
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="./theme/stylesheet/style.min.css">


    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
          href="./theme/pygments/github.min.css">



  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/solid.css">


  <link rel="shortcut icon" href="./images/favicon.ico" type="image/x-icon">
  <link rel="icon" href="./images/favicon.ico" type="image/x-icon">










 

<meta name="author" content="Walter Fan" />
<meta name="description" content="AI 能让你写代码快 10 倍，但如果没有护法加持，你可能在以 10 倍速度制造技术债。本文介绍 AI 辅助编程时代的三大护法：可验证性（TDD）、可观测性（MDD）、可理解性（活文档），帮你驯服 AI 这匹烈马。" />
<meta name="keywords" content="AI, TDD, MDD, 可验证性, 可观测性, 可理解性, 编程方法论">


  <meta property="og:site_name" content="Walter Fan's Blog"/>
  <meta property="og:title" content="AI 辅助编程的三大护法：可验证性、可观测性、可理解性"/>
  <meta property="og:description" content="AI 能让你写代码快 10 倍，但如果没有护法加持，你可能在以 10 倍速度制造技术债。本文介绍 AI 辅助编程时代的三大护法：可验证性（TDD）、可观测性（MDD）、可理解性（活文档），帮你驯服 AI 这匹烈马。"/>
  <meta property="og:locale" content="en_US"/>
  <meta property="og:url" content="./ai-fu-zhu-bian-cheng-de-san-da-hu-fa-ke-yan-zheng-xing-ke-guan-ce-xing-ke-li-jie-xing.html"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="2026-01-30 15:30:00+08:00"/>
  <meta property="article:modified_time" content="2026-01-30 19:00:00+08:00"/>
  <meta property="article:author" content="./author/walter-fan.html">
  <meta property="article:section" content="Journal"/>
  <meta property="article:tag" content="AI"/>
  <meta property="article:tag" content="TDD"/>
  <meta property="article:tag" content="MDD"/>
  <meta property="article:tag" content="可验证性"/>
  <meta property="article:tag" content="可观测性"/>
  <meta property="article:tag" content="可理解性"/>
  <meta property="article:tag" content="编程方法论"/>
  <meta property="og:image" content="./images/walterfan.jpg">

  <title>Walter Fan's Blog &ndash; AI 辅助编程的三大护法：可验证性、可观测性、可理解性</title>


</head>
<body class="light-theme">

<aside>
  <div>
    <a href="./">
      <img src="./images/walterfan.jpg" alt="Walter Fan" title="Walter Fan">
    </a>

    <h1>
      <a href="./">Walter Fan</a>
    </h1>

    <p>手握灵珠常奋笔, 心开天籁不吹箫</p>


    <nav>
      <ul class="list">



          <li>
            <a target="_blank" href="tao.html" >tao</a>
          </li>
          <li>
            <a target="_blank" href="interest.html" >interest</a>
          </li>
          <li>
            <a target="_blank" href="article.html" >article</a>
          </li>
          <li>
            <a target="_self" href="/wordpress" >notebook</a>
          </li>
          <li>
            <a target="_blank" href="bookmark.html" >bookmark</a>
          </li>
          <li>
            <a target="_blank" href="manual.html" >manual</a>
          </li>
          <li>
            <a target="_self" href="/webrtc/examples/index.html" >webrtc</a>
          </li>
          <li>
            <a target="_blank" href="https://github.com/walterfan" >github</a>
          </li>
      </ul>
    </nav>

    <ul class="social">
      <li>
        <a class="sc-github"
           href="http://github.com/walterfan"
           target="_blank">
          <i class="fa-brands fa-github"></i>
        </a>
      </li>
    </ul>
  </div>

</aside>
  <main>


<article class="single">
  <header>
      
    <h1 id="ai-fu-zhu-bian-cheng-de-san-da-hu-fa-ke-yan-zheng-xing-ke-guan-ce-xing-ke-li-jie-xing">AI 辅助编程的三大护法：可验证性、可观测性、可理解性</h1>
    <p>
      Posted on Fri 30 January 2026 in <a href="./category/journal.html">Journal</a>

    </p>
  </header>


  <div>
    <table>
<thead>
<tr>
<th><strong>Abstract</strong></th>
<th>AI 辅助编程的三大护法</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Authors</strong></td>
<td><a href="https://www.fanyamin.com">Walter Fan</a></td>
</tr>
<tr>
<td><strong>Category</strong></td>
<td>编程方法论</td>
</tr>
<tr>
<td><strong>Status</strong></td>
<td>v1.1</td>
</tr>
<tr>
<td><strong>Updated</strong></td>
<td>2026-01-30</td>
</tr>
<tr>
<td><strong>License</strong></td>
<td><a href="http://creativecommons.org/licenses/by-nc-nd/4.0">CC-BY-NC-ND 4.0</a></td>
</tr>
</tbody>
</table>
<h1 id="ai">AI 辅助编程的三大护法：可验证性、可观测性、可理解性</h1>
<h2 id="ai_1">开篇：AI 写代码快，但你怎么确定它写对了？</h2>
<p>周五下午，小李兴冲冲地给我演示他的新技能：</p>
<blockquote>
<p>"看！我让 Claude 帮我生成了一个 WebRTC 的连接管理模块，500 行代码，5 分钟搞定！"</p>
</blockquote>
<p>我瞥了一眼屏幕，问了他三个问题：</p>
<ol>
<li>"你怎么知道它能用？" —— 小李："这个……我觉得逻辑应该没问题……"</li>
<li>"上线之后怎么监控？" —— 小李："呃……先上了再说？"</li>
<li>"三个月后你还能看懂这段代码吗？" —— 小李："……"</li>
</ol>
<p>这就是当下 AI 辅助编程最大的悖论：<strong>AI 能让你写代码快 10 倍，但如果配套方法跟不上，你可能在以 10 倍速度制造技术债。</strong></p>
<p>要驯服 AI 这匹烈马，你需要三大护法：</p>
<table>
<thead>
<tr>
<th>护法</th>
<th>核心问题</th>
<th>实现方法</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>可验证性</strong></td>
<td>AI 写对了吗？</td>
<td>TDD（测试驱动开发）</td>
</tr>
<tr>
<td><strong>可观测性</strong></td>
<td>代码跑得怎样？</td>
<td>MDD（度量驱动开发）</td>
</tr>
<tr>
<td><strong>可理解性</strong></td>
<td>人能看懂吗？</td>
<td>活文档（Living Documentation）</td>
</tr>
</tbody>
</table>
<p>它们不仅能帮你确认"AI 写对了吗"，更能在一开始就让 AI <strong>"带着镣铐跳舞"</strong>，生成更可靠、更易维护的代码。</p>
<p>今天我们就聊聊：<strong>如何让 AI 一开始就 Build in 这三大护法？</strong></p>
<hr>
<h2 id="ai_2">为什么这三大特性在 AI 时代更重要了？</h2>
<h3 id="vs-ai">传统开发 vs AI 辅助开发的本质差异</h3>
<table>
<thead>
<tr>
<th>维度</th>
<th>传统开发</th>
<th>AI 辅助开发</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>代码来源</strong></td>
<td>你自己写，边写边想</td>
<td>AI 生成，你可能看都没仔细看</td>
</tr>
<tr>
<td><strong>理解程度</strong></td>
<td>每行代码都在你脑子里</td>
<td>可能只理解了大概逻辑</td>
</tr>
<tr>
<td><strong>验证方式</strong></td>
<td>边写边测，出问题立刻知道</td>
<td>生成完了才发现，调试成本高</td>
</tr>
<tr>
<td><strong>质量控制</strong></td>
<td>靠经验和 Code Review</td>
<td>靠测试用例和指标监控</td>
</tr>
<tr>
<td><strong>维护成本</strong></td>
<td>自己写的，改起来有底</td>
<td>AI 写的，改的时候怕牵一发动全身</td>
</tr>
</tbody>
</table>
<p><strong>问题在哪？</strong></p>
<p>AI 生成代码的速度远超人类阅读和理解的速度。你可能还没搞清楚第 100 行在干什么，AI 已经给你写完 500 行了。</p>
<p>这时候：
- <strong>没有可验证性</strong>（测试用例）→ 你根本不知道 AI 的理解和你的预期是否一致
- <strong>没有可观测性</strong>（度量指标）→ 你不知道代码上线后会不会崩、会不会慢、会不会漏内存
- <strong>没有可理解性</strong>（活文档）→ 三个月后你看这段代码，就像看别人写的一样陌生</p>
<p><strong>三大护法的价值就在于：它们把"质量保障"前置了，而不是等出了问题再补救。</strong></p>
<hr>
<h2 id="tdd">护法一：可验证性（TDD）</h2>
<blockquote>
<p><em>"不能验证的代码，就是薛定谔的代码——你不跑测试，永远不知道它是对是错。"</em></p>
</blockquote>
<h3 id="tdd60">什么是 TDD？（60 秒回顾）</h3>
<p>测试驱动开发的核心流程：
1. <strong>Red</strong>：先写一个会失败的测试（因为功能还不存在）
2. <strong>Green</strong>：写最少的代码让测试通过
3. <strong>Refactor</strong>：在测试保护下重构代码</p>
<p><strong>听起来很基础？但在 AI 时代，它变成了"约束 AI 行为的最佳工具"。</strong></p>
<h3 id="ai-build-in-tdd">如何让 AI Build in TDD？</h3>
<h4 id="1-ai-prompt">场景 1：给 AI 一个"测试先行"的 Prompt</h4>
<p>❌ <strong>错误示范</strong>：</p>
<div class="highlight"><pre><span></span><code>帮我写一个 WebRTC PeerConnection 的封装类，支持音视频通话。
</code></pre></div>

<p>AI 会给你一大堆代码，但你不知道：
- 它处理了哪些边界情况？
- 异常场景会不会崩？
- 能不能处理网络抖动？</p>
<p>✅ <strong>正确示范</strong>：</p>
<div class="highlight"><pre><span></span><code>我需要一个 WebRTC PeerConnection 的封装类。

请按照 TDD 流程：
1. 先写出关键场景的测试用例（至少包括正常流程、网络中断、对端离线三个场景）
2. 再实现代码让测试通过
3. 确保测试覆盖率 &gt; 80%

测试用例应该包括：
- 正常建立连接
- Offer/Answer 交换失败
- ICE 候选收集超时
- 网络中断后重连
- 优雅关闭连接

用 pytest 框架，给我可直接运行的代码。
</code></pre></div>

<p><strong>变化在哪？</strong>
- AI 需要先<strong>理解验收标准</strong>（测试用例），再写实现
- 你可以在 AI 开始写代码前，先<strong>Review 测试用例</strong>，确认理解一致
- 测试用例就是"可执行的需求文档"</p>
<h4 id="2-ai">场景 2：让 AI 生成"自证清白"的代码</h4>
<p>很多时候，你不是要 AI 写测试，而是要它<strong>生成带测试的代码</strong>。</p>
<p><strong>Prompt 模板</strong>：</p>
<div class="highlight"><pre><span></span><code>请用 TDD 方式实现一个 [功能描述]。

要求：
1. 先给出测试用例（用 [测试框架] 编写）
2. 测试用例要覆盖：正常流程、边界条件、异常场景
3. 实现代码要让所有测试通过
4. 给出运行测试的命令

输出格式：
- test_[模块名].py：测试代码
- [模块名].py：实现代码
- README.md：如何运行测试
</code></pre></div>

<p><strong>示例输出</strong>：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># AI 生成的测试</span>
pytest<span class="w"> </span>test_webrtc_manager.py<span class="w"> </span>-v<span class="w"> </span>--cov<span class="o">=</span>webrtc_manager<span class="w"> </span>--cov-report<span class="o">=</span>html
</code></pre></div>

<p>你可以<strong>立刻验证</strong> AI 的理解是否正确，而不是等到集成测试才发现问题。</p>
<hr>
<h2 id="mdd">护法二：可观测性（MDD）</h2>
<blockquote>
<p><em>"不可测量的，就无法改进。不可观测的，就无法排障。"</em></p>
</blockquote>
<h3 id="mdd_1">什么是 MDD？（用一个故事说清楚）</h3>
<p>上周我们的服务出了个诡异的问题：<strong>用户投诉卡顿，但 CPU、内存、网络指标都正常。</strong></p>
<p>排查了一整天，最后发现是：<strong>WebSocket 连接数超过了系统限制，但我们没监控这个指标。</strong></p>
<p><em>"不可测量的，就无法改进。"</em></p>
<p>MDD 的核心思想：<strong>代码上线时，就应该自带关键指标的监控能力。</strong></p>
<h3 id="ai-build-in-mdd">如何让 AI Build in MDD？</h3>
<h4 id="1-prompt">场景 1：在 Prompt 里明确度量需求</h4>
<p>❌ <strong>错误示范</strong>：</p>
<div class="highlight"><pre><span></span><code>帮我写一个 HTTP 请求重试逻辑。
</code></pre></div>

<p>AI 会给你一个能用的实现，但你不知道：
- 重试了几次？
- 哪些请求在重试？
- 重试成功率多少？</p>
<p>✅ <strong>正确示范</strong>：</p>
<div class="highlight"><pre><span></span><code>我需要一个带指标监控的 HTTP 请求重试逻辑。

功能要求：
- 支持指数退避重试（最多 3 次）
- 可配置重试条件（哪些状态码需要重试）

度量要求（用 Prometheus metrics）：
- http_request_total: 总请求数（按 method, path, status_code 分类）
- http_request_retry_total: 重试次数
- http_request_retry_success_rate: 重试成功率
- http_request_duration_seconds: 请求耗时分布

请生成：
1. 实现代码（包含埋点）
2. Grafana 监控面板配置（JSON）
3. 告警规则（重试成功率 &lt; 50% 时告警）
</code></pre></div>

<p><strong>AI 会给你什么？</strong>
- 一个带埋点的实现
- 可直接导入的 Grafana 面板
- 现成的告警规则</p>
<p><strong>你的收益？</strong>
- 代码上线第一天，就能看到关键指标
- 出问题时，5 分钟定位，而不是 5 小时</p>
<h4 id="2-ai_1">场景 2：让 AI 生成"度量设计文档"</h4>
<p>对于复杂系统，可以让 AI 先设计度量方案：</p>
<div class="highlight"><pre><span></span><code>我要实现一个分布式任务调度系统。

请先给出度量设计方案，包括：
1. 关键指标清单（Golden Signals: Latency, Traffic, Errors, Saturation）
2. 每个指标的采集方式（Gauge / Counter / Histogram）
3. 监控面板布局建议
4. SLO 定义（可用性目标、性能目标）

然后再实现代码。
</code></pre></div>

<p><strong>为什么要这样？</strong></p>
<p>因为度量设计比代码实现更难。如果一开始方向错了，埋再多点也没用。</p>
<hr>
<h2 id="ai_3">实战：一个完整的 AI 辅助开发流程</h2>
<p>假设你要让 AI 帮你实现一个"实时消息推送服务"。</p>
<h3 id="step-1tdd">Step 1：定义验收测试（TDD）</h3>
<div class="highlight"><pre><span></span><code><span class="gu">## 验收测试用例</span>

<span class="gu">### 正常流程</span>
<span class="k">-</span><span class="w"> </span>用户 A 发送消息，用户 B 能在 100ms 内收到
<span class="k">-</span><span class="w"> </span>支持 10000 个并发连接

<span class="gu">### 边界条件</span>
<span class="k">-</span><span class="w"> </span>用户离线时，消息能缓存 24 小时
<span class="k">-</span><span class="w"> </span>单个用户消息队列 &gt; 1000 条时，触发限流

<span class="gu">### 异常场景</span>
<span class="k">-</span><span class="w"> </span>WebSocket 连接中断，自动重连（最多 3 次）
<span class="k">-</span><span class="w"> </span>Redis 挂掉，降级到内存队列
</code></pre></div>

<p><strong>发给 AI 的 Prompt</strong>：</p>
<div class="highlight"><pre><span></span><code>请根据以上验收测试用例，用 pytest 写出测试代码。

包括：
- 单元测试（测试消息队列、限流逻辑）
- 集成测试（测试完整推送流程）
- 性能测试（用 locust 模拟 10000 并发）
</code></pre></div>

<h3 id="step-2mdd">Step 2：定义度量指标（MDD）</h3>
<div class="highlight"><pre><span></span><code><span class="gu">## 关键指标</span>

<span class="gu">### RED Metrics</span>
<span class="k">-</span><span class="w"> </span><span class="gs">**Request Rate**</span>: 每秒推送消息数
<span class="k">-</span><span class="w"> </span><span class="gs">**Error Rate**</span>: 推送失败率（目标 &lt; 0.1%）
<span class="k">-</span><span class="w"> </span><span class="gs">**Duration**</span>: P99 推送延迟（目标 &lt; 100ms）

<span class="gu">### 业务指标</span>
<span class="k">-</span><span class="w"> </span>active_connections: 当前活跃连接数
<span class="k">-</span><span class="w"> </span>message_queue_depth: 待推送消息队列深度
<span class="k">-</span><span class="w"> </span>offline_message_count: 离线消息数量

<span class="gu">### 资源指标</span>
<span class="k">-</span><span class="w"> </span>CPU 使用率
<span class="k">-</span><span class="w"> </span>内存使用率
<span class="k">-</span><span class="w"> </span>Redis 连接数
</code></pre></div>

<p><strong>发给 AI 的 Prompt</strong>：</p>
<div class="highlight"><pre><span></span><code>请在实现代码中加入以上指标的埋点（用 Prometheus Python Client）。

并生成：
1. Grafana 监控面板配置
2. 告警规则（推送失败率 &gt; 1% 或 P99 延迟 &gt; 200ms 时告警）
</code></pre></div>

<h3 id="step-3-ai">Step 3：让 AI 生成代码</h3>
<div class="highlight"><pre><span></span><code>请实现实时消息推送服务，要求：

1. 按照之前的测试用例，确保所有测试通过
2. 按照之前的度量方案，加入指标埋点
3. 使用 FastAPI + Redis + WebSocket
4. 代码要包含：
   - 核心实现（message_service.py）
   - 测试代码（test_message_service.py）
   - 度量埋点（metrics.py）
   - Docker Compose 配置（包含 Prometheus + Grafana）
   - README（如何运行、如何查看监控）

给我可以直接运行的完整项目。
</code></pre></div>

<h3 id="step-4">Step 4：验证和迭代</h3>
<div class="highlight"><pre><span></span><code><span class="c1"># 1. 运行测试</span>
pytest<span class="w"> </span>test_message_service.py<span class="w"> </span>-v<span class="w"> </span>--cov

<span class="c1"># 2. 启动服务</span>
docker-compose<span class="w"> </span>up<span class="w"> </span>-d

<span class="c1"># 3. 查看监控面板</span>
open<span class="w"> </span>http://localhost:3000<span class="w">  </span><span class="c1"># Grafana</span>

<span class="c1"># 4. 运行性能测试</span>
locust<span class="w"> </span>-f<span class="w"> </span>load_test.py
</code></pre></div>

<p><strong>如果测试失败或指标异常？</strong></p>
<p>给 AI 反馈：</p>
<div class="highlight"><pre><span></span><code>测试用例 test_offline_message_cache 失败了，错误信息：
[粘贴错误日志]

请修复代码，并解释为什么会失败。
</code></pre></div>

<hr>
<h2 id="_1">护法三：可理解性（活文档）</h2>
<blockquote>
<p><em>"代码写完能跑只是开始，能被人理解才是真正的结束。"</em></p>
</blockquote>
<p>前两个护法解决了"AI 写对了吗"和"跑起来怎么样"，但还有一个问题：<strong>三个月后你还能看懂这段代码吗？</strong></p>
<p>AI 生成的代码有个特点：它可能在逻辑上完全正确，但阅读体验很糟糕——变量命名随意、逻辑跳跃、缺少解释。你当时觉得"能跑就行"，三个月后改需求时欲哭无泪。</p>
<h3 id="_2">什么是活文档？</h3>
<p><strong>活文档（Living Documentation）</strong> 的概念来自 Cyrille Martraire 的《活文档：与代码共同演进》一书。</p>
<p>最初的灵感来自 BDD（行为驱动开发）：团队编写的测试用例既是需求说明，又是自动化测试。只要测试全部通过，这个文档就始终保持最新——这就是"活"的含义。</p>
<p><strong>活文档的四个原则</strong>：</p>
<table>
<thead>
<tr>
<th>原则</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>可靠</strong></td>
<td>无论何时，活文档都是准确的，与所交付的软件保持同步</td>
</tr>
<tr>
<td><strong>省力</strong></td>
<td>最小化文档工作量，软件变更时只需极少的额外工作</td>
</tr>
<tr>
<td><strong>协作</strong></td>
<td>促进所有参与者之间的对话和知识共享</td>
</tr>
<tr>
<td><strong>有见地</strong></td>
<td>引导注意力，提供反馈机会，鼓励深入思考</td>
</tr>
</tbody>
</table>
<p><strong>活文档的两种形式</strong>：
- <strong>外部文档</strong>：README、Wiki、架构图、运维手册
- <strong>固有文档</strong>：注解、注释、测试用例、配置文件</p>
<p>关键观点：<strong>存储文档的最佳位置是被记录的事物本身</strong>。比如 API 文档最好就写在 API 定义旁边（OpenAPI），而不是单独维护一个 Word。</p>
<p>另一个重要原则：<strong>文档应该尽量自动化生成，不仅要让人容易阅读，还要让机器容易阅读</strong>。这在 AI 辅助编程时代尤为重要——AI 可以帮你从代码生成文档，也可以从文档理解代码。</p>
<h3 id="sdd">SDD：实现活文档的一种方法</h3>
<p><strong>SDD（Spec-Driven Development，规格驱动开发）</strong> 是实现活文档的有效方法：<strong>先写规格说明，再写代码实现。</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>核心思想</th>
<th>产出物</th>
</tr>
</thead>
<tbody>
<tr>
<td>TDD</td>
<td>先写测试，再写实现</td>
<td>测试用例</td>
</tr>
<tr>
<td>MDD</td>
<td>先定指标，再写实现</td>
<td>度量方案</td>
</tr>
<tr>
<td>SDD</td>
<td>先写规格，再写实现</td>
<td>规格文档</td>
</tr>
</tbody>
</table>
<p>SDD 的"规格"（Spec）可以是：
- <strong>API 规格</strong>：OpenAPI/Swagger 定义接口契约
- <strong>数据规格</strong>：JSON Schema 定义数据结构
- <strong>架构规格</strong>：ADR（Architecture Decision Record）记录设计决策
- <strong>行为规格</strong>：用 Gherkin 语法描述用户故事</p>
<p><strong>SDD 在 AI 编程中的价值</strong>：当你先写清楚"系统应该是什么样"，AI 就能生成更符合预期的代码，而且这些规格本身就成为了活文档。</p>
<h3 id="_3">可理解性的三个层次</h3>
<div class="highlight"><pre><span></span><code>              架构文档
          （系统是怎么设计的？）
                 │
                 ▼
              运维手册
          （怎么部署、怎么排障？）
                 │
                 ▼
              代码注释
          （这段代码为什么这样写？）
</code></pre></div>

<h3 id="ai-build-in">如何让 AI Build in 可理解性？</h3>
<h4 id="1">层次 1：代码注释——解释"为什么"而不是"做什么"</h4>
<p>❌ <strong>错误示范</strong>（AI 默认生成的）：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 计算重试延迟</span>
<span class="n">delay</span> <span class="o">=</span> <span class="n">base_delay</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">attempt</span><span class="p">)</span>
</code></pre></div>

<p>✅ <strong>正确示范</strong>（你应该要求的）：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 使用指数退避策略避免雪崩效应</span>
<span class="c1"># 为什么选择 2 倍增长？实测发现线性增长在高并发下效果不好</span>
<span class="c1"># 为什么有上限？防止单次重试等待时间过长，影响用户体验</span>
<span class="n">delay</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">base_delay</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">attempt</span><span class="p">),</span> <span class="n">max_delay</span><span class="p">)</span>
</code></pre></div>

<p><strong>Prompt 模板</strong>：</p>
<div class="highlight"><pre><span></span><code>请在代码中加入注释，要求：
1. 每个函数有 docstring（包括参数、返回值、可能的异常）
2. 复杂逻辑要解释&quot;为什么这样设计&quot;，而不是重复代码在做什么
3. 关键的设计决策要用注释记录（比如为什么选择这个算法、这个阈值）
4. 不要写废话注释（如 &quot;# 循环遍历列表&quot;）
</code></pre></div>

<h4 id="2-5">层次 2：架构文档——让人 5 分钟看懂系统全貌</h4>
<p><strong>Prompt 模板</strong>：</p>
<div class="highlight"><pre><span></span><code>请为这个系统生成架构文档，包括：

1. 系统架构图（用 Mermaid 绘制）：
   - 核心组件及其职责
   - 组件之间的调用关系
   - 外部依赖（数据库、消息队列、第三方服务）

2. 数据流图：
   - 请求从进入到响应的完整路径
   - 数据在各组件间的转换

3. 关键设计决策：
   - 为什么选择这个技术栈？
   - 有哪些 trade-off？
   - 未来可能的扩展点？
</code></pre></div>

<p><strong>示例输出</strong>（AI 生成的 Mermaid 架构图）：</p>
<div class="highlight"><pre><span></span><code>graph TB
    subgraph Client
        A[Web Client] --&gt; B[API Gateway]
        C[Mobile App] --&gt; B
    end

    subgraph Backend
        B --&gt; D[Auth Service]
        B --&gt; E[Message Service]
        E --&gt; F[(Redis)]
        E --&gt; G[(PostgreSQL)]
        E --&gt; H[Notification Worker]
    end

    subgraph Monitoring
        E --&gt; I[Prometheus]
        I --&gt; J[Grafana]
    end
</code></pre></div>

<h4 id="3-10">层次 3：运维手册——让人 10 分钟能排障</h4>
<p><strong>Prompt 模板</strong>：</p>
<div class="highlight"><pre><span></span><code>请生成一个 RUNBOOK.md 运维手册，包括：

1. 快速启动：
   - 环境要求
   - 一键部署命令
   - 健康检查方法

2. 常见问题排查：
   - 问题现象 → 可能原因 → 排查步骤 → 解决方案
   - 至少覆盖 5 个常见问题

3. 监控告警：
   - 关键指标说明
   - 告警处理 SOP
   - 扩缩容建议

4. 回滚方案：
   - 如何快速回滚到上一版本
   - 数据兼容性注意事项
</code></pre></div>

<h3 id="_4">可理解性的"黄金检验"</h3>
<p>问自己三个问题：</p>
<ol>
<li><strong>新人检验</strong>：一个刚入职的同事，能在 30 分钟内理解这个系统的核心逻辑吗？</li>
<li><strong>深夜检验</strong>：凌晨 3 点收到告警，你能在 10 分钟内定位问题吗？</li>
<li><strong>半年检验</strong>：半年后你回来改这段代码，能快速上手吗？</li>
</ol>
<p>如果答案是"不能"，说明可理解性还不够。</p>
<hr>
<h2 id="_5">三大护法的"黄金三角"</h2>
<p>三大护法不是孤立的，它们相互支撑：</p>
<div class="highlight"><pre><span></span><code>              可验证性（TDD）
             &quot;确保写对了&quot;
                   ▲
                  / \
                 /   \
                /     \
               /       \
              /    ◉    \
             /   质量    \
            /   保障     \
           ▼             ▼
   可观测性（MDD）    可理解性（活文档）
  &quot;确保跑得好&quot;       &quot;确保看得懂&quot;
</code></pre></div>

<table>
<thead>
<tr>
<th>缺少哪个？</th>
<th>会怎样？</th>
</tr>
</thead>
<tbody>
<tr>
<td>缺可验证性</td>
<td>不知道对不对，线上出问题才发现</td>
</tr>
<tr>
<td>缺可观测性</td>
<td>出了问题定位不了，只能瞪眼</td>
</tr>
<tr>
<td>缺可理解性</td>
<td>改不动，越改越乱，最后只能重写</td>
</tr>
</tbody>
</table>
<p><strong>一个都不能少。</strong></p>
<hr>
<h2 id="langchain">代码示例：用 LangChain 实现"三大护法先行"</h2>
<p>理论讲完了，来看一个简短的代码示例。核心思路：<strong>让 AI 按顺序生成测试 → 指标 → 实现 → 文档，而不是一上来就写代码。</strong></p>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;三大护法代码生成器（简化版）&quot;&quot;&quot;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">langchain_openai</span><span class="w"> </span><span class="kn">import</span> <span class="n">ChatOpenAI</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">langchain_core.prompts</span><span class="w"> </span><span class="kn">import</span> <span class="n">ChatPromptTemplate</span>

<span class="n">llm</span> <span class="o">=</span> <span class="n">ChatOpenAI</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;gpt-4o&quot;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">generate_with_three_guards</span><span class="p">(</span><span class="n">requirement</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;按顺序生成：测试 → 指标 → 实现 → 文档&quot;&quot;&quot;</span>

    <span class="c1"># Step 1: 可验证性 - 先生成测试用例</span>
    <span class="n">test_prompt</span> <span class="o">=</span> <span class="n">ChatPromptTemplate</span><span class="o">.</span><span class="n">from_template</span><span class="p">(</span>
        <span class="s2">&quot;根据需求生成 pytest 测试用例，覆盖正常/边界/异常场景：</span><span class="se">\n</span><span class="si">{requirement}</span><span class="s2">&quot;</span>
    <span class="p">)</span>
    <span class="n">tests</span> <span class="o">=</span> <span class="p">(</span><span class="n">test_prompt</span> <span class="o">|</span> <span class="n">llm</span><span class="p">)</span><span class="o">.</span><span class="n">invoke</span><span class="p">({</span><span class="s2">&quot;requirement&quot;</span><span class="p">:</span> <span class="n">requirement</span><span class="p">})</span>

    <span class="c1"># Step 2: 可观测性 - 设计度量指标</span>
    <span class="n">metrics_prompt</span> <span class="o">=</span> <span class="n">ChatPromptTemplate</span><span class="o">.</span><span class="n">from_template</span><span class="p">(</span>
        <span class="s2">&quot;为以下需求设计 Prometheus 指标（包含 RED Metrics）：</span><span class="se">\n</span><span class="si">{requirement}</span><span class="s2">&quot;</span>
    <span class="p">)</span>
    <span class="n">metrics</span> <span class="o">=</span> <span class="p">(</span><span class="n">metrics_prompt</span> <span class="o">|</span> <span class="n">llm</span><span class="p">)</span><span class="o">.</span><span class="n">invoke</span><span class="p">({</span><span class="s2">&quot;requirement&quot;</span><span class="p">:</span> <span class="n">requirement</span><span class="p">})</span>

    <span class="c1"># Step 3: 生成实现 - 带约束！</span>
    <span class="n">impl_prompt</span> <span class="o">=</span> <span class="n">ChatPromptTemplate</span><span class="o">.</span><span class="n">from_template</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">根据需求实现代码，必须满足：</span>
<span class="s2">1. 让以下测试通过：</span><span class="si">{tests}</span>
<span class="s2">2. 包含以下指标埋点：</span><span class="si">{metrics}</span>
<span class="s2">3. 关键函数要有 docstring</span>
<span class="s2">需求：</span><span class="si">{requirement}</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">implementation</span> <span class="o">=</span> <span class="p">(</span><span class="n">impl_prompt</span> <span class="o">|</span> <span class="n">llm</span><span class="p">)</span><span class="o">.</span><span class="n">invoke</span><span class="p">({</span>
        <span class="s2">&quot;requirement&quot;</span><span class="p">:</span> <span class="n">requirement</span><span class="p">,</span> 
        <span class="s2">&quot;tests&quot;</span><span class="p">:</span> <span class="n">tests</span><span class="o">.</span><span class="n">content</span><span class="p">,</span>
        <span class="s2">&quot;metrics&quot;</span><span class="p">:</span> <span class="n">metrics</span><span class="o">.</span><span class="n">content</span>
    <span class="p">})</span>

    <span class="c1"># Step 4: 可理解性 - 生成活文档</span>
    <span class="n">doc_prompt</span> <span class="o">=</span> <span class="n">ChatPromptTemplate</span><span class="o">.</span><span class="n">from_template</span><span class="p">(</span>
        <span class="s2">&quot;用 Mermaid 画出以下代码的架构图，并写一个 RUNBOOK.md：</span><span class="se">\n</span><span class="si">{code}</span><span class="s2">&quot;</span>
    <span class="p">)</span>
    <span class="n">docs</span> <span class="o">=</span> <span class="p">(</span><span class="n">doc_prompt</span> <span class="o">|</span> <span class="n">llm</span><span class="p">)</span><span class="o">.</span><span class="n">invoke</span><span class="p">({</span><span class="s2">&quot;code&quot;</span><span class="p">:</span> <span class="n">implementation</span><span class="o">.</span><span class="n">content</span><span class="p">})</span>

    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;tests&quot;</span><span class="p">:</span> <span class="n">tests</span><span class="p">,</span> <span class="s2">&quot;metrics&quot;</span><span class="p">:</span> <span class="n">metrics</span><span class="p">,</span> <span class="s2">&quot;code&quot;</span><span class="p">:</span> <span class="n">implementation</span><span class="p">,</span> <span class="s2">&quot;docs&quot;</span><span class="p">:</span> <span class="n">docs</span><span class="p">}</span>
</code></pre></div>

<p><strong>核心设计要点</strong>：</p>
<ol>
<li><strong>强制顺序</strong>：先 <code>tests</code>，再 <code>metrics</code>，再 <code>implementation</code>，最后 <code>docs</code></li>
<li><strong>约束传递</strong>：生成实现时，把前两步的输出作为约束条件传入</li>
<li><strong>可 Review</strong>：每一步的输出都可以人工检查，发现问题及早纠正</li>
</ol>
<p><strong>运行效果</strong>：</p>
<div class="highlight"><pre><span></span><code>Step 1: ✅ 生成了 7 个测试用例（正常 3 + 边界 2 + 异常 2）
Step 2: ✅ 定义了 5 个指标（rate, errors, duration, 业务指标 x2）
Step 3: ✅ 生成了实现代码（含埋点）
Step 4: ✅ 生成了架构图和 RUNBOOK.md
</code></pre></div>

<p>这就是"带着镣铐跳舞"：<strong>AI 不是自由发挥，而是在测试用例和度量指标的约束下生成代码。</strong></p>
<hr>
<h2 id="ai_4">实战检查清单：让 AI 自带"三大护法"</h2>
<p>下次让 AI 帮你写代码时，带上这份清单：</p>
<h3 id="tdd_1">✅ 可验证性检查项（TDD）</h3>
<ul>
<li>[ ] 明确验收标准（正常流程、边界条件、异常场景）</li>
<li>[ ] 让 AI 先写测试用例，你 Review 后再实现</li>
<li>[ ] 确保测试覆盖率 &gt; 80%</li>
<li>[ ] 包含单元测试、集成测试、性能测试</li>
<li>[ ] 提供一键运行测试的脚本</li>
</ul>
<h3 id="mdd_2">✅ 可观测性检查项（MDD）</h3>
<ul>
<li>[ ] 定义关键指标（RED Metrics + 业务指标 + 资源指标）</li>
<li>[ ] 在代码中加入埋点（Prometheus / StatsD / OpenTelemetry）</li>
<li>[ ] 生成监控面板（Grafana / Datadog）</li>
<li>[ ] 配置告警规则（SLO 违反时触发）</li>
<li>[ ] 写出指标查询示例（PromQL / Grafana 变量）</li>
</ul>
<h3 id="_6">✅ 可理解性检查项（活文档）</h3>
<ul>
<li>[ ] 考虑用 SDD 方式：先写规格说明（OpenAPI / JSON Schema / ADR）</li>
<li>[ ] 关键函数有清晰的 docstring（参数、返回值、异常）</li>
<li>[ ] 复杂逻辑有"为什么这样设计"的注释</li>
<li>[ ] 有系统架构图（Mermaid / PlantUML）</li>
<li>[ ] 有运维手册 RUNBOOK.md（部署、监控、排查）</li>
<li>[ ] README 包含快速开始指南和设计决策说明</li>
</ul>
<hr>
<h2 id="ai_5">结语：AI 是助手，但方向盘在你手里</h2>
<p>三大护法不是什么新东西，但在 AI 辅助编程时代，它们的价值被重新放大了：</p>
<ul>
<li><strong>可验证性</strong> 让你在 AI 写代码前，就明确"什么叫做对"</li>
<li><strong>可观测性</strong> 让你在代码上线后，能快速知道"它运行得怎么样"</li>
<li><strong>可理解性</strong> 让你在三个月后，还能看懂并修改这段代码</li>
</ul>
<p>换句话说：
- 可验证性是"<strong>事前控制</strong>"：确保 AI 朝着正确的方向跑
- 可观测性是"<strong>事后监控</strong>"：确保代码在生产环境不翻车
- 可理解性是"<strong>长期维护</strong>"：确保代码不会变成没人敢动的"祖传代码"</p>
<p><strong>最后一个建议</strong>：</p>
<p>不要一上来就让 AI 生成 500 行代码。先让它：
1. 写 10 个测试用例（你 Review）—— 可验证性
2. 定义 5 个关键指标（你确认）—— 可观测性
3. 画一张架构图（你理解）—— 可理解性
4. 再开始写实现</p>
<p><strong>这样你花 15 分钟前期准备，能省下 3 小时后期调试和维护时间。</strong></p>
<hr>
<h2 id="_7">核心要点回顾</h2>
<table>
<thead>
<tr>
<th>护法</th>
<th>核心问题</th>
<th>实现方法</th>
<th>如何让 AI Build in</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>可验证性</strong></td>
<td>AI 写对了吗？</td>
<td>TDD</td>
<td>在 Prompt 里先要求测试用例，再要求实现</td>
</tr>
<tr>
<td><strong>可观测性</strong></td>
<td>代码跑得怎样？</td>
<td>MDD</td>
<td>在 Prompt 里明确度量指标和埋点要求</td>
</tr>
<tr>
<td><strong>可理解性</strong></td>
<td>人能看懂吗？</td>
<td>活文档</td>
<td>在 Prompt 里要求注释、架构图、运维手册，或先写规格再实现</td>
</tr>
</tbody>
</table>
<p><strong>一句话总结</strong>：</p>
<blockquote>
<p><em>"在 AI 时代，测试用例是你的'验收报告'，度量指标是你的'仪表盘'，文档是你的'地图'。三者缺一，你就是在用 10 倍速度制造技术债。"</em></p>
</blockquote>
<hr>
<h2 id="_8">行动清单</h2>
<p>下次让 AI 帮你写代码时，按顺序做这些事：</p>
<h3 id="_9">🔴 可验证性（先做）</h3>
<ul>
<li>[ ] 在 Prompt 里加上"请先写测试用例"</li>
<li>[ ] Review 测试用例，确认覆盖正常流程、边界条件、异常场景</li>
<li>[ ] 确认后，再让 AI 写实现</li>
<li>[ ] 运行测试，验证全部通过</li>
</ul>
<h3 id="_10">🟡 可观测性（同步做）</h3>
<ul>
<li>[ ] 明确关键度量指标（至少 RED Metrics）</li>
<li>[ ] 要求代码包含埋点（Prometheus / OpenTelemetry）</li>
<li>[ ] 生成监控面板配置</li>
<li>[ ] 配置告警规则</li>
</ul>
<h3 id="_11">🟢 可理解性（活文档）</h3>
<ul>
<li>[ ] 要求关键函数有 docstring</li>
<li>[ ] 复杂逻辑要有"为什么"的注释</li>
<li>[ ] 生成架构图（Mermaid / PlantUML）</li>
<li>[ ] 生成 RUNBOOK.md 运维手册</li>
<li>[ ] （可选）用 SDD 方式：先写规格说明再实现</li>
</ul>
<hr>
<h2 id="_12">思维导图：一图总结三大护法</h2>
<div class="highlight"><pre><span></span><code>@startmindmap
&lt;style&gt;
mindmapDiagram {
  .root {
    BackgroundColor #2C3E50
    FontColor white
    FontSize 16
    FontStyle bold
  }
  .problem {
    BackgroundColor #E74C3C
    FontColor white
  }
  .tdd {
    BackgroundColor #3498DB
    FontColor white
  }
  .mdd {
    BackgroundColor #27AE60
    FontColor white
  }
  .doc {
    BackgroundColor #9B59B6
    FontColor white
  }
  .action {
    BackgroundColor #F39C12
    FontColor white
  }
}
&lt;/style&gt;

*[#2C3E50] AI 辅助编程\n三大护法 &lt;&lt;root&gt;&gt;

left side

**[#E74C3C] 核心问题 &lt;&lt;problem&gt;&gt;
*** AI 写代码快 10 倍
*** 但验证方法跟不上
*** 可能 10 倍速制造技术债
****_ 不知道写对没
****_ 不知道跑得怎样
****_ 三个月后看不懂

**[#3498DB] 护法一：可验证性\n（TDD） &lt;&lt;tdd&gt;&gt;
*** 核心问题
****_ AI 写对了吗？
*** 实现方法
****_ 先写测试用例
****_ 再让 AI 写实现
****_ 测试通过 = 验收通过
*** 关键要点
****_ Red → Green → Refactor
****_ 覆盖正常/边界/异常
****_ 测试覆盖率 &gt; 80%

right side

**[#27AE60] 护法二：可观测性\n（MDD） &lt;&lt;mdd&gt;&gt;
*** 核心问题
****_ 代码跑得怎样？
*** 实现方法
****_ 先定义度量指标
****_ 再让 AI 加埋点
****_ 生成监控面板
*** 关键要点
****_ RED Metrics
****_ 业务指标 + 资源指标
****_ 告警规则

**[#9B59B6] 护法三：可理解性\n（活文档） &lt;&lt;doc&gt;&gt;
*** 核心问题
****_ 人能看懂吗？
*** 四个原则
****_ 可靠：与代码同步
****_ 省力：自动化生成
****_ 协作：促进知识共享
****_ 有见地：引导思考
*** 三个层次
****_ 代码注释（为什么）
****_ 架构文档（全貌）
****_ 运维手册（排障）

**[#F39C12] 行动要点 &lt;&lt;action&gt;&gt;
*** 不要一上来就让 AI 写 500 行
*** 先让 AI 写 10 个测试用例
*** 再定义 5 个关键指标
*** 要求注释和架构图
*** 最后才写实现
@endmindmap
</code></pre></div>

<blockquote>
<p><strong>一句话总结</strong>：测试用例是"验收报告"，度量指标是"仪表盘"，活文档是"地图"。三者缺一，你就是在用 10 倍速度制造技术债。</p>
</blockquote>
<hr>
<p><strong>想了解更多？</strong></p>
<ul>
<li><a href="https://item.jd.com/69315415321.html">微服务之道：度量驱动开发</a> —— MDD 的系统介绍</li>
<li><a href="https://book.douban.com/subject/1230036/">Test-Driven Development by Example - Kent Beck</a> —— TDD 的经典之作</li>
<li><a href="https://book.douban.com/subject/35372829/">活文档：与代码共同演进</a> —— 活文档的系统方法论</li>
<li><a href="https://sre.google/books/">Site Reliability Engineering - Google</a> —— 可观测性的实践指南</li>
</ul>
<hr>
<p>你在用 AI 辅助编程时，遇到过哪些"代码看起来对，但跑起来不对"的坑？
在评论区聊聊你的经验，或者分享你的 TDD/MDD 实践。</p>
<hr>
<hr/>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="./tag/ai.html">AI</a>
      <a href="./tag/tdd.html">TDD</a>
      <a href="./tag/mdd.html">MDD</a>
      <a href="./tag/ke-yan-zheng-xing.html">可验证性</a>
      <a href="./tag/ke-guan-ce-xing.html">可观测性</a>
      <a href="./tag/ke-li-jie-xing.html">可理解性</a>
      <a href="./tag/bian-cheng-fang-fa-lun.html">编程方法论</a>
    </p>
  </div>


  <div class="neighbors">
    <a class="btn float-left" href="./zhi-chang-gong-ju-xiang-zhi-ling-dao-li-mei-you-title-ye-neng-you-ying-xiang-li.html" title="职场工具箱之领导力：没有 Title 也能有影响力">
      <i class="fa fa-angle-left"></i> Previous Post
    </a>
    <a class="btn float-right" href="./agent-skillsgei-ai-zhu-shou-zhuang-shang-ji-neng-bao.html" title="Agent Skills：给 AI 助手装上"技能包"">
      Next Post <i class="fa fa-angle-right"></i>
    </a>
  </div>

  <div class="related-posts">
    <h4>You might enjoy</h4>
    <ul class="related-posts">
      <li><a href="./cong-shou-cuo-workflow-dao-langgraphai-liu-cheng-bian-pai-de-liang-chong-lu-jing.html">从手搓 Workflow 到 LangGraph：AI 流程编排的两种路径</a></li>
      <li><a href="./yong-ai-agent-chu-li-fu-za-liu-cheng-xian-xie-workflowzai-xie-prompt.html">用 AI Agent 处理复杂流程：先写 Workflow，再写 Prompt</a></li>
      <li><a href="./agent-skillsgei-ai-zhu-shou-zhuang-shang-ji-neng-bao.html">Agent Skills：给 AI 助手装上"技能包"</a></li>
      <li><a href="./claude-code-shi-yong-ji-qiao-yu-cheng-ben-kong-zhi-zhi-nan.html">Claude Code 使用技巧与成本控制指南</a></li>
      <li><a href="./prompt-as-codedang-prompt-bu-zhi-shi-hua-er-shi-ke-zhi-xing-de-cheng-xu.html">Prompt-as-Code：当 Prompt 不只是"话"，而是可执行的"程序"</a></li>
    </ul>
  </div>



<!-- Disqus -->
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'wfblog';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>
    Please enable JavaScript to view comments.
</noscript>
<!-- End Disqus -->
</article>

<footer>
<p>&copy; 2010 ~ 2030  Walter Fan <a href="https://beian.miit.gov.cn" target="_blank">皖ICP备20001876号-1</a></p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
</p><!-- StatusCake -->

<!-- End StatusCake --></footer>  </main>

<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Walter Fan's Blog ",
  "url" : ".",
  "image": "./images/walterfan.jpg",
  "description": "an old programmer never die, he just branch to a new address."
}
</script>
</body>
</html>