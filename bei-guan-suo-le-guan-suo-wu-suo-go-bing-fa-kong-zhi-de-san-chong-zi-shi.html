
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="./theme/stylesheet/style.min.css">


    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
          href="./theme/pygments/github.min.css">



  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/solid.css">


  <link rel="shortcut icon" href="./images/favicon.ico" type="image/x-icon">
  <link rel="icon" href="./images/favicon.ico" type="image/x-icon">










 

<meta name="author" content="Walter Fan" />
<meta name="description" content="并发编程最怕什么？数据竞争。解决数据竞争最常见的方法是加锁，但锁也分三六九等。本文用 Go 代码实战，带你理解悲观锁、乐观锁、无锁三种并发控制策略的原理、实现和适用场景。" />
<meta name="keywords" content="golang, concurrency, lock, mutex, atomic, channel, performance">


  <meta property="og:site_name" content="Walter Fan's Blog"/>
  <meta property="og:title" content="悲观锁、乐观锁、无锁：Go 并发控制的三种姿势"/>
  <meta property="og:description" content="并发编程最怕什么？数据竞争。解决数据竞争最常见的方法是加锁，但锁也分三六九等。本文用 Go 代码实战，带你理解悲观锁、乐观锁、无锁三种并发控制策略的原理、实现和适用场景。"/>
  <meta property="og:locale" content="en_US"/>
  <meta property="og:url" content="./bei-guan-suo-le-guan-suo-wu-suo-go-bing-fa-kong-zhi-de-san-chong-zi-shi.html"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="2026-01-28 23:00:00+08:00"/>
  <meta property="article:modified_time" content="2026-01-28 23:00:00+08:00"/>
  <meta property="article:author" content="./author/walter-fan.html">
  <meta property="article:section" content="Tech"/>
  <meta property="article:tag" content="golang"/>
  <meta property="article:tag" content="concurrency"/>
  <meta property="article:tag" content="lock"/>
  <meta property="article:tag" content="mutex"/>
  <meta property="article:tag" content="atomic"/>
  <meta property="article:tag" content="channel"/>
  <meta property="article:tag" content="performance"/>
  <meta property="og:image" content="./images/walterfan.jpg">

  <title>Walter Fan's Blog &ndash; 悲观锁、乐观锁、无锁：Go 并发控制的三种姿势</title>


</head>
<body class="light-theme">

<aside>
  <div>
    <a href="./">
      <img src="./images/walterfan.jpg" alt="Walter Fan" title="Walter Fan">
    </a>

    <h1>
      <a href="./">Walter Fan</a>
    </h1>

    <p>手握灵珠常奋笔, 心开天籁不吹箫</p>


    <nav>
      <ul class="list">



          <li>
            <a target="_blank" href="tao.html" >tao</a>
          </li>
          <li>
            <a target="_blank" href="article.html" >article</a>
          </li>
          <li>
            <a target="_blank" href="interest.html" >interest</a>
          </li>
          <li>
            <a target="_self" href="/wordpress" >notebook</a>
          </li>
          <li>
            <a target="_blank" href="bookmark.html" >bookmark</a>
          </li>
          <li>
            <a target="_blank" href="manual.html" >manual</a>
          </li>
          <li>
            <a target="_self" href="/webrtc/examples/index.html" >webrtc</a>
          </li>
          <li>
            <a target="_blank" href="https://github.com/walterfan" >github</a>
          </li>
      </ul>
    </nav>

    <ul class="social">
      <li>
        <a class="sc-github"
           href="http://github.com/walterfan"
           target="_blank">
          <i class="fa-brands fa-github"></i>
        </a>
      </li>
    </ul>
  </div>

</aside>
  <main>


<article class="single">
  <header>
      
    <h1 id="bei-guan-suo-le-guan-suo-wu-suo-go-bing-fa-kong-zhi-de-san-chong-zi-shi">悲观锁、乐观锁、无锁：Go 并发控制的三种姿势</h1>
    <p>
      Posted on Wed 28 January 2026 in <a href="./category/tech.html">Tech</a>

    </p>
  </header>


  <div>
    <table>
<thead>
<tr>
<th><strong>Abstract</strong></th>
<th>Go 并发控制：悲观锁 vs 乐观锁 vs 无锁</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Authors</strong></td>
<td><a href="https://www.fanyamin.com">Walter Fan</a></td>
</tr>
<tr>
<td><strong>Category</strong></td>
<td>技术笔记</td>
</tr>
<tr>
<td><strong>Status</strong></td>
<td>v1.0</td>
</tr>
<tr>
<td><strong>Updated</strong></td>
<td>2026-01-28</td>
</tr>
<tr>
<td><strong>License</strong></td>
<td><a href="http://creativecommons.org/licenses/by-nc-nd/4.0">CC-BY-NC-ND 4.0</a></td>
</tr>
</tbody>
</table>
<hr>
<h2 id="bug">开篇：一个让你加班到凌晨的 Bug</h2>
<p>周五下午 5 点，你正准备收拾东西下班。</p>
<p>突然，线上告警：<strong>库存超卖了</strong>。</p>
<p>你一看代码，逻辑很简单：</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 扣减库存</span>
<span class="k">if</span><span class="w"> </span><span class="nx">stock</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">stock</span><span class="o">--</span>
<span class="p">}</span>
</code></pre></div>

<p>"这能有什么问题？"</p>
<p>然后你发现——<strong>100 个并发请求同时进来</strong>，每个 goroutine 都读到 <code>stock = 1</code>，然后每个都执行了 <code>stock--</code>。</p>
<p>结果：库存变成了 -99。</p>
<p>老板问你："我们的库存是负数，这是什么黑科技？"</p>
<hr>
<p><strong>这就是经典的数据竞争（Data Race）问题。</strong></p>
<p>解决方案？加锁。</p>
<p>但锁也分好几种"姿势"：</p>
<ul>
<li><strong>悲观锁</strong>：先锁上，再干活（"我不信任你们，一个一个来"）</li>
<li><strong>乐观锁</strong>：先干活，提交时再检查冲突（"我赌你们不会同时改"）</li>
<li><strong>无锁</strong>：压根不用锁，靠设计来避免竞争（"我换个思路"）</li>
</ul>
<p>今天这篇文章，用 <strong>Go 代码实战</strong>，带你理解这三种并发控制策略的原理、实现和适用场景。</p>
<hr>
<h2 id="_1">一、悲观锁：宁可错杀，不可放过</h2>
<h3 id="11">1.1 核心思想</h3>
<p>悲观锁的哲学是：</p>
<blockquote>
<p><strong>"我假设一定会有人跟我抢资源，所以我先把资源锁住，用完再放开。"</strong></p>
</blockquote>
<p>这是一种"防御性编程"的思路——在访问共享资源之前，先获取互斥锁（Mutex），确保同一时刻只有一个 goroutine 能操作。</p>
<h3 id="12-go-syncmutex">1.2 Go 实现：sync.Mutex</h3>
<p>Go 标准库提供了 <code>sync.Mutex</code>，用法非常简单：</p>
<div class="highlight"><pre><span></span><code><span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;fmt&quot;</span>
<span class="w">    </span><span class="s">&quot;sync&quot;</span>
<span class="p">)</span>

<span class="kd">var</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="nx">stock</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">100</span>
<span class="w">    </span><span class="nx">mu</span><span class="w">    </span><span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="p">)</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">deduct</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span><span class="w">         </span><span class="c1">// 加锁</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span><span class="w"> </span><span class="c1">// 确保释放锁</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">stock</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">stock</span><span class="o">--</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">wg</span><span class="w"> </span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">200</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">defer</span><span class="w"> </span><span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
<span class="w">            </span><span class="nx">deduct</span><span class="p">()</span>
<span class="w">        </span><span class="p">}()</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Final stock:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">stock</span><span class="p">)</span><span class="w"> </span><span class="c1">// 输出: Final stock: 0</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>关键点</strong>：</p>
<ul>
<li><code>mu.Lock()</code> 会阻塞，直到获取到锁</li>
<li><code>defer mu.Unlock()</code> 确保即使 panic 也能释放锁</li>
<li>同一时刻只有一个 goroutine 能进入临界区</li>
</ul>
<h3 id="13-syncrwmutex">1.3 读写锁：sync.RWMutex</h3>
<p>如果你的场景是<strong>读多写少</strong>，可以用 <code>sync.RWMutex</code>：</p>
<div class="highlight"><pre><span></span><code><span class="kd">var</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="nx">data</span><span class="w"> </span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>
<span class="w">    </span><span class="nx">rwmu</span><span class="w"> </span><span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
<span class="p">)</span>

<span class="c1">// 读操作：可以多个 goroutine 同时读</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">get</span><span class="p">(</span><span class="nx">key</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">rwmu</span><span class="p">.</span><span class="nx">RLock</span><span class="p">()</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="nx">rwmu</span><span class="p">.</span><span class="nx">RUnlock</span><span class="p">()</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">// 写操作：独占锁</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">rwmu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="nx">rwmu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">value</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>区别</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>RLock()</code></td>
<td>读锁，多个 goroutine 可以同时持有</td>
</tr>
<tr>
<td><code>Lock()</code></td>
<td>写锁，独占，会阻塞所有读和写</td>
</tr>
</tbody>
</table>
<h3 id="14">1.4 优缺点</h3>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>实现简单，逻辑清晰</td>
<td>性能开销大（锁竞争、上下文切换）</td>
</tr>
<tr>
<td>强一致性保证</td>
<td>高并发下容易成为瓶颈</td>
</tr>
<tr>
<td>不会出现 ABA 问题</td>
<td>可能导致死锁（如果锁嵌套使用不当）</td>
</tr>
</tbody>
</table>
<h3 id="15">1.5 适用场景</h3>
<ul>
<li>写操作多，竞争激烈</li>
<li>临界区逻辑复杂（不只是简单的加减）</li>
<li>对数据一致性要求极高</li>
</ul>
<hr>
<h2 id="_2">二、乐观锁：先干活，出问题再说</h2>
<h3 id="21">2.1 核心思想</h3>
<p>乐观锁的哲学是：</p>
<blockquote>
<p><strong>"我赌大部分情况下不会冲突，所以先不加锁，等提交时再检查有没有人改过。"</strong></p>
</blockquote>
<p>如果检查发现被别人改了，就<strong>重试</strong>或<strong>放弃</strong>。</p>
<h3 id="22-go-syncatomic-cas">2.2 Go 实现：sync/atomic + CAS</h3>
<p>Go 的 <code>sync/atomic</code> 包提供了原子操作，其中 <code>CompareAndSwap</code>（CAS）是乐观锁的核心：</p>
<div class="highlight"><pre><span></span><code><span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;fmt&quot;</span>
<span class="w">    </span><span class="s">&quot;sync&quot;</span>
<span class="w">    </span><span class="s">&quot;sync/atomic&quot;</span>
<span class="p">)</span>

<span class="kd">var</span><span class="w"> </span><span class="nx">stock</span><span class="w"> </span><span class="kt">int64</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">100</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">deductCAS</span><span class="p">()</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">old</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">atomic</span><span class="p">.</span><span class="nx">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">stock</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">old</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="c1">// 库存不足</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// CAS：如果 stock 还是 old，就减 1</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">atomic</span><span class="p">.</span><span class="nx">CompareAndSwapInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">stock</span><span class="p">,</span><span class="w"> </span><span class="nx">old</span><span class="p">,</span><span class="w"> </span><span class="nx">old</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="c1">// 扣减成功</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// 如果失败（说明被别人改了），自动重试</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">wg</span><span class="w"> </span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
<span class="w">    </span><span class="nx">successCount</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">200</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">defer</span><span class="w"> </span><span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nx">deductCAS</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="nx">atomic</span><span class="p">.</span><span class="nx">AddInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">successCount</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}()</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Final stock:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">stock</span><span class="p">)</span><span class="w">         </span><span class="c1">// 输出: 0</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Success count:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">successCount</span><span class="p">)</span><span class="w"> </span><span class="c1">// 输出: 100</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>关键点</strong>：</p>
<ul>
<li><code>atomic.LoadInt64()</code> 原子读取当前值</li>
<li><code>CompareAndSwapInt64(addr, old, new)</code> 如果 <code>*addr == old</code>，则设置为 <code>new</code>，返回 <code>true</code>；否则返回 <code>false</code></li>
<li>失败后自旋重试（spin）</li>
</ul>
<h3 id="23">2.3 常用原子操作</h3>
<div class="highlight"><pre><span></span><code><span class="c1">// 原子加减</span>
<span class="nx">atomic</span><span class="p">.</span><span class="nx">AddInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">counter</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">   </span><span class="c1">// counter++</span>
<span class="nx">atomic</span><span class="p">.</span><span class="nx">AddInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">counter</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w">  </span><span class="c1">// counter--</span>

<span class="c1">// 原子读写</span>
<span class="nx">val</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">atomic</span><span class="p">.</span><span class="nx">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">counter</span><span class="p">)</span>
<span class="nx">atomic</span><span class="p">.</span><span class="nx">StoreInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">counter</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span>

<span class="c1">// CAS</span>
<span class="nx">swapped</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">atomic</span><span class="p">.</span><span class="nx">CompareAndSwapInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">counter</span><span class="p">,</span><span class="w"> </span><span class="nx">oldVal</span><span class="p">,</span><span class="w"> </span><span class="nx">newVal</span><span class="p">)</span>
</code></pre></div>

<h3 id="24">2.4 乐观锁的"版本号"变体</h3>
<p>在数据库场景中，乐观锁通常用<strong>版本号</strong>实现：</p>
<div class="highlight"><pre><span></span><code><span class="kd">type</span><span class="w"> </span><span class="nx">Item</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">ID</span><span class="w">      </span><span class="kt">int</span>
<span class="w">    </span><span class="nx">Stock</span><span class="w">   </span><span class="kt">int</span>
<span class="w">    </span><span class="nx">Version</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="c1">// 版本号</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">deductWithVersion</span><span class="p">(</span><span class="nx">item</span><span class="w"> </span><span class="o">*</span><span class="nx">Item</span><span class="p">)</span><span class="w"> </span><span class="kt">error</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 1. 读取当前数据</span>
<span class="w">    </span><span class="nx">oldVersion</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">item</span><span class="p">.</span><span class="nx">Version</span>

<span class="w">    </span><span class="c1">// 2. 业务逻辑</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">item</span><span class="p">.</span><span class="nx">Stock</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;insufficient stock&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">item</span><span class="p">.</span><span class="nx">Stock</span><span class="o">--</span>

<span class="w">    </span><span class="c1">// 3. 带版本号更新（伪代码，实际是 SQL）</span>
<span class="w">    </span><span class="c1">// UPDATE items SET stock = ?, version = version + 1 </span>
<span class="w">    </span><span class="c1">// WHERE id = ? AND version = ?</span>
<span class="w">    </span><span class="nx">affected</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">db</span><span class="p">.</span><span class="nx">Update</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span><span class="w"> </span><span class="nx">oldVersion</span><span class="p">)</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">affected</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;concurrent modification, retry&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="25">2.5 优缺点</h3>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>无锁竞争，高并发性能好</td>
<td>冲突多时，重试开销大</td>
</tr>
<tr>
<td>不会死锁</td>
<td>可能出现 ABA 问题（见下文）</td>
</tr>
<tr>
<td>适合读多写少场景</td>
<td>逻辑复杂时难以使用</td>
</tr>
</tbody>
</table>
<h3 id="26-aba">2.6 ABA 问题</h3>
<p>CAS 的隐患：如果值从 A 变成 B 再变回 A，CAS 会认为"没变过"。</p>
<div class="highlight"><pre><span></span><code>时间线：
goroutine 1: 读到 stock = 100
goroutine 2: stock 100 -&gt; 99 -&gt; 100（被别人扣了又加回来）
goroutine 1: CAS(100, 99) 成功（但其实中间发生过变化）
</code></pre></div>

<p>解决方案：加版本号或时间戳。</p>
<h3 id="27">2.7 适用场景</h3>
<ul>
<li>读多写少，冲突概率低</li>
<li>操作简单（只是加减、替换）</li>
<li>对性能要求高，能接受偶尔重试</li>
</ul>
<hr>
<h2 id="_3">三、无锁：换个思路，绕过竞争</h2>
<h3 id="31">3.1 核心思想</h3>
<p>无锁的哲学是：</p>
<blockquote>
<p><strong>"与其费劲加锁，不如从设计上避免共享状态。"</strong></p>
</blockquote>
<p>这不是说"不用任何同步机制"，而是用其他方式（Channel、不可变数据、分区）来避免数据竞争。</p>
<h3 id="32-go-channelcsp">3.2 Go 实现：Channel（CSP 模型）</h3>
<p>Go 的设计哲学是：</p>
<blockquote>
<p><strong>"Don't communicate by sharing memory; share memory by communicating."</strong>
（不要通过共享内存来通信，而要通过通信来共享内存。）</p>
</blockquote>
<p>用 Channel 重写库存扣减：</p>
<div class="highlight"><pre><span></span><code><span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;fmt&quot;</span>
<span class="p">)</span>

<span class="c1">// 库存管理器（单一 goroutine 持有状态）</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">stockManager</span><span class="p">(</span><span class="nx">stock</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="nx">requests</span><span class="w"> </span><span class="o">&lt;-</span><span class="kd">chan</span><span class="w"> </span><span class="kd">chan</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">req</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">requests</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">stock</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">stock</span><span class="o">--</span>
<span class="w">            </span><span class="nx">req</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="kc">true</span><span class="w">  </span><span class="c1">// 扣减成功</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">req</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="c1">// 库存不足</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">requests</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kd">chan</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span>

<span class="w">    </span><span class="c1">// 启动库存管理器</span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="nx">stockManager</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="nx">requests</span><span class="p">)</span>

<span class="w">    </span><span class="c1">// 模拟 200 个并发请求</span>
<span class="w">    </span><span class="nx">done</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="mi">200</span><span class="p">)</span>
<span class="w">    </span><span class="nx">successCount</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">200</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">reply</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span>
<span class="w">            </span><span class="nx">requests</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">reply</span><span class="w">   </span><span class="c1">// 发送请求</span>
<span class="w">            </span><span class="nx">success</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">reply</span><span class="w">  </span><span class="c1">// 等待响应</span>
<span class="w">            </span><span class="nx">done</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">success</span>
<span class="w">        </span><span class="p">}()</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 统计结果</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">200</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">done</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">successCount</span><span class="o">++</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Success count:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">successCount</span><span class="p">)</span><span class="w"> </span><span class="c1">// 输出: 100</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>关键点</strong>：</p>
<ul>
<li>状态（stock）只被一个 goroutine 持有</li>
<li>其他 goroutine 通过 Channel 发送"请求"</li>
<li>没有共享内存，所以不需要锁</li>
</ul>
<h3 id="33-immutable-data">3.3 不可变数据（Immutable Data）</h3>
<p>另一种无锁思路：<strong>永远不修改数据，只创建新版本</strong>。</p>
<div class="highlight"><pre><span></span><code><span class="kd">type</span><span class="w"> </span><span class="nx">Config</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">DBHost</span><span class="w">   </span><span class="kt">string</span>
<span class="w">    </span><span class="nx">DBPort</span><span class="w">   </span><span class="kt">int</span>
<span class="w">    </span><span class="nx">LogLevel</span><span class="w"> </span><span class="kt">string</span>
<span class="p">}</span>

<span class="kd">var</span><span class="w"> </span><span class="nx">currentConfig</span><span class="w"> </span><span class="nx">atomic</span><span class="p">.</span><span class="nx">Value</span><span class="w"> </span><span class="c1">// 存储 *Config</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">init</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">currentConfig</span><span class="p">.</span><span class="nx">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Config</span><span class="p">{</span>
<span class="w">        </span><span class="nx">DBHost</span><span class="p">:</span><span class="w">   </span><span class="s">&quot;localhost&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="nx">DBPort</span><span class="p">:</span><span class="w">   </span><span class="mi">5432</span><span class="p">,</span>
<span class="w">        </span><span class="nx">LogLevel</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;info&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">})</span>
<span class="p">}</span>

<span class="c1">// 读取配置（无锁）</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">GetConfig</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="nx">Config</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">currentConfig</span><span class="p">.</span><span class="nx">Load</span><span class="p">().(</span><span class="o">*</span><span class="nx">Config</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 更新配置（创建新对象，原子替换）</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">UpdateConfig</span><span class="p">(</span><span class="nx">newHost</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">old</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">GetConfig</span><span class="p">()</span>
<span class="w">    </span><span class="nx">newConfig</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">Config</span><span class="p">{</span>
<span class="w">        </span><span class="nx">DBHost</span><span class="p">:</span><span class="w">   </span><span class="nx">newHost</span><span class="p">,</span>
<span class="w">        </span><span class="nx">DBPort</span><span class="p">:</span><span class="w">   </span><span class="nx">old</span><span class="p">.</span><span class="nx">DBPort</span><span class="p">,</span>
<span class="w">        </span><span class="nx">LogLevel</span><span class="p">:</span><span class="w"> </span><span class="nx">old</span><span class="p">.</span><span class="nx">LogLevel</span><span class="p">,</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">currentConfig</span><span class="p">.</span><span class="nx">Store</span><span class="p">(</span><span class="nx">newConfig</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>关键点</strong>：</p>
<ul>
<li>读操作完全无锁</li>
<li>写操作创建新对象，用 <code>atomic.Value</code> 原子替换</li>
<li>适合配置、元数据等读多写少场景</li>
</ul>
<h3 id="34-sharding">3.4 分区（Sharding）</h3>
<p>如果必须有共享状态，可以把状态拆分成多个分区，减少竞争：</p>
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">shardCount</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">16</span>

<span class="kd">type</span><span class="w"> </span><span class="nx">ShardedCounter</span><span class="w"> </span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">shards</span><span class="w"> </span><span class="p">[</span><span class="nx">shardCount</span><span class="p">]</span><span class="kd">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="w">        </span><span class="nx">count</span><span class="w"> </span><span class="kt">int64</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="o">*</span><span class="nx">ShardedCounter</span><span class="p">)</span><span class="w"> </span><span class="nx">Inc</span><span class="p">(</span><span class="nx">key</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 根据 key 哈希到某个分区</span>
<span class="w">    </span><span class="nx">shard</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">shards</span><span class="p">[</span><span class="nx">hash</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span><span class="o">%</span><span class="nx">shardCount</span><span class="p">]</span>
<span class="w">    </span><span class="nx">shard</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
<span class="w">    </span><span class="nx">shard</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span>
<span class="w">    </span><span class="nx">shard</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="o">*</span><span class="nx">ShardedCounter</span><span class="p">)</span><span class="w"> </span><span class="nx">Total</span><span class="p">()</span><span class="w"> </span><span class="kt">int64</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">total</span><span class="w"> </span><span class="kt">int64</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">c</span><span class="p">.</span><span class="nx">shards</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">c</span><span class="p">.</span><span class="nx">shards</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Lock</span><span class="p">()</span>
<span class="w">        </span><span class="nx">total</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">c</span><span class="p">.</span><span class="nx">shards</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">count</span>
<span class="w">        </span><span class="nx">c</span><span class="p">.</span><span class="nx">shards</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Unlock</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">total</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>关键点</strong>：</p>
<ul>
<li>锁竞争从 1 个锁变成 16 个锁</li>
<li>不同 key 大概率打到不同分区，互不干扰</li>
</ul>
<h3 id="35">3.5 优缺点</h3>
<table>
<thead>
<tr>
<th>方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>Channel</td>
<td>Go 原生支持，代码清晰</td>
<td>有 Channel 开销，不适合极高性能场景</td>
</tr>
<tr>
<td>不可变数据</td>
<td>读完全无锁，线程安全</td>
<td>写操作需要复制，内存开销大</td>
</tr>
<tr>
<td>分区</td>
<td>减少锁竞争，可扩展</td>
<td>聚合操作需要遍历所有分区</td>
</tr>
</tbody>
</table>
<h3 id="36">3.6 适用场景</h3>
<ul>
<li><strong>Channel</strong>：任务分发、消息传递、Pipeline</li>
<li><strong>不可变数据</strong>：配置管理、缓存、读多写少</li>
<li><strong>分区</strong>：高并发计数器、分布式锁</li>
</ul>
<hr>
<h2 id="_4">四、三种方式对比总结</h2>
<table>
<thead>
<tr>
<th>维度</th>
<th>悲观锁</th>
<th>乐观锁</th>
<th>无锁</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>假设</strong></td>
<td>一定会冲突</td>
<td>大概率不冲突</td>
<td>避免共享状态</td>
</tr>
<tr>
<td><strong>实现</strong></td>
<td>Mutex / RWMutex</td>
<td>CAS / 版本号</td>
<td>Channel / 不可变</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>竞争多时差</td>
<td>竞争少时好</td>
<td>取决于设计</td>
</tr>
<tr>
<td><strong>复杂度</strong></td>
<td>简单</td>
<td>中等</td>
<td>需要设计思维</td>
</tr>
<tr>
<td><strong>死锁风险</strong></td>
<td>有</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td><strong>ABA 问题</strong></td>
<td>无</td>
<td>有</td>
<td>无</td>
</tr>
</tbody>
</table>
<h3 id="_5">选择建议</h3>
<div class="highlight"><pre><span></span><code>问自己一个问题：写操作多还是少？

        写操作多？
          / \
         /   \
        是    否
       /        \
   悲观锁      冲突概率高？
               /  \
              /    \
             是    否
            /        \
       悲观锁      乐观锁/无锁
</code></pre></div>

<p>更具体的场景推荐：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐方案</th>
</tr>
</thead>
<tbody>
<tr>
<td>库存扣减（高并发）</td>
<td>悲观锁 + 数据库行锁</td>
</tr>
<tr>
<td>计数器（精确）</td>
<td>atomic</td>
</tr>
<tr>
<td>配置热更新</td>
<td>atomic.Value + 不可变数据</td>
</tr>
<tr>
<td>任务分发</td>
<td>Channel</td>
</tr>
<tr>
<td>缓存（读多写少）</td>
<td>sync.RWMutex 或 不可变数据</td>
</tr>
<tr>
<td>高并发计数（允许近似）</td>
<td>分区计数器</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="benchmark">五、实战：用 Benchmark 验证性能差异</h2>
<p>Talk is cheap，跑个 benchmark：</p>
<div class="highlight"><pre><span></span><code><span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;sync&quot;</span>
<span class="w">    </span><span class="s">&quot;sync/atomic&quot;</span>
<span class="w">    </span><span class="s">&quot;testing&quot;</span>
<span class="p">)</span>

<span class="kd">var</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="nx">counterMutex</span><span class="w"> </span><span class="kt">int64</span>
<span class="w">    </span><span class="nx">mu</span><span class="w">           </span><span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="w">    </span><span class="nx">counterAtomic</span><span class="w"> </span><span class="kt">int64</span>
<span class="p">)</span>

<span class="c1">// 悲观锁</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">BenchmarkMutex</span><span class="p">(</span><span class="nx">b</span><span class="w"> </span><span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">b</span><span class="p">.</span><span class="nx">RunParallel</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">pb</span><span class="w"> </span><span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">PB</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="nx">pb</span><span class="p">.</span><span class="nx">Next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
<span class="w">            </span><span class="nx">counterMutex</span><span class="o">++</span>
<span class="w">            </span><span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">})</span>
<span class="p">}</span>

<span class="c1">// 乐观锁（atomic）</span>
<span class="kd">func</span><span class="w"> </span><span class="nx">BenchmarkAtomic</span><span class="p">(</span><span class="nx">b</span><span class="w"> </span><span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">b</span><span class="p">.</span><span class="nx">RunParallel</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">pb</span><span class="w"> </span><span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">PB</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="nx">pb</span><span class="p">.</span><span class="nx">Next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">atomic</span><span class="p">.</span><span class="nx">AddInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">counterAtomic</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">})</span>
<span class="p">}</span>
</code></pre></div>

<p>运行：</p>
<div class="highlight"><pre><span></span><code>go<span class="w"> </span><span class="nb">test</span><span class="w"> </span>-bench<span class="o">=</span>.<span class="w"> </span>-benchmem<span class="w"> </span>-cpu<span class="o">=</span><span class="m">1</span>,4,8
</code></pre></div>

<p>典型结果（仅供参考，实际取决于 CPU）：</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>1 CPU</th>
<th>4 CPU</th>
<th>8 CPU</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mutex</td>
<td>50 ns/op</td>
<td>200 ns/op</td>
<td>400 ns/op</td>
</tr>
<tr>
<td>Atomic</td>
<td>10 ns/op</td>
<td>15 ns/op</td>
<td>20 ns/op</td>
</tr>
</tbody>
</table>
<p><strong>结论</strong>：</p>
<ul>
<li>单核差距不大</li>
<li>多核下 Mutex 性能急剧下降（锁竞争）</li>
<li>Atomic 扩展性更好</li>
</ul>
<hr>
<h2 id="_6">总结</h2>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>一句话</th>
<th>Go 实现</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>悲观锁</strong></td>
<td>先锁后干活</td>
<td><code>sync.Mutex</code> / <code>sync.RWMutex</code></td>
</tr>
<tr>
<td><strong>乐观锁</strong></td>
<td>先干活后检查</td>
<td><code>atomic.CompareAndSwap</code> / 版本号</td>
</tr>
<tr>
<td><strong>无锁</strong></td>
<td>换个思路避免竞争</td>
<td>Channel / 不可变数据 / 分区</td>
</tr>
</tbody>
</table>
<p><strong>记忆口诀</strong>：</p>
<blockquote>
<p>写多用悲观，读多用乐观，能不共享就不共享。</p>
</blockquote>
<hr>
<h2 id="checklistgo">Checklist：Go 并发控制</h2>
<ul>
<li>[ ] 确认是否真的需要共享状态（能不能用 Channel 替代？）</li>
<li>[ ] 确认读写比例（读多 → RWMutex / atomic；写多 → Mutex）</li>
<li>[ ] 锁的粒度是否合理（锁太大影响并发，锁太小容易出错）</li>
<li>[ ] 是否有死锁风险（检查锁的获取顺序）</li>
<li>[ ] 用 <code>go run -race</code> 检测数据竞争</li>
<li>[ ] 高并发场景跑 benchmark 验证</li>
</ul>
<hr>
<h2 id="_7">扩展阅读</h2>
<ul>
<li><a href="https://pkg.go.dev/sync">Go sync 包官方文档</a></li>
<li><a href="https://pkg.go.dev/sync/atomic">Go atomic 包官方文档</a></li>
<li><a href="https://go.dev/ref/mem">The Go Memory Model</a></li>
<li><a href="https://go.dev/blog/pipelines">Go Concurrency Patterns</a></li>
</ul>
<hr>
<h2 id="_8">写在最后</h2>
<p>回到开头那个库存超卖的 bug——</p>
<p>如果你用了悲观锁，它不会发生。
如果你用了乐观锁，它会被检测到并重试。
如果你用了 Channel，它压根就不可能发生。</p>
<p><strong>并发问题的本质，是"多个人同时改一个东西"。</strong></p>
<p>解决方案无非三种：
1. 排队一个个来（悲观锁）
2. 改完检查有没有冲突（乐观锁）
3. 让每个人改自己的东西（无锁）</p>
<p>选哪个？看场景。</p>
<p>下次写并发代码时，先问自己：</p>
<blockquote>
<p>「这个共享状态，真的非共享不可吗？」</p>
</blockquote>
<p>很多时候，最好的锁是——不加锁。</p>
<hr>
<div class="highlight"><pre><span></span><code>@startmindmap
* 并发控制三种姿势
** 悲观锁
*** 先锁后干活
*** sync.Mutex
*** sync.RWMutex
*** 写多竞争激烈
** 乐观锁
*** 先干活后检查
*** CAS 实现
*** 版本号变体
*** ABA 问题
*** 读多写少
** 无锁
*** 避免共享状态
*** Channel CSP
*** 不可变数据
*** 分区 Sharding
** 选择建议
*** 写多用悲观锁
*** 读多用乐观/无锁
*** Benchmark 验证
@endmindmap
</code></pre></div>

<p><img alt="并发控制思维导图" src="../images/journal_20260128_lock_types_mindmap.png"></p>
<hr/>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="./tag/golang.html">golang</a>
      <a href="./tag/concurrency.html">concurrency</a>
      <a href="./tag/lock.html">lock</a>
      <a href="./tag/mutex.html">mutex</a>
      <a href="./tag/atomic.html">atomic</a>
      <a href="./tag/channel.html">channel</a>
      <a href="./tag/performance.html">performance</a>
    </p>
  </div>


  <div class="neighbors">
    <a class="btn float-left" href="./ai-sen-hao-wei-er-ju-zhen-wei-shi-yao-ni-mei-tian-mang-dao-fei-qi-nian-di-que-mei-shi-yao-ke-xie-de.html" title="艾森豪威尔矩阵：为什么你每天忙到飞起，年底却没什么可写的">
      <i class="fa fa-angle-left"></i> Previous Post
    </a>
    <a class="btn float-right" href="./zhi-chang-gong-ju-xiang-zhi-pdcagao-shou-zuo-shi-du-you-yi-ge-bi-huan.html" title="职场工具箱之 PDCA：高手做事，都有一个"闭环"">
      Next Post <i class="fa fa-angle-right"></i>
    </a>
  </div>

  <div class="related-posts">
    <h4>You might enjoy</h4>
    <ul class="related-posts">
      <li><a href="./jing-ti-ni-de-go-cheng-xu-zheng-zai-tou-tou-xie-lou-xiang-jie-goroutine-leak.html">警惕！你的 Go 程序正在偷偷"泄漏" —— 详解 Goroutine Leak</a></li>
      <li><a href="./go-cheng-xu-beng-kui-fen-xi-shi-zhan-cong-coredump-dao-gen-yin-ding-wei.html">Go 程序崩溃分析实战：从 Coredump 到根因定位</a></li>
      <li><a href="./yong-eino-gou-jian-ai-agentgo-kai-fa-zhe-de-langchain-zhong-yu-lai-liao.html">用 Eino 构建 AI Agent：Go 开发者的 LangChain 终于来了</a></li>
    </ul>
  </div>



<!-- Disqus -->
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'wfblog';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>
    Please enable JavaScript to view comments.
</noscript>
<!-- End Disqus -->
</article>

<footer>
<p>&copy; 2010 ~ 2030  Walter Fan <a href="https://beian.miit.gov.cn" target="_blank">皖ICP备20001876号-1</a></p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
</p><!-- StatusCake -->

<!-- End StatusCake --></footer>  </main>

<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Walter Fan's Blog ",
  "url" : ".",
  "image": "./images/walterfan.jpg",
  "description": "an old programmer never die, he just branch to a new address."
}
</script>
</body>
</html>