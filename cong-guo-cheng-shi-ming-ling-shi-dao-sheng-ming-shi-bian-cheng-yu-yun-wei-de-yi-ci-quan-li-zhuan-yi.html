
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="./theme/stylesheet/style.min.css">


    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
          href="./theme/pygments/github.min.css">



  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/solid.css">


  <link rel="shortcut icon" href="./images/favicon.ico" type="image/x-icon">
  <link rel="icon" href="./images/favicon.ico" type="image/x-icon">










 

<meta name="author" content="Walter Fan" />
<meta name="description" content="过程式是“我来一步步做”，命令式是“你按我说的做”，声明式是“我只说我想要什么，怎么做到你自己想办法”。这背后不是语法之争，而是复杂系统时代的协作方式升级。" />
<meta name="keywords" content="Programming, DevOps, Declarative, Kubernetes, Terraform, GitOps, Infrastructure as Code">


  <meta property="og:site_name" content="Walter Fan's Blog"/>
  <meta property="og:title" content="从过程式、命令式到声明式：编程与运维的一次“权力转移”"/>
  <meta property="og:description" content="过程式是“我来一步步做”，命令式是“你按我说的做”，声明式是“我只说我想要什么，怎么做到你自己想办法”。这背后不是语法之争，而是复杂系统时代的协作方式升级。"/>
  <meta property="og:locale" content="en_US"/>
  <meta property="og:url" content="./cong-guo-cheng-shi-ming-ling-shi-dao-sheng-ming-shi-bian-cheng-yu-yun-wei-de-yi-ci-quan-li-zhuan-yi.html"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="2026-01-27 20:30:00+08:00"/>
  <meta property="article:modified_time" content="2026-01-27 20:30:00+08:00"/>
  <meta property="article:author" content="./author/walter-fan.html">
  <meta property="article:section" content="Method"/>
  <meta property="article:tag" content="Programming"/>
  <meta property="article:tag" content="DevOps"/>
  <meta property="article:tag" content="Declarative"/>
  <meta property="article:tag" content="Kubernetes"/>
  <meta property="article:tag" content="Terraform"/>
  <meta property="article:tag" content="GitOps"/>
  <meta property="article:tag" content="Infrastructure as Code"/>
  <meta property="og:image" content="./images/walterfan.jpg">

  <title>Walter Fan's Blog &ndash; 从过程式、命令式到声明式：编程与运维的一次“权力转移”</title>


</head>
<body class="light-theme">

<aside>
  <div>
    <a href="./">
      <img src="./images/walterfan.jpg" alt="Walter Fan" title="Walter Fan">
    </a>

    <h1>
      <a href="./">Walter Fan</a>
    </h1>

    <p>手握灵珠常奋笔, 心开天籁不吹箫</p>


    <nav>
      <ul class="list">



          <li>
            <a target="_blank" href="tao.html" >tao</a>
          </li>
          <li>
            <a target="_blank" href="article.html" >article</a>
          </li>
          <li>
            <a target="_blank" href="interest.html" >interest</a>
          </li>
          <li>
            <a target="_self" href="/wordpress" >notebook</a>
          </li>
          <li>
            <a target="_blank" href="bookmark.html" >bookmark</a>
          </li>
          <li>
            <a target="_blank" href="manual.html" >manual</a>
          </li>
          <li>
            <a target="_self" href="/webrtc/examples/index.html" >webrtc</a>
          </li>
          <li>
            <a target="_blank" href="https://github.com/walterfan" >github</a>
          </li>
      </ul>
    </nav>

    <ul class="social">
      <li>
        <a class="sc-github"
           href="http://github.com/walterfan"
           target="_blank">
          <i class="fa-brands fa-github"></i>
        </a>
      </li>
    </ul>
  </div>

</aside>
  <main>


<article class="single">
  <header>
      
    <h1 id="cong-guo-cheng-shi-ming-ling-shi-dao-sheng-ming-shi-bian-cheng-yu-yun-wei-de-yi-ci-quan-li-zhuan-yi">从过程式、命令式到声明式：编程与运维的一次“权力转移”</h1>
    <p>
      Posted on Tue 27 January 2026 in <a href="./category/method.html">Method</a>

    </p>
  </header>


  <div>
    <table>
<thead>
<tr>
<th><strong>Abstract</strong></th>
<th>从过程式、命令式到声明式编程和运维的转变</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Authors</strong></td>
<td><a href="https://www.fanyamin.com">Walter Fan</a></td>
</tr>
<tr>
<td><strong>Category</strong></td>
<td>方法论 / 工程实践</td>
</tr>
<tr>
<td><strong>Status</strong></td>
<td>v1.0</td>
</tr>
<tr>
<td><strong>Updated</strong></td>
<td>2026-01-27</td>
</tr>
<tr>
<td><strong>License</strong></td>
<td><a href="http://creativecommons.org/licenses/by-nc-nd/4.0">CC-BY-NC-ND 4.0</a></td>
</tr>
</tbody>
</table>
<h2 id="_1">开篇：你以为你在“部署”，其实你在“追自己留下的脚印”</h2>
<p>我见过最经典的一类线上事故，不是代码写错了，也不是机器挂了，而是四个字：<strong>“跟上次不一样”</strong>。</p>
<p>你上周用一串命令把服务推到线上：</p>
<div class="highlight"><pre><span></span><code>kubectl<span class="w"> </span><span class="nb">set</span><span class="w"> </span>image<span class="w"> </span>deploy/api<span class="w"> </span><span class="nv">api</span><span class="o">=</span>...:v12
kubectl<span class="w"> </span>scale<span class="w"> </span>deploy/api<span class="w"> </span>--replicas<span class="o">=</span><span class="m">6</span>
kubectl<span class="w"> </span>patch<span class="w"> </span>deploy/api<span class="w"> </span>-p<span class="w"> </span><span class="s1">&#39;...&#39;</span>
</code></pre></div>

<p>这周你想复现“上周那个稳定状态”，但你突然发现：</p>
<ul>
<li>你记不清当时到底 patch 了哪些字段</li>
<li>同事在你不知情的情况下又改了几处（还挺合理）</li>
<li>线上对象已经长得跟你的记忆完全不一样</li>
</ul>
<p>于是你开始在群里问：“谁动了我的 deployment？”<br>
然后大家开始一起演一出“没有监控也能复盘”的职场魔幻剧。</p>
<p>这就是为什么我说：<strong>从过程式/命令式到声明式的转变，本质是一次“权力转移”</strong>——把“怎么做”的权力从人手里交给系统，让人只对“想要什么”负责。</p>
<hr>
<h2 id="_2">一、三种范式，三种对“控制”的态度</h2>
<p>先把概念说清楚，别上来就被术语劝退。</p>
<h3 id="1-procedural">1) 过程式（Procedural）：我亲自下场，一步一步来</h3>
<p>过程式最像“写菜谱”：先切葱再下锅，火候几分钟，步骤是核心。</p>
<ul>
<li>你关心的是 <strong>How</strong>：每一步怎么执行</li>
<li>你写的是流程：<code>if/for/while</code>、函数调用顺序、状态如何变化</li>
</ul>
<p>优点：清晰、可控、性能调优空间大<br>
缺点：当系统变复杂、并发变多，“步骤”容易变成灾难现场</p>
<h3 id="2-imperative">2) 命令式（Imperative）：你照我说的做</h3>
<p>命令式不一定写在代码里，也可能写在命令行、脚本、控制台里。</p>
<ul>
<li>你关心的是 <strong>做什么动作</strong>：create / update / delete / scale</li>
<li>你通常在操作“现在的对象”（live state）</li>
</ul>
<p>它的最大问题不是“不好用”，而是<strong>不可回放</strong>：</p>
<ul>
<li>同样一串命令在不同初始状态下，结果可能不一样</li>
<li>命令执行的副作用（顺序、失败重试、部分成功）很难完全复盘</li>
</ul>
<h3 id="3-declarative">3) 声明式（Declarative）：我只说我想要什么</h3>
<p>声明式最像“点外卖”：你说要一份麻辣香锅，不必告诉商家先洗菜还是先开火。</p>
<ul>
<li>你表达的是 <strong>What</strong>：目标状态/约束条件/不变量</li>
<li>系统负责 <strong>How</strong>：规划、调度、重试、收敛（reconcile）</li>
</ul>
<p>这里有个关键提醒：</p>
<blockquote>
<p><strong>声明式不是“没有过程”，而是“过程不由你显式写出来”。</strong></p>
</blockquote>
<p>过程仍然存在，只是被下沉到框架/控制器/引擎里了。</p>
<hr>
<h2 id="_3">二、为什么声明式越来越火：因为我们在管理“复杂系统”，不是单机程序</h2>
<p>声明式流行，不是因为它更“高级”，而是因为它更适合几个现实约束。</p>
<h3 id="1-200">1) 规模化：人类不擅长记住 200 个细节</h3>
<p>当资源少、环境简单时，命令式挺爽：改一行、重启一下就好了。</p>
<p>但当你要管的是：</p>
<ul>
<li>多集群、多环境（dev/staging/prod）</li>
<li>多租户、多团队协作</li>
<li>还要合规、要审计、要可追溯</li>
</ul>
<p>命令式就会把人逼成“记忆型动物”：靠脑子记、靠聊天记录找。</p>
<h3 id="2">2) 幂等与可重复：声明式天然更接近“可重放”</h3>
<p>声明式通常要求你描述一个<strong>收敛目标</strong>，系统可以反复执行直到达成。</p>
<p>这带来两件工程上的好处：</p>
<ul>
<li><strong>幂等</strong>：同一个声明反复 apply，结果应该一致</li>
<li><strong>可复制</strong>：你可以把目标状态放进版本库，让环境可重建</li>
</ul>
<h3 id="3-git">3) 协作与审计：Git 比微信群靠谱</h3>
<p>现实里最可靠的“变更记录”，不是谁在群里说了一句“我改了下”，而是：</p>
<ul>
<li>有 diff</li>
<li>有 commit message</li>
<li>有 reviewer</li>
<li>有回滚点</li>
</ul>
<p>声明式天然适合和 Git 绑定，这也是 GitOps 能跑起来的原因。</p>
<hr>
<h2 id="_4">三、运维世界的转变：从“我手动敲命令”到“系统帮我收敛”</h2>
<p>运维的演进其实很像软件工程的演进：从“个人英雄主义”走向“系统化协作”。</p>
<h3 id="1">1) 命令式运维：手工命令 + 脚本（最常见，也最容易背锅）</h3>
<p>早期的典型画面：</p>
<ul>
<li>SSH 上去改配置、重启服务</li>
<li>写个脚本跑一遍，希望别炸</li>
<li>炸了就再 SSH 上去修</li>
</ul>
<p>这套方式的问题在于：<strong>操作和结果绑定得太紧</strong>，而环境差异、顺序差异会把你拖进泥潭。</p>
<h3 id="2-iac">2) IaC（基础设施即代码）：把“基础设施”变成可版本化的声明</h3>
<p>Terraform 是一个典型代表：你写配置描述目标基础设施，工具负责 plan/apply，并通过状态（state）管理“现实长什么样”。官方文档里对 Terraform 的定位就是“infrastructure as code”。<br>
你把它看成一句话就行：</p>
<blockquote>
<p><strong>把基础设施从“手工操作对象”，升级成“可版本化的目标状态”。</strong></p>
</blockquote>
<p>Terraform 文档入口（可扩展阅读）：<code>https://developer.hashicorp.com/terraform/docs</code></p>
<h3 id="3-gitops">3) GitOps：把“部署动作”变成“状态同步”</h3>
<p>当你把目标状态放在 Git 里时，“部署”就不再是 CI 里跑一堆命令，而更像：</p>
<ul>
<li>Git 是事实来源（source of truth）</li>
<li>集群里有个控制器持续对比：<strong>现实 vs 目标</strong></li>
<li>不一致就收敛（同步），一致就躺平（保持）</li>
</ul>
<p>Argo CD 的官方文档里就明确把它定义为“declarative, GitOps continuous delivery”。<br>
文档入口：<code>https://argo-cd.readthedocs.io/en/stable/</code></p>
<p>这类系统最关键的变化是：<strong>你不再“推送”变更到集群，而是让集群“拉取并对齐”到 Git 的目标状态。</strong></p>
<hr>
<h2 id="kubernetes">四、Kubernetes 是声明式运维的“教科书”</h2>
<p>K8s 的核心设计就是“声明式 + 控制器收敛”。你写一个 Deployment，真正有用的不是 YAML 的格式，而是这句话：</p>
<blockquote>
<p><strong>你告诉它你想要的副本数、镜像版本、策略；它负责把系统状态收敛到你想要的样子。</strong></p>
</blockquote>
<p>Kubernetes 官方文档把对象管理分成三类：命令式、命令式配置、声明式配置，其中声明式推荐用 <code>kubectl apply</code> 管理目录级配置。<br>
参考：<code>https://kubernetes.io/docs/tasks/manage-kubernetes-objects/declarative-config/</code></p>
<h3 id="server-side-applyssa">声明式的“进阶版”：Server-Side Apply（SSA）</h3>
<p>当多个系统/人都在“声明式地”改一个对象时，就会出现一个现实问题：<strong>谁说了算？</strong></p>
<p>SSA 的思路是：让 apiserver 记录“字段归属”（谁管理哪个 field），冲突就显式报出来，而不是默默互相覆盖。<br>
参考：<code>https://kubernetes.io/docs/reference/using-api/server-side-apply/</code></p>
<p>这背后其实是在解决一个更大的问题：<strong>声明式协作的边界</strong>。</p>
<hr>
<h2 id="_5">五、从编程视角看：声明式不是“新语言”，而是一种抽象层级</h2>
<p>声明式并不只存在于运维。</p>
<h3 id="1-sql">1) SQL：你说“要什么数据”，优化器决定“怎么查”</h3>
<p>SQL 经常被拿来当声明式的例子：你写 <code>SELECT ... WHERE ...</code>，并不指定索引怎么用、join 顺序怎么排。<br>
PostgreSQL 文档入口：<code>https://www.postgresql.org/docs/15/sql.html</code></p>
<h3 id="2-ui">2) UI 世界：你描述“界面应该长什么样”，框架负责更新</h3>
<p>React 这类框架的心智模型也是声明式：你描述 UI = f(state)。<br>
你不需要手动做 DOM diff（那是框架的事），你只负责“目标长相”。</p>
<h3 id="3">3) 但别神化：声明式的代价是真实存在的</h3>
<p>声明式把“怎么做”下沉给系统，代价就是：</p>
<ul>
<li>你要理解系统的收敛机制（reconcile loop）</li>
<li>你要接受一定的“黑盒感”</li>
<li>排错时得学会观察“目标/现实/差异”三件套</li>
</ul>
<hr>
<h2 id="yaml">六、怎么落地：把声明式用成“省心”，而不是用成“更大的 YAML 地狱”</h2>
<p>我自己总结的落地顺序是：先定边界，再定事实来源，再定收敛方式。</p>
<h3 id="1_1">1) 先问一句：哪些东西适合声明式？</h3>
<p>适合声明式的通常是：</p>
<ul>
<li><strong>资源类</strong>：机器、网络、权限、部署对象（可描述的目标状态）</li>
<li><strong>可收敛</strong>：系统能通过重试/调度把它对齐</li>
</ul>
<p>不太适合直接声明式化的通常是：</p>
<ul>
<li>需要复杂流程编排且强顺序依赖的（当然也能做，但成本更高）</li>
<li>本质是一次性动作/事务的（比如“把这批数据迁移完”）</li>
</ul>
<h3 id="2-git-slack">2) 让 Git 成为“事实来源”，别让 Slack/微信群当数据库</h3>
<ul>
<li>目标状态进 Git</li>
<li>变更走 PR</li>
<li>重要环境的 apply/sync 尽量自动化</li>
</ul>
<h3 id="3_1">3) 给“收敛”留出口：观察、回滚、保护阈值</h3>
<p>声明式系统最怕两件事：</p>
<ul>
<li><strong>漂移（drift）</strong>：现实被手工改了，目标没更新</li>
<li><strong>自动收敛误伤</strong>：目标写错了，系统很勤奋地把你拉进坑里</li>
</ul>
<p>所以你需要配套：</p>
<ul>
<li>diff（变更预览）</li>
<li>rollback（回滚路径）</li>
<li>guardrail（例如审批、保护分支、变更窗口、限速）</li>
</ul>
<hr>
<h2 id="_6">七、常见坑：声明式不是银弹，它只会把坑换个形状</h2>
<ul>
<li><strong>把命令式当声明式</strong>：明明每次都 <code>kubectl patch</code>，还以为自己在 GitOps</li>
<li><strong>一半声明式一半手工改</strong>：最后一定会遇到“到底谁是事实来源”的战争</li>
<li><strong>状态文件/字段归属没管好</strong>：Terraform state、K8s managedFields 这类东西，都是“系统记忆”，丢了就会失忆</li>
<li><strong>把一切都 YAML 化</strong>：复杂逻辑硬塞 YAML，往往是“用错抽象层级”</li>
</ul>
<hr>
<h2 id="tldr">TL;DR（给只想快速抓重点的人）</h2>
<ul>
<li><strong>过程式</strong>：我写步骤（How）</li>
<li><strong>命令式</strong>：我发命令（Do）</li>
<li><strong>声明式</strong>：我描述目标（What），系统负责收敛（Reconcile）</li>
<li>声明式流行不是审美，而是复杂系统时代对 <strong>幂等、协作、审计、可重复</strong> 的刚需</li>
</ul>
<hr>
<h2 id="checklist">可执行清单（Checklist）</h2>
<ul>
<li>[ ] 先划清边界：哪些资源/配置要声明式管理，哪些保留流程化</li>
<li>[ ] 选定事实来源：Git 是唯一目标状态（至少对 prod 如此）</li>
<li>[ ] 设计收敛机制：谁负责对齐（人、CI、控制器、GitOps 工具）</li>
<li>[ ] 给变更加护栏：diff、审批、回滚、限速</li>
<li>[ ] 规定“禁止手工改”的范围（或明确“手工改必回填”）</li>
<li>[ ] 监控漂移：现实与目标不一致要能被发现、被告警</li>
</ul>
<hr>
<h2 id="_7">互动提问</h2>
<p>你现在团队里最“命令式”的一块运维工作是什么？是 Kubernetes 的 <code>kubectl patch</code>/<code>scale</code>，还是云资源的控制台点点点？我可以基于你的场景，给一条更具体的迁移路线（先收敛哪几类资源最划算、怎么避免一上来就掉进 YAML 地狱）。</p>
<hr>
<h2 id="reference">Reference</h2>
<ul>
<li>Kubernetes: Declarative object configuration: <code>https://kubernetes.io/docs/tasks/manage-kubernetes-objects/declarative-config/</code></li>
<li>Kubernetes: Server-Side Apply: <code>https://kubernetes.io/docs/reference/using-api/server-side-apply/</code></li>
<li>Terraform docs: <code>https://developer.hashicorp.com/terraform/docs</code></li>
<li>Argo CD docs: <code>https://argo-cd.readthedocs.io/en/stable/</code></li>
<li>PostgreSQL: The SQL Language: <code>https://www.postgresql.org/docs/15/sql.html</code></li>
</ul>
<hr>
<div class="highlight"><pre><span></span><code>@startmindmap
* 声明式编程
** 过程式
*** 我亲自一步步做
*** 关注 How
*** 清晰可控
** 命令式
*** 你按我说的做
*** 逐条指令
*** 易审计
** 声明式
*** 我只说想要什么
*** 关注 What
*** 系统自己实现
** 典型案例
*** Kubernetes YAML
*** Terraform HCL
*** GitOps
** 核心优势
*** 幂等性
*** 可版本控制
*** 自愈能力
@endmindmap
</code></pre></div>

<p><img alt="声明式编程思维导图" src="../images/journal_20260127_declarative_mindmap.png"></p>
<hr/>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="./tag/programming.html">Programming</a>
      <a href="./tag/devops.html">DevOps</a>
      <a href="./tag/declarative.html">Declarative</a>
      <a href="./tag/kubernetes.html">Kubernetes</a>
      <a href="./tag/terraform.html">Terraform</a>
      <a href="./tag/gitops.html">GitOps</a>
      <a href="./tag/infrastructure-as-code.html">Infrastructure as Code</a>
    </p>
  </div>


  <div class="neighbors">
    <a class="btn float-left" href="./zai-eks-shang-gei-pod-bang-iam-roleirsaserviceaccount-oidcdao-di-zen-yao-hui-shi.html" title="在 EKS 上给 Pod 绑 IAM Role：IRSA（ServiceAccount + OIDC）到底怎么回事">
      <i class="fa fa-angle-left"></i> Previous Post
    </a>
    <a class="btn float-right" href="./zhi-chang-gong-ju-xiang-zhi-5w1h-8c1dbu-hui-wen-wen-ti-shi-xin-ren-zui-da-de-duan-ban.html" title="职场工具箱之 5W1H + 8C1D：不会问问题，是新人最大的短板">
      Next Post <i class="fa fa-angle-right"></i>
    </a>
  </div>

  <div class="related-posts">
    <h4>You might enjoy</h4>
    <ul class="related-posts">
      <li><a href="./python-bian-cheng-de-chang-jian-xian-jing-yu-qi-qiao-yin-ji.html">Python 编程的常见陷阱与奇巧淫技</a></li>
      <li><a href="./shu-ju-diu-shi-de-zai-nan-xian-chang.html">数据丢失的灾难现场</a></li>
      <li><a href="./zai-eks-shang-gei-pod-bang-iam-roleirsaserviceaccount-oidcdao-di-zen-yao-hui-shi.html">在 EKS 上给 Pod 绑 IAM Role：IRSA（ServiceAccount + OIDC）到底怎么回事</a></li>
      <li><a href="./zai-shu-mei-pai-shang-wan-k3scong-an-zhuang-dao-shi-zhan-da-zao-ni-de-si-ren-kubernetes-ji-qun.html">在树莓派上玩 K3s：从安装到实战，打造你的私人 Kubernetes 集群</a></li>
    </ul>
  </div>



<!-- Disqus -->
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'wfblog';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>
    Please enable JavaScript to view comments.
</noscript>
<!-- End Disqus -->
</article>

<footer>
<p>&copy; 2010 ~ 2030  Walter Fan <a href="https://beian.miit.gov.cn" target="_blank">皖ICP备20001876号-1</a></p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
</p><!-- StatusCake -->

<!-- End StatusCake --></footer>  </main>

<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Walter Fan's Blog ",
  "url" : ".",
  "image": "./images/walterfan.jpg",
  "description": "an old programmer never die, he just branch to a new address."
}
</script>
</body>
</html>