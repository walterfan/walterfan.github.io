
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="./theme/stylesheet/style.min.css">


    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
          href="./theme/pygments/github.min.css">



  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/solid.css">


  <link rel="shortcut icon" href="./images/favicon.ico" type="image/x-icon">
  <link rel="icon" href="./images/favicon.ico" type="image/x-icon">










 

<meta name="author" content="Walter Fan" />
<meta name="description" content="用自己手写的 lazy-form-workflow 和 LangGraph 对照，聊聊「把复杂流程当图来跑」这件事：图怎么建、边怎么跳、状态怎么传，以及 AI 决策节点该放在哪。" />
<meta name="keywords" content="ai, workflow, langgraph, agent, java, 流程编排">


  <meta property="og:site_name" content="Walter Fan's Blog"/>
  <meta property="og:title" content="从手搓 Workflow 到 LangGraph：AI 流程编排的两种路径"/>
  <meta property="og:description" content="用自己手写的 lazy-form-workflow 和 LangGraph 对照，聊聊「把复杂流程当图来跑」这件事：图怎么建、边怎么跳、状态怎么传，以及 AI 决策节点该放在哪。"/>
  <meta property="og:locale" content="en_US"/>
  <meta property="og:url" content="./cong-shou-cuo-workflow-dao-langgraphai-liu-cheng-bian-pai-de-liang-chong-lu-jing.html"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="2026-02-08 09:00:00+08:00"/>
  <meta property="article:modified_time" content="2026-02-08 22:30:00+08:00"/>
  <meta property="article:author" content="./author/walter-fan.html">
  <meta property="article:section" content="Journal"/>
  <meta property="article:tag" content="ai"/>
  <meta property="article:tag" content="workflow"/>
  <meta property="article:tag" content="langgraph"/>
  <meta property="article:tag" content="agent"/>
  <meta property="article:tag" content="java"/>
  <meta property="article:tag" content="流程编排"/>
  <meta property="og:image" content="./images/walterfan.jpg">

  <title>Walter Fan's Blog &ndash; 从手搓 Workflow 到 LangGraph：AI 流程编排的两种路径</title>


</head>
<body class="light-theme">

<aside>
  <div>
    <a href="./">
      <img src="./images/walterfan.jpg" alt="Walter Fan" title="Walter Fan">
    </a>

    <h1>
      <a href="./">Walter Fan</a>
    </h1>

    <p>手握灵珠常奋笔, 心开天籁不吹箫</p>


    <nav>
      <ul class="list">



          <li>
            <a target="_blank" href="tao.html" >tao</a>
          </li>
          <li>
            <a target="_blank" href="article.html" >article</a>
          </li>
          <li>
            <a target="_blank" href="interest.html" >interest</a>
          </li>
          <li>
            <a target="_self" href="/wordpress" >notebook</a>
          </li>
          <li>
            <a target="_blank" href="bookmark.html" >bookmark</a>
          </li>
          <li>
            <a target="_blank" href="manual.html" >manual</a>
          </li>
          <li>
            <a target="_self" href="/webrtc/examples/index.html" >webrtc</a>
          </li>
          <li>
            <a target="_blank" href="https://github.com/walterfan" >github</a>
          </li>
      </ul>
    </nav>

    <ul class="social">
      <li>
        <a class="sc-github"
           href="http://github.com/walterfan"
           target="_blank">
          <i class="fa-brands fa-github"></i>
        </a>
      </li>
    </ul>
  </div>

</aside>
  <main>


<article class="single">
  <header>
      
    <h1 id="cong-shou-cuo-workflow-dao-langgraphai-liu-cheng-bian-pai-de-liang-chong-lu-jing">从手搓 Workflow 到 LangGraph：AI 流程编排的两种路径</h1>
    <p>
      Posted on Sun 08 February 2026 in <a href="./category/journal.html">Journal</a>

    </p>
  </header>


  <div>
    <table>
<thead>
<tr>
<th><strong>Abstract</strong></th>
<th>从手搓 Workflow 到 LangGraph：AI 流程编排的两种路径</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Authors</strong></td>
<td><a href="https://www.fanyamin.com">Walter Fan</a></td>
</tr>
<tr>
<td><strong>Category</strong></td>
<td>Journal</td>
</tr>
<tr>
<td><strong>Status</strong></td>
<td>v1.0</td>
</tr>
<tr>
<td><strong>Updated</strong></td>
<td>2026-02-08</td>
</tr>
<tr>
<td><strong>License</strong></td>
<td><a href="http://creativecommons.org/licenses/by-nc-nd/4.0">CC-BY-NC-ND 4.0</a></td>
</tr>
</tbody>
</table>
<h2 id="_1">短大纲（给忙人）</h2>
<details>
<summary>展开看看</summary>

- **Workflow 的本质**：把流程当 DAG 跑，节点做事、边决定往哪跳
- **手搓版 lazy-form-workflow**：Java 实现，Blackboard 传状态，条件边用 `BiPredicate` 决定路由
- **LangGraph 的做法**：`StateGraph` + TypedDict 状态 + `add_conditional_edges`，更偏 Python/LangChain 生态
- **对比与取舍**：两者思路一致，LangGraph 更成熟、生态更全；自研适合做可控、可嵌入的轻量编排
- **可执行清单**：选型时看持久化、人机协作、多 Agent 等需求，再决定用现成框架还是自研
- **常见坑**：priority 顺序、条件边覆盖不全导致静默结束——建图时务必覆盖所有分支

</details>

<hr>
<h2 id="prompt">开头：审批流程改了三次，Prompt 也改了三次，最后没人知道逻辑在哪</h2>
<p>你遇到过没？需求说「超过 1000 块要人工审」，改完又说「病假超过 3 天也要」，再加一条「周末加班调休走快速通道」……每改一次，你就在 Prompt 里塞一段话，最后那个 Prompt 像一锅乱炖：谁都能往里加料，但没人敢动筷子——怕哪句逻辑冲突了。</p>
<p>流程一复杂，光靠「堆 Prompt」就顶不住了。分支多、要查库、要调接口、还要有审计，你总不能靠「请继续」把整条链路串起来。</p>
<p>更靠谱的做法是：<strong>把流程当程序写出来</strong>。节点做具体事，边决定往哪跳，状态在中间传递。这就是 Workflow 编排的思想——跟画流程图差不多，只不过这张图真的能跑。</p>
<p>我去年在 <a href="https://github.com/walterfan/lazy-form-instructor">lazy-form-instructor</a> 里手搓了一个简陋的 workflow 引擎 <code>lazy-form-workflow</code>，后来又仔细看了 LangGraph 的实现。两者思路高度一致，只是语言、生态和细节不一样。这篇就对照着讲讲，顺便帮你少踩我踩过的坑。</p>
<hr>
<h2 id="1-workflow">1) 本质：Workflow 就是「流程图 + 状态机」的合体</h2>
<p>不管自研还是 LangGraph，核心抽象都一样，可以用四个词概括：</p>
<ul>
<li><strong>节点（Node）</strong>：执行一步逻辑，读写共享状态。相当于流程图里的一个方框。</li>
<li><strong>边（Edge）</strong>：连接节点，决定「执行完 A 之后去哪」。相当于箭头。</li>
<li><strong>条件边（Conditional Edge）</strong>：根据当前状态或节点输出，选择走哪条边。相当于流程图里的菱形判断框。</li>
<li><strong>状态（State）</strong>：在节点之间传递的共享数据。相当于「全局变量」，每个节点都能读能写。</li>
</ul>
<p>所以 Workflow 本质上就是一个<strong>有向图</strong>：你画出来的流程图，真的能跑。</p>
<p>图一般是 DAG（有向无环图），否则会死循环。LangGraph 支持环——比如 Agent 循环调用工具、直到满足条件才停——但会通过 checkpoint 和步数限制来控制，不会真给你跑到天荒地老。</p>
<hr>
<h2 id="2-lazy-form-workflow">2) 手搓版：lazy-form-workflow 怎么玩的</h2>
<p>项目在 <a href="https://github.com/walterfan/lazy-form-instructor/tree/master/lazy-form-workflow"><code>lazy-form-instructor/lazy-form-workflow</code></a>，Java、Maven，零依赖 LangChain，适合嵌到现有 Java 后端里。当时做它的动机很简单：我们有个请假审批系统，规则一变再变，不想每次都改 Prompt，就想「能不能把流程当图配置出来」。</p>
<h3 id="_2">核心组件</h3>
<table>
<thead>
<tr>
<th>组件</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>WorkflowGraph</code></td>
<td>存节点和边，提供 <code>validate()</code> 做环检测</td>
</tr>
<tr>
<td><code>WorkflowNode</code></td>
<td>接口，<code>execute(ctx)</code> 返回 <code>NodeResult</code></td>
</tr>
<tr>
<td><code>WorkflowEdge</code></td>
<td>有 <code>BiPredicate&lt;WorkflowContext, NodeResult&gt;</code>，决定能不能走这条边</td>
</tr>
<tr>
<td><code>WorkflowContext</code></td>
<td>Blackboard 模式，<code>vars</code>、<code>state</code>、<code>traceLog</code> 等</td>
</tr>
<tr>
<td><code>WorkflowEngine</code></td>
<td>从起点开始循环执行：跑节点 → 记 trace → 找下一条边 → 下一节点</td>
</tr>
</tbody>
</table>
<h3 id="_3">节点类型</h3>
<ul>
<li><code>StartNode</code> / <code>EndNode</code>：入口和出口</li>
<li><code>ActionNode</code>：做确定性操作（查库、调 API 等）</li>
<li><code>LogicDecisionNode</code>：用 <code>Predicate&lt;WorkflowContext&gt;</code> 做布尔判断</li>
<li><code>AiDecisionNode</code>：调 LLM 做语义决策（审批、路由等），带置信度</li>
</ul>
<h3 id="_4">条件边示例</h3>
<div class="highlight"><pre><span></span><code><span class="n">graph</span><span class="p">.</span><span class="na">addEdge</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">WorkflowEdge</span><span class="p">(</span><span class="s">&quot;check_amount&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;high_value&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="na">payload</span><span class="p">().</span><span class="na">equals</span><span class="p">(</span><span class="kc">true</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;HIGH_VALUE&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>
<span class="n">graph</span><span class="p">.</span><span class="na">addEdge</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">WorkflowEdge</span><span class="p">(</span><span class="s">&quot;check_amount&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;low_value&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="na">payload</span><span class="p">().</span><span class="na">equals</span><span class="p">(</span><span class="kc">false</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;LOW_VALUE&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>
</code></pre></div>

<p><code>WorkflowEngine</code> 按 priority 排序出边，找到第一个 <code>canTraverse(ctx, result)</code> 为 true 的边，就跳到对应节点。</p>
<p>坑点提示：<strong>priority 数值越大越优先</strong>。我一开始写反了，结果「低金额」分支总是先匹配，调试了半天才反应过来——这种顺序问题，写单元测试时一定要覆盖「每条边都能走到」的场景。</p>
<h3 id="blackboard">状态传递：Blackboard</h3>
<p><code>WorkflowContext</code> 就是一块共享黑板：</p>
<ul>
<li><code>request</code>：解析后的表单/请求</li>
<li><code>state</code>：字符串状态（如 <code>"PENDING_APPROVAL"</code>）</li>
<li><code>vars</code>：键值对，节点可读写</li>
<li><code>traceLog</code>：执行轨迹，便于审计</li>
</ul>
<p>每个节点拿到 <code>ctx</code>，改完再 <code>return</code>，下一个节点看到的已经是更新后的状态。</p>
<hr>
<h2 id="3-langgraphstategraph">3) LangGraph：StateGraph + 条件边</h2>
<p>LangGraph 是 LangChain 生态里的流程编排框架，用 Python 写，文档和示例都很丰富。</p>
<h3 id="typeddict-reducer">状态：TypedDict + Reducer</h3>
<p>状态用 TypedDict 定义，每个字段的类型可以带 Reducer。为什么要 Reducer？因为多个节点可能都会往 <code>messages</code> 里追加内容，如果直接覆盖会丢数据，所以用 Reducer 定义「怎么合并」——比如 <code>add_messages</code> 就是「老列表 + 新列表」拼接。</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">GraphState</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">question</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">generation</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">documents</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">messages</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="n">add_messages</span><span class="p">]</span>  <span class="c1"># 用 reducer 合并</span>
</code></pre></div>

<p>节点函数签名为 <code>(state) -&gt; dict</code>，返回的 dict 会按 Reducer 规则合并进总状态。</p>
<h3 id="add_node-add_edge-add_conditional_edges">建图：add_node / add_edge / add_conditional_edges</h3>
<div class="highlight"><pre><span></span><code><span class="n">workflow</span> <span class="o">=</span> <span class="n">StateGraph</span><span class="p">(</span><span class="n">GraphState</span><span class="p">)</span>
<span class="n">workflow</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s2">&quot;retrieve&quot;</span><span class="p">,</span> <span class="n">retrieve</span><span class="p">)</span>
<span class="n">workflow</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s2">&quot;grade_documents&quot;</span><span class="p">,</span> <span class="n">grade_documents</span><span class="p">)</span>
<span class="n">workflow</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s2">&quot;generate&quot;</span><span class="p">,</span> <span class="n">generate</span><span class="p">)</span>

<span class="n">workflow</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">START</span><span class="p">,</span> <span class="s2">&quot;retrieve&quot;</span><span class="p">)</span>
<span class="n">workflow</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s2">&quot;retrieve&quot;</span><span class="p">,</span> <span class="s2">&quot;grade_documents&quot;</span><span class="p">)</span>
<span class="n">workflow</span><span class="o">.</span><span class="n">add_conditional_edges</span><span class="p">(</span>
    <span class="s2">&quot;grade_documents&quot;</span><span class="p">,</span>
    <span class="n">decide_to_generate</span><span class="p">,</span>  <span class="c1"># 路由函数，返回 &quot;generate&quot; 或 &quot;retrieve&quot;</span>
    <span class="p">{</span><span class="s2">&quot;generate&quot;</span><span class="p">:</span> <span class="s2">&quot;generate&quot;</span><span class="p">,</span> <span class="s2">&quot;retrieve&quot;</span><span class="p">:</span> <span class="s2">&quot;retrieve&quot;</span><span class="p">}</span>
<span class="p">)</span>
<span class="n">workflow</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s2">&quot;generate&quot;</span><span class="p">,</span> <span class="n">END</span><span class="p">)</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">workflow</span><span class="o">.</span><span class="n">compile</span><span class="p">()</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">invoke</span><span class="p">({</span><span class="s2">&quot;question&quot;</span><span class="p">:</span> <span class="s2">&quot;...&quot;</span><span class="p">})</span>
</code></pre></div>

<p><code>add_conditional_edges</code> 的第二个参数是一个函数，输入是 state，输出是边的 key（如 <code>"generate"</code>），用来查第三个参数里的映射，得到下一个节点。</p>
<h3 id="lazy-form-workflow">和 lazy-form-workflow 的对应关系</h3>
<table>
<thead>
<tr>
<th>lazy-form-workflow</th>
<th>LangGraph</th>
</tr>
</thead>
<tbody>
<tr>
<td>WorkflowContext</td>
<td>TypedDict state</td>
</tr>
<tr>
<td>WorkflowNode.execute(ctx)</td>
<td>node(state) -&gt; dict</td>
</tr>
<tr>
<td>WorkflowEdge + BiPredicate</td>
<td>add_conditional_edges(fn, mapping)</td>
</tr>
<tr>
<td>WorkflowEngine.execute()</td>
<td>graph.compile().invoke()</td>
</tr>
<tr>
<td>traceLog</td>
<td>需自行在 state 里维护或靠 checkpoint</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="4">4) 对比：什么时候用哪个</h2>
<table>
<thead>
<tr>
<th>维度</th>
<th>lazy-form-workflow</th>
<th>LangGraph</th>
</tr>
</thead>
<tbody>
<tr>
<td>语言</td>
<td>Java</td>
<td>Python</td>
</tr>
<tr>
<td>生态</td>
<td>独立，可嵌 Java 服务</td>
<td>LangChain/LangSmith 等</td>
</tr>
<tr>
<td>状态</td>
<td>Blackboard (vars/state)</td>
<td>TypedDict + Reducer</td>
</tr>
<tr>
<td>持久化</td>
<td>暂无</td>
<td>checkpoint（内存/Redis/Sqlite）</td>
</tr>
<tr>
<td>人机协同</td>
<td>NodeResult.waiting() 预留</td>
<td>human-in-the-loop</td>
</tr>
<tr>
<td>适用</td>
<td>审批、表单、内部流程</td>
<td>Agent、RAG、多步推理</td>
</tr>
</tbody>
</table>
<p>我自己选的话：<strong>审批、表单、内部流程</strong>这种业务，用 Java 自研能嵌进现有系统，trace 也好定制；<strong>Agent、RAG、多步推理</strong>这种，直接上 LangGraph，别 reinvent the wheel。</p>
<hr>
<h2 id="5">5) 可执行清单 + 常见坑</h2>
<p>如果你在考虑「要不要自研 workflow」或「要不要切到 LangGraph」，先按下面 checklist 过一遍：</p>
<ul>
<li>[ ] <strong>持久化</strong>：流程要断点续跑吗？LangGraph 有 checkpoint，自研要自己设计</li>
<li>[ ] <strong>人机协同</strong>：有没有人工审批、二次确认？两边都能做，LangGraph 有现成 human-in-the-loop</li>
<li>[ ] <strong>多 Agent</strong>：需要多个 Agent 协作吗？LangGraph 的 Supervisor 模式更成熟</li>
<li>[ ] <strong>技术栈</strong>：团队主力是 Java 还是 Python？会影响选型</li>
<li>[ ] <strong>审计</strong>：trace 要存哪里、查多久？自研的 traceLog 容易定制</li>
</ul>
<p>常见坑：<strong>条件边没覆盖全</strong>会导致流程「静默结束」——找不到满足的边就直接停，既没报错也没跑到 End。所以建图时务必保证每个分支节点的出边能覆盖所有可能输出；或者显式加一条 default 边，把「意外情况」路由到人工或失败处理节点。</p>
<hr>
<h2 id="_5">总结与思维导图</h2>
<p>两种实现的本质都是：<strong>图 + 状态 + 条件边</strong>。区别在于状态模型（Blackboard vs TypedDict）、生态和持久化能力。选型时先想清楚持久化、人机协同、多 Agent 这些需求，再决定用现成框架还是自研。</p>
<p>如果你已经在一个框架里踩过坑，或者有更好的选型经验，欢迎在评论区聊聊——这种「流程当图跑」的思路，以后会越来越常见，早点把坑踩明白，省得后面重构。</p>
<div class="highlight"><pre><span></span><code>@startmindmap
* Workflow 编排
** 核心抽象
*** 节点 Node
*** 边 Edge
*** 条件边 Conditional Edge
*** 状态 State
** lazy-form-workflow
*** Java / Maven
*** Blackboard 状态
*** BiPredicate 条件边
*** AiDecisionNode 做语义决策
** LangGraph
*** Python / LangChain
*** TypedDict + Reducer
*** add_conditional_edges
*** checkpoint 持久化
** 选型要点
*** 持久化需求
*** 人机协同
*** 技术栈
*** 审计与 trace
@endmindmap
</code></pre></div>

<p><img alt="Workflow 编排思维导图" src="../images/journal_20260208_langgraph_workflow_mindmap.png"></p>
<hr>
<h2 id="_6">扩展阅读</h2>
<ul>
<li><a href="https://docs.langchain.com/oss/python/langgraph/overview">LangGraph 官方文档</a></li>
<li><a href="https://github.com/walterfan/lazy-form-instructor">lazy-form-instructor 仓库</a></li>
<li><a href="./journal_20260206_ai-agent-workflow.md">用 AI Agent 处理复杂流程：先写 Workflow，再写 Prompt</a></li>
</ul>
<hr/>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="./tag/ai.html">ai</a>
      <a href="./tag/workflow.html">workflow</a>
      <a href="./tag/langgraph.html">langgraph</a>
      <a href="./tag/agent.html">agent</a>
      <a href="./tag/java.html">java</a>
      <a href="./tag/liu-cheng-bian-pai.html">流程编排</a>
    </p>
  </div>


  <div class="neighbors">
    <a class="btn float-left" href="./zhi-chang-gong-ju-xiang-zhi-rapidba-hong-xian-he-pai-ban-quan-chai-kai-kua-bu-men-shao-che-pi.html" title="职场工具箱之 RAPID：把红线和拍板权拆开，跨部门少扯皮">
      <i class="fa fa-angle-left"></i> Previous Post
    </a>
  </div>

  <div class="related-posts">
    <h4>You might enjoy</h4>
    <ul class="related-posts">
      <li><a href="./yong-ai-agent-chu-li-fu-za-liu-cheng-xian-xie-workflowzai-xie-prompt.html">用 AI Agent 处理复杂流程：先写 Workflow，再写 Prompt</a></li>
      <li><a href="./prompt-as-codedang-prompt-bu-zhi-shi-hua-er-shi-ke-zhi-xing-de-cheng-xu.html">Prompt-as-Code：当 Prompt 不只是"话"，而是可执行的"程序"</a></li>
      <li><a href="./agent-skillsgei-ai-zhu-shou-zhuang-shang-ji-neng-bao.html">Agent Skills：给 AI 助手装上"技能包"</a></li>
      <li><a href="./ai-fu-zhu-bian-cheng-de-san-da-hu-fa-ke-yan-zheng-xing-ke-guan-ce-xing-ke-li-jie-xing.html">AI 辅助编程的三大护法：可验证性、可观测性、可理解性</a></li>
      <li><a href="./claude-code-shi-yong-ji-qiao-yu-cheng-ben-kong-zhi-zhi-nan.html">Claude Code 使用技巧与成本控制指南</a></li>
    </ul>
  </div>



<!-- Disqus -->
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'wfblog';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>
    Please enable JavaScript to view comments.
</noscript>
<!-- End Disqus -->
</article>

<footer>
<p>&copy; 2010 ~ 2030  Walter Fan <a href="https://beian.miit.gov.cn" target="_blank">皖ICP备20001876号-1</a></p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
</p><!-- StatusCake -->

<!-- End StatusCake --></footer>  </main>

<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Walter Fan's Blog ",
  "url" : ".",
  "image": "./images/walterfan.jpg",
  "description": "an old programmer never die, he just branch to a new address."
}
</script>
</body>
</html>