
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="./theme/stylesheet/style.min.css">


    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
          href="./theme/pygments/github.min.css">



  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/solid.css">


  <link rel="shortcut icon" href="./images/favicon.ico" type="image/x-icon">
  <link rel="icon" href="./images/favicon.ico" type="image/x-icon">










 

<meta name="author" content="Walter Fan" />
<meta name="description" content="以为有了 GC 就可以高枕无忧？太天真了！Go 程序中最隐秘的杀手 —— Goroutine Leak，正在悄悄吃掉你的内存。本文带你深入现场，手把手教你如何发现、排查并彻底消灭它。" />
<meta name="keywords" content="golang, goroutine-leak, memory-leak, troubleshooting, performance">


  <meta property="og:site_name" content="Walter Fan's Blog"/>
  <meta property="og:title" content="警惕！你的 Go 程序正在偷偷&#34;泄漏&#34; —— 详解 Goroutine Leak"/>
  <meta property="og:description" content="以为有了 GC 就可以高枕无忧？太天真了！Go 程序中最隐秘的杀手 —— Goroutine Leak，正在悄悄吃掉你的内存。本文带你深入现场，手把手教你如何发现、排查并彻底消灭它。"/>
  <meta property="og:locale" content="en_US"/>
  <meta property="og:url" content="./jing-ti-ni-de-go-cheng-xu-zheng-zai-tou-tou-xie-lou-xiang-jie-goroutine-leak.html"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="2025-12-13 20:20:00+08:00"/>
  <meta property="article:modified_time" content="2025-12-13 22:30:00+08:00"/>
  <meta property="article:author" content="./author/walter-fan.html">
  <meta property="article:section" content="Tech"/>
  <meta property="article:tag" content="golang"/>
  <meta property="article:tag" content="goroutine-leak"/>
  <meta property="article:tag" content="memory-leak"/>
  <meta property="article:tag" content="troubleshooting"/>
  <meta property="article:tag" content="performance"/>
  <meta property="og:image" content="./images/walterfan.jpg">

  <title>Walter Fan's Blog &ndash; 警惕！你的 Go 程序正在偷偷&#34;泄漏&#34; —— 详解 Goroutine Leak</title>


</head>
<body class="light-theme">

<aside>
  <div>
    <a href="./">
      <img src="./images/walterfan.jpg" alt="Walter Fan" title="Walter Fan">
    </a>

    <h1>
      <a href="./">Walter Fan</a>
    </h1>

    <p>手握灵珠常奋笔, 心开天籁不吹箫</p>


    <nav>
      <ul class="list">



          <li>
            <a target="_self" href="tao.html" >tao</a>
          </li>
          <li>
            <a target="_self" href="interest.html" >interest</a>
          </li>
          <li>
            <a target="_self" href="/wordpress" >notebook</a>
          </li>
          <li>
            <a target="_self" href="bookmark.html" >bookmark</a>
          </li>
          <li>
            <a target="_self" href="/webrtc/examples/index.html" >webrtc</a>
          </li>
          <li>
            <a target="_self" href="https://github.com/walterfan" >github</a>
          </li>
          <li>
            <a target="_self" href="https://www.jianshu.com/u/e0b365801f48" >技术文章</a>
          </li>
      </ul>
    </nav>

    <ul class="social">
      <li>
        <a class="sc-github"
           href="http://github.com/walterfan"
           target="_blank">
          <i class="fa-brands fa-github"></i>
        </a>
      </li>
    </ul>
  </div>

</aside>
  <main>


<article class="single">
  <header>
      
    <h1 id="jing-ti-ni-de-go-cheng-xu-zheng-zai-tou-tou-xie-lou-xiang-jie-goroutine-leak">警惕！你的 Go 程序正在偷偷"泄漏" —— 详解 Goroutine Leak</h1>
    <p>
      Posted on Sat 13 December 2025 in <a href="./category/tech.html">Tech</a>

    </p>
  </header>


  <div>
    <table>
<thead>
<tr>
<th><strong>Abstract</strong></th>
<th>Journal on 2025-12-13</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Authors</strong></td>
<td><a href="https://www.fanyamin.com">Walter Fan</a></td>
</tr>
<tr>
<td><strong>Category</strong></td>
<td>learning note</td>
</tr>
<tr>
<td><strong>Status</strong></td>
<td>v1.0</td>
</tr>
<tr>
<td><strong>Updated</strong></td>
<td>2025-12-13</td>
</tr>
<tr>
<td><strong>License</strong></td>
<td><a href="http://creativecommons.org/licenses/by-nc-nd/4.0">CC-BY-NC-ND 4.0</a></td>
</tr>
</tbody>
</table>
<h2 id="c">👻 只有 C++ 才有内存泄漏？别闹了！</h2>
<p>还记得当年写 C++ 时被 <code>malloc</code> 和 <code>free</code> 支配的恐惧吗？稍微手抖一下，忘记释放内存，服务器几天后就得“口吐白沫”重启。</p>
<p>后来我们转投了 Java 和 Go 的怀抱，心里美滋滋：“这下好了，有垃圾回收（GC）这把尚方宝剑，内存管理这种脏活累活就交给 runtime 吧，我可以专心写业务逻辑（Bug）了！” 🥳</p>
<p><strong>Too Young, Too Simple!</strong></p>
<p>就像 Java 依然会有 <code>Memory Leak</code>（比如静态集合里塞了一堆对象忘了删），Go 程序同样无法幸免。而且，Go 还附赠了一个独有的“特产”—— <strong>Goroutine Leak</strong>。这货比普通的内存泄漏更阴险，它就像潜伏在你家下水道里的史莱姆，不知不觉中越长越大，直到有一天把你家房子撑爆（OOM）。💥</p>
<p>今天，咱们就来扒一扒这个“隐形杀手”的皮。</p>
<h2 id="goroutine-leak">😱 什么是 Goroutine Leak？</h2>
<p>简单来说，就是你启动了一个 Goroutine（协程），然后... <strong>把它忘了</strong>。</p>
<p>它在那儿傻傻地等着一个永远不会到来的信号，或者卡在一个永远无法完成的 IO 操作上。主程序以为它干完活回家吃饭了，实际上它还在那儿占着茅坑不拉屎——不仅占着栈空间（起步 2KB，虽然不大，但架不住多啊），还可能持有各种资源（锁、channel、文件句柄）。</p>
<p>久而久之，你的程序里就堆满了这些“僵尸”协程。GC 想回收它们？没门！因为它们还“活着”（blocked），GC 大爷是不敢动活人的。</p>
<h2 id="_1">🕵️‍♂️ 案发现场：我是怎么把服务器搞挂的</h2>
<p>让我们来看一个经典的“作死”案例。</p>
<p>假设我们要从三个镜像源下载同一个文件，谁快用谁。这听起来是不是很聪明？</p>
<div class="highlight"><pre><span></span><code><span class="kd">func</span><span class="w"> </span><span class="nx">fastestDownload</span><span class="p">()</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">ch</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span>
<span class="w">    </span><span class="nx">mirrors</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;mirror1.com&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;mirror2.com&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;mirror3.com&quot;</span><span class="p">}</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">mirror</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">mirrors</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">url</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 模拟下载</span>
<span class="w">            </span><span class="nx">result</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">download</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span><span class="w"> </span>
<span class="w">            </span><span class="nx">ch</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="c1">// 👈 凶手就在这里！</span>
<span class="w">        </span><span class="p">}(</span><span class="nx">mirror</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">ch</span><span class="w"> </span><span class="c1">// 拿到最快的一个结果就返回</span>
<span class="p">}</span>
</code></pre></div>

<p>这段代码看起来简直完美，利用 Go 的并发特性，性能拉满！😎</p>
<p><strong>但是！</strong> 💀</p>
<p>当最快的那个 <code>mirror</code> 返回结果，主函数 <code>fastestDownload</code> 拿到数据开开心心返回了。剩下那两个慢吞吞的 <code>mirror</code> 呢？</p>
<ol>
<li>它们终于下载完了。</li>
<li>它们试图把结果塞进 <code>ch</code>。</li>
<li><strong>但是！</strong> <code>ch</code> 是一个无缓冲的 channel，而且也没有人在另一头读了（主函数早跑了）。</li>
<li>于是，这两个可怜的 Goroutine 就永远卡在了 <code>ch &lt;- result</code> 这一行，变成了孤魂野鬼，直到程序重启。</li>
</ol>
<p>如果你这是一个高频调用的函数，恭喜你，你的内存曲线会像房价一样，只涨不跌。📈</p>
<h2 id="_2">🛠️ 排查工具箱：捉鬼敢死队</h2>
<p>既然知道有鬼，那怎么抓呢？别怕，这里有几把趁手的兵器。</p>
<h3 id="1-runtimenumgoroutine">1. 最简单的照妖镜：<code>runtime.NumGoroutine()</code></h3>
<p>在你的代码里埋点监控，或者写个简单的 HTTP 接口，定期吐出当前的 Goroutine 数量。</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;fmt&quot;</span>
<span class="w">    </span><span class="s">&quot;runtime&quot;</span>
<span class="w">    </span><span class="s">&quot;time&quot;</span>
<span class="p">)</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">monitor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;👻 当前僵尸...啊不，协程数量: %d\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">runtime</span><span class="p">.</span><span class="nx">NumGoroutine</span><span class="p">())</span>
<span class="w">        </span><span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>如果这个数字随着时间推移稳步上升，从来不回头，那基本上是实锤了。</p>
<h3 id="2-go-tool-pprof">2. 专业的显微镜：<code>go tool pprof</code> 深度剖析</h3>
<p>Go 官方自带的神器 <code>pprof</code>，是排查性能问题和 Goroutine Leak 的瑞士军刀。</p>
<h4 id="21-pprof">2.1 开启 pprof 接口</h4>
<p>首先，在你的程序里加上这几行，开启 pprof 的 HTTP 接口：</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="s">&quot;net/http/pprof&quot;</span><span class="w"> </span><span class="c1">// 导入这个包，会自动注册 /debug/pprof 路由</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 在一个单独的 Goroutine 里启动 pprof 服务</span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 监听 6060 端口，你可以换成任何你喜欢的端口</span>
<span class="w">        </span><span class="nx">http</span><span class="p">.</span><span class="nx">ListenAndServe</span><span class="p">(</span><span class="s">&quot;localhost:6060&quot;</span><span class="p">,</span><span class="w"> </span><span class="kc">nil</span><span class="p">)</span>
<span class="w">    </span><span class="p">}()</span>

<span class="w">    </span><span class="c1">// ... 你的业务代码</span>
<span class="p">}</span>
</code></pre></div>

<h4 id="22">2.2 浏览器快速查看 (适合快速一瞥)</h4>
<p>程序跑起来后，在浏览器打开：
*   <strong>Goroutine 概览</strong>: <code>http://localhost:6060/debug/pprof/goroutine?debug=1</code>
*   <strong>堆内存</strong>: <code>http://localhost:6060/debug/pprof/heap?debug=1</code>
*   <strong>阻塞情况</strong>: <code>http://localhost:6060/debug/pprof/block?debug=1</code></p>
<p>在 Goroutine 页面，你会看到所有正在运行的 Goroutine 的堆栈信息。如果有一大堆 Goroutine 都卡在同一行代码上，那里就是案发现场！🔍</p>
<h4 id="23-go-tool-pprof">2.3 <code>go tool pprof</code> 命令行深度分析 (推荐！)</h4>
<p>浏览器只能看个大概，要做深度分析，还得用命令行。</p>
<p><strong>Step 1: 采集 profile 数据</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1"># 采集 Goroutine profile (推荐用这个抓 leak)</span>
go<span class="w"> </span>tool<span class="w"> </span>pprof<span class="w"> </span>http://localhost:6060/debug/pprof/goroutine

<span class="c1"># 采集 CPU profile (分析 CPU 热点)</span>
go<span class="w"> </span>tool<span class="w"> </span>pprof<span class="w"> </span>http://localhost:6060/debug/pprof/profile?seconds<span class="o">=</span><span class="m">30</span>

<span class="c1"># 采集 Heap profile (分析内存分配)</span>
go<span class="w"> </span>tool<span class="w"> </span>pprof<span class="w"> </span>http://localhost:6060/debug/pprof/heap
</code></pre></div>

<p>执行后，你会进入一个交互式命令行。</p>
<p><strong>Step 2: 常用分析命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>top</code></td>
<td>显示消耗资源最多的函数</td>
<td>快速定位热点</td>
</tr>
<tr>
<td><code>top 20</code></td>
<td>显示 Top 20</td>
<td>看更多</td>
</tr>
<tr>
<td><code>list &lt;函数名&gt;</code></td>
<td>显示函数的源码，并标注每行的消耗</td>
<td>精确定位到代码行</td>
</tr>
<tr>
<td><code>web</code></td>
<td>生成一张 SVG 图，用浏览器打开</td>
<td>可视化调用关系 (需要安装 graphviz)</td>
</tr>
<tr>
<td><code>png</code></td>
<td>导出 PNG 图片</td>
<td>保存分析结果</td>
</tr>
<tr>
<td><code>traces</code></td>
<td>显示调用栈</td>
<td>看完整的调用链</td>
</tr>
</tbody>
</table>
<p><strong>Step 3: 实战演练</strong></p>
<p>假设我们怀疑有 Goroutine Leak，执行：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>go<span class="w"> </span>tool<span class="w"> </span>pprof<span class="w"> </span>http://localhost:6060/debug/pprof/goroutine
Fetching<span class="w"> </span>profile<span class="w"> </span>over<span class="w"> </span>HTTP<span class="w"> </span>from<span class="w"> </span>http://localhost:6060/debug/pprof/goroutine
...
<span class="o">(</span>pprof<span class="o">)</span><span class="w"> </span>top
Showing<span class="w"> </span>nodes<span class="w"> </span>accounting<span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="m">1024</span>,<span class="w"> </span><span class="m">100</span>%<span class="w"> </span>of<span class="w"> </span><span class="m">1024</span><span class="w"> </span>total
Showing<span class="w"> </span>top<span class="w"> </span><span class="m">10</span><span class="w"> </span>nodes<span class="w"> </span>out<span class="w"> </span>of<span class="w"> </span><span class="m">15</span>
<span class="w">      </span>flat<span class="w">  </span>flat%<span class="w">   </span>sum%<span class="w">        </span>cum<span class="w">   </span>cum%
<span class="w">      </span><span class="m">1000</span><span class="w"> </span><span class="m">97</span>.66%<span class="w"> </span><span class="m">97</span>.66%<span class="w">       </span><span class="m">1000</span><span class="w"> </span><span class="m">97</span>.66%<span class="w">  </span>main.fastestDownload.func1
<span class="w">        </span><span class="m">20</span><span class="w">  </span><span class="m">1</span>.95%<span class="w"> </span><span class="m">99</span>.61%<span class="w">         </span><span class="m">20</span><span class="w">  </span><span class="m">1</span>.95%<span class="w">  </span>runtime.gopark
<span class="w">         </span><span class="m">4</span><span class="w">  </span><span class="m">0</span>.39%<span class="w">   </span><span class="m">100</span>%<span class="w">          </span><span class="m">4</span><span class="w">  </span><span class="m">0</span>.39%<span class="w">  </span>runtime.chanrecv
...
</code></pre></div>

<p>看到了吗？<code>main.fastestDownload.func1</code> 占了 97.66%！这就是那个泄漏的匿名函数。</p>
<p>然后用 <code>list</code> 看看具体是哪一行：</p>
<div class="highlight"><pre><span></span><code><span class="o">(</span>pprof<span class="o">)</span><span class="w"> </span>list<span class="w"> </span>fastestDownload
Total:<span class="w"> </span><span class="m">1024</span>
<span class="nv">ROUTINE</span><span class="w"> </span><span class="o">========================</span><span class="w"> </span>main.fastestDownload.func1<span class="w"> </span><span class="k">in</span><span class="w"> </span>/path/to/main.go
<span class="w">    </span><span class="m">1000</span><span class="w">     </span><span class="m">1000</span><span class="w"> </span><span class="o">(</span>flat,<span class="w"> </span>cum<span class="o">)</span><span class="w"> </span><span class="m">97</span>.66%<span class="w"> </span>of<span class="w"> </span>Total
<span class="w">         </span>.<span class="w">          </span>.<span class="w">     </span><span class="m">48</span>:<span class="w">        </span>go<span class="w"> </span>func<span class="o">(</span>url<span class="w"> </span>string<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">         </span>.<span class="w">          </span>.<span class="w">     </span><span class="m">49</span>:<span class="w">            </span>result<span class="w"> </span>:<span class="o">=</span><span class="w"> </span>download<span class="o">(</span>url<span class="o">)</span>
<span class="w">    </span><span class="m">1000</span><span class="w">     </span><span class="m">1000</span><span class="w">     </span><span class="m">50</span>:<span class="w">            </span>ch<span class="w"> </span>&lt;-<span class="w"> </span>result<span class="w"> </span>//<span class="w"> </span>👈<span class="w"> </span><span class="m">1000</span><span class="w"> </span>个<span class="w"> </span>Goroutine<span class="w"> </span>卡在这里！
<span class="w">         </span>.<span class="w">          </span>.<span class="w">     </span><span class="m">51</span>:<span class="w">        </span><span class="o">}(</span>mirror<span class="o">)</span>
</code></pre></div>

<p><strong>破案了！</strong> 1000 个 Goroutine 全卡在 <code>ch &lt;- result</code> 这一行，等着往 channel 里塞数据，但没人读。</p>
<h4 id="24-flame-graph">2.4 生成火焰图 (Flame Graph)</h4>
<p>火焰图是分析性能问题的大杀器，一眼就能看出哪里最"热"。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 需要先安装 graphviz</span>
<span class="c1"># macOS: brew install graphviz</span>
<span class="c1"># Ubuntu: sudo apt-get install graphviz</span>

<span class="c1"># 采集 CPU profile 并生成火焰图</span>
go<span class="w"> </span>tool<span class="w"> </span>pprof<span class="w"> </span>-http<span class="o">=</span>:8080<span class="w"> </span>http://localhost:6060/debug/pprof/profile?seconds<span class="o">=</span><span class="m">30</span>
</code></pre></div>

<p>这会在浏览器打开一个交互式的 Web UI，你可以切换到 "Flame Graph" 视图，看到漂亮的火焰图。🔥</p>
<h4 id="25-profile-diff">2.5 对比两次 Profile (Diff)</h4>
<p>这招用来确认"修复是否有效"特别好使。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 先采集一次 (修复前)</span>
go<span class="w"> </span>tool<span class="w"> </span>pprof<span class="w"> </span>-output<span class="o">=</span>before.pprof<span class="w"> </span>http://localhost:6060/debug/pprof/goroutine

<span class="c1"># ... 部署你的修复代码 ...</span>

<span class="c1"># 再采集一次 (修复后)</span>
go<span class="w"> </span>tool<span class="w"> </span>pprof<span class="w"> </span>-output<span class="o">=</span>after.pprof<span class="w"> </span>http://localhost:6060/debug/pprof/goroutine

<span class="c1"># 对比两次结果</span>
go<span class="w"> </span>tool<span class="w"> </span>pprof<span class="w"> </span>-base<span class="o">=</span>before.pprof<span class="w"> </span>after.pprof
<span class="o">(</span>pprof<span class="o">)</span><span class="w"> </span>top
<span class="c1"># 如果修复成功，这里应该看到 Goroutine 数量下降了</span>
</code></pre></div>

<h3 id="3-goleak">3. 单元测试里的守门员：<code>goleak</code></h3>
<p>Uber 开源了一个库 <code>go.uber.org/goleak</code>，专门用来在单元测试里抓 Goroutine Leak。强烈推荐集成到你的 CI/CD 里。</p>
<div class="highlight"><pre><span></span><code><span class="kd">func</span><span class="w"> </span><span class="nx">TestFastestDownload</span><span class="p">(</span><span class="nx">t</span><span class="w"> </span><span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="nx">goleak</span><span class="p">.</span><span class="nx">VerifyNone</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span><span class="w"> </span><span class="c1">// 👈 测试结束时，如果还有多余的 Goroutine，直接报错！</span>

<span class="w">    </span><span class="c1">// ... 你的测试代码</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="_3">🛡️ 防身术：如何避免被坑？</h2>
<h3 id="1-channel-unbuffered-channel">1. 永远不要使用无缓冲 Channel (Unbuffered Channel) 除非你确定有人读</h3>
<p>回到上面的案例，怎么修？最简单的方法，给 Channel 加个缓冲！</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 缓冲区大小等于协程数量，这样它们就算没人读，也能把结果塞进去然后安心退出</span>
<span class="nx">ch</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">mirrors</span><span class="p">))</span><span class="w"> </span>
</code></pre></div>

<h3 id="2-context">2. Context 是个好东西，请随身携带</h3>
<p><code>context.Context</code> 是 Go 并发模式里的这一剂良药。它可以用来取消所有派生出来的 Goroutine。</p>
<div class="highlight"><pre><span></span><code><span class="kd">func</span><span class="w"> </span><span class="nx">saferDownload</span><span class="p">(</span><span class="nx">ctx</span><span class="w"> </span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">ch</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="c1">// 这里还是要注意缓冲，或者配合 select</span>
<span class="w">    </span><span class="nx">ctx</span><span class="p">,</span><span class="w"> </span><span class="nx">cancel</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nx">context</span><span class="p">.</span><span class="nx">WithCancel</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
<span class="w">    </span><span class="k">defer</span><span class="w"> </span><span class="nx">cancel</span><span class="p">()</span><span class="w"> </span><span class="c1">// 👈 关键：函数退出时，发出取消信号</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">_</span><span class="p">,</span><span class="w"> </span><span class="nx">mirror</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">mirrors</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">(</span><span class="nx">url</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">select</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">case</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">Done</span><span class="p">():</span><span class="w"> </span><span class="c1">// 收到取消信号，立即撤退</span>
<span class="w">                </span><span class="k">return</span>
<span class="w">            </span><span class="k">case</span><span class="w"> </span><span class="nx">ch</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">download</span><span class="p">(</span><span class="nx">url</span><span class="p">):</span>
<span class="w">                </span><span class="c1">// 正常发送</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}(</span><span class="nx">mirror</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="3-select-default">3. <code>Select</code> 里的 <code>default</code> 分支</h3>
<p>如果你想向一个 channel 发送数据，但又不确定对面在不在，可以用 <code>select</code> + <code>default</code> 来避免阻塞。</p>
<div class="highlight"><pre><span></span><code><span class="k">select</span><span class="w"> </span><span class="p">{</span>
<span class="k">case</span><span class="w"> </span><span class="nx">ch</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">result</span><span class="p">:</span>
<span class="w">    </span><span class="c1">// 发送成功</span>
<span class="k">default</span><span class="p">:</span>
<span class="w">    </span><span class="c1">// 发送不出去？算了，溜了溜了 👋</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Nobody is listening, I&#39;m out!&quot;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="_4">📝 总结</h2>
<p>Goroutine 虽然轻量，但也别把它当成免费的午餐。</p>
<ol>
<li><strong>创建就要负责到底</strong>：生了孩子（Goroutine）就要管它养老送终（Exit）。</li>
<li><strong>警惕阻塞</strong>：任何涉及 Channel 操作或 IO 的地方，都要问自己一句：“如果这里卡住了，它能退出来吗？”</li>
<li><strong>善用工具</strong>：pprof 和 goleak 是你的好朋友。</li>
</ol>
<p>写 Go 代码，不仅要追求 <code>if err != nil</code> 的手速，更要有对 Goroutine 生命周期的敬畏之心。🙏</p>
<p>祝大家的 Goroutine 都能以此生最优雅的姿势退出！💃</p>
<hr/>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="./tag/golang.html">golang</a>
      <a href="./tag/goroutine-leak.html">goroutine-leak</a>
      <a href="./tag/memory-leak.html">memory-leak</a>
      <a href="./tag/troubleshooting.html">troubleshooting</a>
      <a href="./tag/performance.html">performance</a>
    </p>
  </div>


  <div class="neighbors">
    <a class="btn float-left" href="./tips-for-vibe-coding-with-cursor-bie-rang-ai-cai-ni-de-xin-si.html" title="Tips for Vibe Coding with Cursor: 别让 AI 猜你的心思">
      <i class="fa fa-angle-left"></i> Previous Post
    </a>
    <a class="btn float-right" href="./java-lao-yi-shang-neng-fan-fou.html" title="Java 老矣, 尚能饭否">
      Next Post <i class="fa fa-angle-right"></i>
    </a>
  </div>

  <div class="related-posts">
    <h4>You might enjoy</h4>
    <ul class="related-posts">
      <li><a href="./bei-guan-suo-le-guan-suo-wu-suo-go-bing-fa-kong-zhi-de-san-chong-zi-shi.html">悲观锁、乐观锁、无锁：Go 并发控制的三种姿势</a></li>
      <li><a href="./go-cheng-xu-beng-kui-fen-xi-shi-zhan-cong-coredump-dao-gen-yin-ding-wei.html">Go 程序崩溃分析实战：从 Coredump 到根因定位</a></li>
      <li><a href="./yong-eino-gou-jian-ai-agentgo-kai-fa-zhe-de-langchain-zhong-yu-lai-liao.html">用 Eino 构建 AI Agent：Go 开发者的 LangChain 终于来了</a></li>
      <li><a href="./vuejs-ying-yong-de-bai-ping-si-ji-yuan-yin-pai-cha-yu-jie-jue-fang-an-quan-gong-lue.html">Vue.js 应用的"白屏死机"：原因排查与解决方案全攻略</a></li>
    </ul>
  </div>



<!-- Disqus -->
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'wfblog';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>
    Please enable JavaScript to view comments.
</noscript>
<!-- End Disqus -->
</article>

<footer>
<p>&copy; 2010 ~ 2030  Walter Fan <a href="https://beian.miit.gov.cn" target="_blank">皖ICP备20001876号-1</a></p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
</p><!-- StatusCake -->

<!-- End StatusCake --></footer>  </main>

<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Walter Fan's Blog ",
  "url" : ".",
  "image": "./images/walterfan.jpg",
  "description": "an old programmer never die, he just branch to a new address."
}
</script>
</body>
</html>