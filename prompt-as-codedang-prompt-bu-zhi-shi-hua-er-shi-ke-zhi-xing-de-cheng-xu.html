
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="./theme/stylesheet/style.min.css">


    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
          href="./theme/pygments/github.min.css">



  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/solid.css">


  <link rel="shortcut icon" href="./images/favicon.ico" type="image/x-icon">
  <link rel="icon" href="./images/favicon.ico" type="image/x-icon">










 

<meta name="author" content="Walter Fan" />
<meta name="description" content="你以为 Prompt 只是&#34;和 AI 聊天&#34;？错了。现代 Prompt 可以执行命令、调用工具、定义工作流——它已经从&#34;自然语言&#34;进化成了&#34;可执行的程序&#34;。本文通过 Cursor 的 Rules、Commands、MCP Tools 和 OpenSpec 案例，手把手教你把 Prompt 变成真正的&#34;代码&#34;。" />
<meta name="keywords" content="AI, Prompt Engineering, Cursor, MCP, OpenSpec, Workflow">


  <meta property="og:site_name" content="Walter Fan's Blog"/>
  <meta property="og:title" content="Prompt-as-Code：当 Prompt 不只是&#34;话&#34;，而是可执行的&#34;程序&#34;"/>
  <meta property="og:description" content="你以为 Prompt 只是&#34;和 AI 聊天&#34;？错了。现代 Prompt 可以执行命令、调用工具、定义工作流——它已经从&#34;自然语言&#34;进化成了&#34;可执行的程序&#34;。本文通过 Cursor 的 Rules、Commands、MCP Tools 和 OpenSpec 案例，手把手教你把 Prompt 变成真正的&#34;代码&#34;。"/>
  <meta property="og:locale" content="en_US"/>
  <meta property="og:url" content="./prompt-as-codedang-prompt-bu-zhi-shi-hua-er-shi-ke-zhi-xing-de-cheng-xu.html"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="2026-01-20 10:00:00+08:00"/>
  <meta property="article:modified_time" content="2026-01-20 12:00:00+08:00"/>
  <meta property="article:author" content="./author/walter-fan.html">
  <meta property="article:section" content="AI"/>
  <meta property="article:tag" content="AI"/>
  <meta property="article:tag" content="Prompt Engineering"/>
  <meta property="article:tag" content="Cursor"/>
  <meta property="article:tag" content="MCP"/>
  <meta property="article:tag" content="OpenSpec"/>
  <meta property="article:tag" content="Workflow"/>
  <meta property="og:image" content="./images/walterfan.jpg">

  <title>Walter Fan's Blog &ndash; Prompt-as-Code：当 Prompt 不只是&#34;话&#34;，而是可执行的&#34;程序&#34;</title>


</head>
<body class="light-theme">

<aside>
  <div>
    <a href="./">
      <img src="./images/walterfan.jpg" alt="Walter Fan" title="Walter Fan">
    </a>

    <h1>
      <a href="./">Walter Fan</a>
    </h1>

    <p>手握灵珠常奋笔, 心开天籁不吹箫</p>


    <nav>
      <ul class="list">



          <li>
            <a target="_self" href="tao.html" >tao</a>
          </li>
          <li>
            <a target="_self" href="interest.html" >interest</a>
          </li>
          <li>
            <a target="_self" href="/wordpress" >notebook</a>
          </li>
          <li>
            <a target="_self" href="bookmark.html" >bookmark</a>
          </li>
          <li>
            <a target="_self" href="/webrtc/examples/index.html" >webrtc</a>
          </li>
          <li>
            <a target="_self" href="https://github.com/walterfan" >github</a>
          </li>
          <li>
            <a target="_self" href="https://www.jianshu.com/u/e0b365801f48" >技术文章</a>
          </li>
      </ul>
    </nav>

    <ul class="social">
      <li>
        <a class="sc-github"
           href="http://github.com/walterfan"
           target="_blank">
          <i class="fa-brands fa-github"></i>
        </a>
      </li>
    </ul>
  </div>

</aside>
  <main>


<article class="single">
  <header>
      
    <h1 id="prompt-as-codedang-prompt-bu-zhi-shi-hua-er-shi-ke-zhi-xing-de-cheng-xu">Prompt-as-Code：当 Prompt 不只是"话"，而是可执行的"程序"</h1>
    <p>
      Posted on Tue 20 January 2026 in <a href="./category/ai.html">AI</a>

    </p>
  </header>


  <div>
    <table>
<thead>
<tr>
<th><strong>Abstract</strong></th>
<th>Prompt 不只是"话"，而是可执行的"程序"</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Authors</strong></td>
<td><a href="https://www.fanyamin.com">Walter Fan</a></td>
</tr>
<tr>
<td><strong>Category</strong></td>
<td>AI 工程</td>
</tr>
<tr>
<td><strong>Status</strong></td>
<td>v1.1</td>
</tr>
<tr>
<td><strong>Updated</strong></td>
<td>2026-01-20</td>
</tr>
<tr>
<td><strong>License</strong></td>
<td><a href="http://creativecommons.org/licenses/by-nc-nd/4.0">CC-BY-NC-ND 4.0</a></td>
</tr>
</tbody>
</table>
<blockquote>
<p>"Any sufficiently advanced prompt is indistinguishable from code."
—— 改编自 Arthur C. Clarke</p>
</blockquote>
<hr>
<h2 id="prompt-prompt">开篇：Prompt 已经不是你以为的那个"Prompt"了</h2>
<p>很多人对 Prompt 的认知还停留在"和 AI 聊天"的阶段：</p>
<div class="highlight"><pre><span></span><code>你：&quot;帮我写一段 Python 代码&quot;
AI：&quot;好的，这是代码……&quot;
你：&quot;谢谢&quot;
结束。
</code></pre></div>

<p>但如果我告诉你，现代的 Prompt 可以：</p>
<ul>
<li>✅ <strong>执行终端命令</strong>（<code>git status</code>、<code>npm install</code>、<code>docker-compose up</code>）</li>
<li>✅ <strong>调用外部 API</strong>（Jira、GitLab、Slack、数据库）</li>
<li>✅ <strong>读写文件系统</strong>（创建文件、修改代码、生成配置）</li>
<li>✅ <strong>定义完整的工作流</strong>（条件分支、循环、多步骤协作）</li>
<li>✅ <strong>触发 CI/CD 流程</strong>（提交代码、创建 PR、部署服务）</li>
</ul>
<p>你会怎么想？</p>
<p><strong>这不是"聊天"，这是在写程序。</strong></p>
<p>只不过，这个"程序"是用自然语言写的。</p>
<hr>
<p>这就是今天要聊的主题：<strong>Prompt-as-Code</strong>。</p>
<p>它不仅仅是"把 Prompt 存到文件里"这么简单，更重要的是：</p>
<blockquote>
<p><strong>Prompt 可以像代码一样被执行，定义工作流，调用工具，产生副作用。</strong></p>
</blockquote>
<p>读完这篇文章，你会收获：
1. 理解 Prompt-as-Code 的两层含义：<strong>管理</strong> + <strong>执行</strong>
2. 掌握如何在 Prompt 中定义 <strong>Workflow</strong>
3. 了解 MCP（Model Context Protocol）如何让 Prompt 调用<strong>外部工具</strong>
4. 看一个真实案例：OpenSpec 是如何用 Prompt 编排复杂流程的</p>
<hr>
<h2 id="prompt-as-code">一、Prompt-as-Code 的两层含义</h2>
<h3 id="11-prompt">1.1 第一层：像管理代码一样管理 Prompt</h3>
<p>这是最基础的理解：</p>
<table>
<thead>
<tr>
<th>传统 Prompt</th>
<th>Prompt-as-Code</th>
</tr>
</thead>
<tbody>
<tr>
<td>存在聊天记录里</td>
<td>存在 Git 仓库里</td>
</tr>
<tr>
<td>每次从头写</td>
<td>一次定义，多次调用</td>
</tr>
<tr>
<td>只有自己知道</td>
<td>团队可共享、可 review</td>
</tr>
<tr>
<td>无法追溯修改</td>
<td>有 commit history</td>
</tr>
</tbody>
</table>
<p>如果你只做到这一步，你已经比 80% 的人强了。</p>
<p>但这还不够。</p>
<h3 id="12-prompt">1.2 第二层：Prompt 本身就是可执行的程序</h3>
<p>这才是 Prompt-as-Code 的精髓：</p>
<div class="highlight"><pre><span></span><code>传统代码：  if (condition) { doSomething(); }
Prompt 代码：如果用户要求创建新功能，先运行 `openspec list` 检查冲突
</code></pre></div>

<p><strong>两者的本质是一样的</strong>——都是定义"在什么条件下，执行什么操作"。</p>
<p>区别只是：
- 传统代码用编程语言（Python/JavaScript）
- Prompt 代码用自然语言（中文/英文）</p>
<p>而现代 AI 助手（如 Cursor）已经可以：</p>
<ol>
<li><strong>解析</strong> Prompt 中的流程定义</li>
<li><strong>执行</strong> Prompt 中指定的命令</li>
<li><strong>调用</strong> Prompt 中声明的工具</li>
<li><strong>判断</strong> 条件分支，决定下一步</li>
</ol>
<p>这就是为什么我说：<strong>Prompt 已经是可执行的程序了。</strong></p>
<hr>
<h2 id="prompt-workflow">二、在 Prompt 中定义 Workflow</h2>
<h3 id="21-prompt-workflow">2.1 什么是 Prompt Workflow？</h3>
<p>传统的 Prompt 是"一问一答"：</p>
<div class="highlight"><pre><span></span><code>用户：帮我写一个函数
AI：好的，这是函数……
</code></pre></div>

<p>Workflow Prompt 是"多步骤协作"：</p>
<div class="highlight"><pre><span></span><code>用户：帮我创建一个新功能

AI：
1. 首先，我需要检查现有功能 → 运行 `openspec list`
2. 发现没有冲突 → 创建 proposal.md
3. 等待用户确认 → 用户说&quot;继续&quot;
4. 创建 tasks.md → 创建 specs/
5. 运行验证 → `openspec validate --strict`
6. 完成！
</code></pre></div>

<p><strong>这就是 Workflow</strong>——一个有步骤、有条件、有反馈的完整流程。</p>
<h3 id="22-workflow">2.2 Workflow 的核心要素</h3>
<p>在 Prompt 中定义 Workflow，需要包含以下要素：</p>
<table>
<thead>
<tr>
<th>要素</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>触发条件</strong></td>
<td>什么时候启动这个流程</td>
<td>"当用户要求创建新功能时"</td>
</tr>
<tr>
<td><strong>前置检查</strong></td>
<td>开始前需要确认什么</td>
<td>"先运行 <code>openspec list</code> 检查冲突"</td>
</tr>
<tr>
<td><strong>步骤序列</strong></td>
<td>按什么顺序执行</td>
<td>"1. 创建目录 2. 生成模板 3. 验证格式"</td>
</tr>
<tr>
<td><strong>条件分支</strong></td>
<td>遇到不同情况怎么处理</td>
<td>"如果已存在同名功能，询问用户是否覆盖"</td>
</tr>
<tr>
<td><strong>工具调用</strong></td>
<td>需要调用什么外部工具</td>
<td>"运行 <code>git status</code>，读取 Jira 票据"</td>
</tr>
<tr>
<td><strong>终止条件</strong></td>
<td>什么时候算完成</td>
<td>"当 <code>openspec validate</code> 返回成功时"</td>
</tr>
</tbody>
</table>
<h3 id="23-workflow-prompt">2.3 真实示例：一个完整的 Workflow Prompt</h3>
<p>以下是一个真实的 Cursor Command，它定义了一个完整的"创建技术设计文档"工作流：</p>
<div class="highlight"><pre><span></span><code>---
name: /design-doc
<span class="gu">description: 从 Jira 需求生成技术设计文档</span>
<span class="gu">---</span>

<span class="gh"># 技术设计文档生成器</span>

<span class="gu">## 触发条件</span>
当用户输入 <span class="sb">`/design-doc &lt;JIRA-KEY&gt;`</span> 时触发。

<span class="gu">## Workflow</span>

<span class="gu">### Step 1: 获取需求上下文</span>
<span class="k">1.</span> 调用 MCP Tool <span class="sb">`get_jira_issue`</span> 获取 Jira 票据详情
<span class="k">2.</span> 读取 <span class="sb">`openspec/project.md`</span> 了解项目技术栈
<span class="k">3.</span> 运行 <span class="sb">`git log --oneline -10`</span> 了解最近的代码变更

<span class="gu">### Step 2: 分析并确认范围</span>
<span class="k">1.</span> 总结 Jira 票据的核心需求
<span class="k">2.</span> 列出受影响的模块和文件
<span class="k">3.</span> <span class="gs">**询问用户确认**</span>：展示分析结果，等待用户说&quot;继续&quot;或修改

<span class="gu">### Step 3: 生成设计文档</span>
如果用户确认，则：
<span class="k">1.</span> 创建 <span class="sb">`docs/design/&lt;JIRA-KEY&gt;.md`</span>
<span class="k">2.</span> 按照以下模板生成内容：
<span class="w">   </span><span class="k">-</span><span class="w"> </span>## 背景与目标
<span class="w">   </span><span class="k">-</span><span class="w"> </span>## 技术方案
<span class="w">   </span><span class="k">-</span><span class="w"> </span>## API 设计
<span class="w">   </span><span class="k">-</span><span class="w"> </span>## 数据模型
<span class="w">   </span><span class="k">-</span><span class="w"> </span>## 风险与缓解措施

<span class="gu">### Step 4: 关联与验证</span>
<span class="k">1.</span> 调用 MCP Tool <span class="sb">`update_jira_issue`</span> 将文档链接写入 Jira
<span class="k">2.</span> 运行 <span class="sb">`markdownlint`</span> 检查文档格式
<span class="k">3.</span> 如果有错误，自动修复

<span class="gu">### Step 5: 完成</span>
输出：&quot;✅ 设计文档已生成：docs/design/&lt;JIRA-KEY&gt;.md&quot;
</code></pre></div>

<p><strong>注意这个 Prompt 里发生了什么：</strong></p>
<ol>
<li><strong>调用外部工具</strong>：<code>get_jira_issue</code>、<code>update_jira_issue</code></li>
<li><strong>执行终端命令</strong>：<code>git log</code>、<code>markdownlint</code></li>
<li><strong>创建文件</strong>：<code>docs/design/&lt;JIRA-KEY&gt;.md</code></li>
<li><strong>条件分支</strong>：等待用户确认后才继续</li>
<li><strong>错误处理</strong>：检测到错误时自动修复</li>
</ol>
<p><strong>这不是聊天，这是一个完整的程序。</strong></p>
<hr>
<h2 id="mcp-prompt">三、MCP：让 Prompt 拥有"手脚"</h2>
<h3 id="31-mcp">3.1 什么是 MCP？</h3>
<p>MCP（Model Context Protocol）是 Anthropic 提出的一个协议，它让 AI 可以<strong>调用外部工具</strong>。</p>
<p>如果说 Prompt 是 AI 的"大脑"，那么 MCP Tools 就是 AI 的"手脚"：</p>
<div class="highlight"><pre><span></span><code>┌─────────────────────────────────────────────────────────────┐
│                         AI 大脑                             │
│                    （理解、推理、决策）                       │
├─────────────────────────────────────────────────────────────┤
│                      MCP Protocol                           │
├──────────┬──────────┬──────────┬──────────┬────────────────┤
│ 文件系统  │  终端    │  Jira   │  GitLab  │   浏览器       │
│ 读写文件  │ 执行命令  │ 读写票据 │ 读写 MR  │   自动化测试   │
└──────────┴──────────┴──────────┴──────────┴────────────────┘
</code></pre></div>

<h3 id="32-mcp-tools">3.2 常用的 MCP Tools</h3>
<table>
<thead>
<tr>
<th>Tool 类别</th>
<th>具体功能</th>
<th>在 Prompt 中怎么用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>文件系统</strong></td>
<td>读写文件、创建目录</td>
<td>"读取 <code>src/config.ts</code> 的内容"</td>
</tr>
<tr>
<td><strong>终端</strong></td>
<td>执行 Shell 命令</td>
<td>"运行 <code>npm run test</code>"</td>
</tr>
<tr>
<td><strong>Jira</strong></td>
<td>获取/更新票据</td>
<td>"获取 JIRA-12345 的详情"</td>
</tr>
<tr>
<td><strong>GitLab</strong></td>
<td>创建 MR、获取 Diff</td>
<td>"提交代码并创建 Merge Request"</td>
</tr>
<tr>
<td><strong>浏览器</strong></td>
<td>自动化测试、截图</td>
<td>"打开 localhost:3000，检查页面是否正常"</td>
</tr>
<tr>
<td><strong>数据库</strong></td>
<td>查询/更新数据</td>
<td>"查询用户表中的活跃用户数"</td>
</tr>
<tr>
<td><strong>Slack/飞书</strong></td>
<td>发送消息</td>
<td>"在 #dev 频道发送部署通知"</td>
</tr>
</tbody>
</table>
<h3 id="33-prompt-mcp-tools">3.3 在 Prompt 中调用 MCP Tools</h3>
<p>以下是一个调用多个 MCP Tools 的 Prompt 示例：</p>
<div class="highlight"><pre><span></span><code><span class="gh"># 自动化发布流程</span>

<span class="gu">## 触发条件</span>
当用户说&quot;发布 v1.2.3&quot;时触发。

<span class="gu">## Workflow</span>

<span class="gu">### Step 1: 预检查</span>
<span class="k">1.</span> 运行终端命令：`git status`
<span class="w">   </span><span class="k">-</span><span class="w"> </span>如果有未提交的更改，**停止**并提示用户先提交
<span class="k">2.</span> 运行终端命令：`npm run test`
<span class="w">   </span><span class="k">-</span><span class="w"> </span>如果测试失败，**停止**并展示失败原因

<span class="gu">### Step 2: 准备发布</span>
<span class="k">1.</span> 读取文件：`package.json`
<span class="k">2.</span> 更新版本号为 <span class="sb">`1.2.3`</span>
<span class="k">3.</span> 写入文件：`package.json`
<span class="k">4.</span> 读取文件：`CHANGELOG.md`
<span class="k">5.</span> 在顶部插入本次更新内容
<span class="k">6.</span> 写入文件：`CHANGELOG.md`

<span class="gu">### Step 3: 提交与推送</span>
<span class="k">1.</span> 运行终端命令：`git add .`
<span class="k">2.</span> 运行终端命令：`git commit -m &quot;chore: release v1.2.3&quot;`
<span class="k">3.</span> 运行终端命令：`git tag v1.2.3`
<span class="k">4.</span> 运行终端命令：`git push &amp;&amp; git push --tags`

<span class="gu">### Step 4: 创建 GitLab Release</span>
<span class="k">1.</span> 调用 MCP Tool <span class="sb">`submit_merge_request`</span>：
<span class="w">   </span><span class="k">-</span><span class="w"> </span>标题：&quot;Release v1.2.3&quot;
<span class="w">   </span><span class="k">-</span><span class="w"> </span>描述：从 CHANGELOG.md 提取
<span class="k">2.</span> 调用 MCP Tool <span class="sb">`get_merge_request_info`</span> 获取 MR 链接

<span class="gu">### Step 5: 通知团队</span>
<span class="k">1.</span> 调用 MCP Tool（假设有 Slack Tool）：
<span class="w">   </span><span class="k">-</span><span class="w"> </span>发送到 <span class="ni">#releases</span> 频道
<span class="w">   </span><span class="k">-</span><span class="w"> </span>内容：&quot;🚀 v1.2.3 已发布！MR: &lt;链接&gt;&quot;

<span class="gu">### Step 6: 更新 Jira</span>
<span class="k">1.</span> 调用 MCP Tool <span class="sb">`search_jira_issues`</span>：查找 fixVersion=1.2.3 的票据
<span class="k">2.</span> 对每个票据，调用 <span class="sb">`update_jira_issue`</span>：状态改为&quot;已发布&quot;

<span class="gu">## 完成</span>
输出：&quot;✅ v1.2.3 发布完成！&quot;
</code></pre></div>

<p><strong>这个 Prompt 做了什么？</strong></p>
<ol>
<li>执行了 <strong>7 条终端命令</strong></li>
<li>读写了 <strong>2 个文件</strong></li>
<li>调用了 <strong>4 个 MCP Tools</strong>（GitLab、Slack、Jira）</li>
<li>实现了 <strong>条件分支</strong>（测试失败则停止）</li>
<li>实现了 <strong>循环</strong>（遍历 Jira 票据）</li>
</ol>
<p><strong>这已经是一个完整的 CI/CD 流程了——只不过是用自然语言写的。</strong></p>
<hr>
<h2 id="cursor-rulescommandsmcp">四、Cursor 的三层架构：Rules、Commands、MCP</h2>
<p>Cursor 提供了一套优雅的 Prompt-as-Code 架构：</p>
<div class="highlight"><pre><span></span><code>┌────────────────────────────────────────────────────────────┐
│                   MCP Tools (外部工具)                      │
│     Jira / GitLab / 文件系统 / 终端 / 浏览器 / API          │
├────────────────────────────────────────────────────────────┤
│                    Commands (指令)                         │
│       /blog-write, /design-doc, /release 等                │
│       定义 Workflow：步骤 + 条件 + 工具调用                  │
├────────────────────────────────────────────────────────────┤
│                      Rules (规则)                          │
│       始终生效的约束：代码风格、人设、安全限制                 │
└────────────────────────────────────────────────────────────┘
</code></pre></div>

<h3 id="41-rules">4.1 Rules：定义"始终生效"的约束</h3>
<p>Rules 是 AI 的"宪法"，存放在 <code>.cursor/rules/</code> 目录下。</p>
<p><strong>示例</strong>：</p>
<div class="highlight"><pre><span></span><code>---
<span class="gu">alwaysApply: true</span>
<span class="gu">---</span>

<span class="gh"># AI 行为约束</span>

<span class="gu">## 安全限制</span>
<span class="k">-</span><span class="w"> </span>永远不要执行 <span class="sb">`rm -rf /`</span> 或类似危险命令
<span class="k">-</span><span class="w"> </span>在执行任何删除操作前，必须先询问用户确认
<span class="k">-</span><span class="w"> </span>不要在 Prompt 中暴露敏感信息（API Key、密码）

<span class="gu">## 代码风格</span>
<span class="k">-</span><span class="w"> </span>使用 TypeScript 严格模式
<span class="k">-</span><span class="w"> </span>所有函数必须有类型注解
<span class="k">-</span><span class="w"> </span>错误处理使用 try/catch，不要静默失败

<span class="gu">## 工具使用偏好</span>
<span class="k">-</span><span class="w"> </span>优先使用 MCP Tools 而不是手动操作
<span class="k">-</span><span class="w"> </span>如果 MCP Tool 失败，回退到终端命令
</code></pre></div>

<h3 id="42-commands-workflow">4.2 Commands：定义"可复用的 Workflow"</h3>
<p>Commands 是"带参数的 Prompt 函数"，存放在 <code>.cursor/commands/</code> 目录下。</p>
<p><strong>关键点</strong>：Command 里可以定义完整的 Workflow，包括步骤、条件、工具调用。</p>
<p><strong>示例</strong>（<code>code-review.md</code>）：</p>
<div class="highlight"><pre><span></span><code>---
name: /code-review
<span class="gu">description: 自动化代码审查流程</span>
<span class="gu">---</span>

<span class="gh"># Code Review 助手</span>

<span class="gu">## 触发</span>
当用户输入 <span class="sb">`/code-review`</span> 或 <span class="sb">`/code-review &lt;file&gt;`</span> 时触发。

<span class="gu">## Workflow</span>

<span class="gu">### Step 1: 确定审查范围</span>
<span class="k">-</span><span class="w"> </span>如果用户指定了文件 → 审查该文件
<span class="k">-</span><span class="w"> </span>如果没有指定 → 运行 <span class="sb">`git diff --name-only HEAD~1`</span> 获取最近修改的文件

<span class="gu">### Step 2: 读取代码</span>
对于每个文件，使用文件系统 Tool 读取内容。

<span class="gu">### Step 3: 审查维度</span>
按以下维度审查每个文件：
<span class="k">1.</span> <span class="gs">**正确性**</span>：逻辑是否正确？边界情况是否处理？
<span class="k">2.</span> <span class="gs">**可读性**</span>：命名是否清晰？结构是否合理？
<span class="k">3.</span> <span class="gs">**性能**</span>：是否有 N+1 查询？是否有不必要的循环？
<span class="k">4.</span> <span class="gs">**安全性**</span>：是否有 SQL 注入、XSS 等风险？

<span class="gu">### Step 4: 输出报告</span>
使用 Markdown 表格输出审查结果：
| 文件 | 问题 | 严重程度 | 建议 |
|------|------|----------|------|
| ...  | ...  | 🔴/🟡/🟢 | ...  |

<span class="gu">### Step 5: 可选：自动修复</span>
如果用户说&quot;帮我修&quot;，则：
<span class="k">1.</span> 读取有问题的文件
<span class="k">2.</span> 应用修复
<span class="k">3.</span> 写入文件
<span class="k">4.</span> 运行 <span class="sb">`npm run lint --fix`</span> 格式化
</code></pre></div>

<h3 id="43">4.3 三者的协作关系</h3>
<table>
<thead>
<tr>
<th>层级</th>
<th>职责</th>
<th>生命周期</th>
<th>类比</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Rules</strong></td>
<td>定义约束和偏好</td>
<td>始终生效</td>
<td><code>.eslintrc</code> / <code>tsconfig.json</code></td>
</tr>
<tr>
<td><strong>Commands</strong></td>
<td>定义 Workflow</td>
<td>按需调用</td>
<td>Shell 脚本 / Makefile</td>
</tr>
<tr>
<td><strong>MCP Tools</strong></td>
<td>执行具体操作</td>
<td>被调用时执行</td>
<td>系统 API / SDK</td>
</tr>
</tbody>
</table>
<p><strong>执行流程</strong>：</p>
<div class="highlight"><pre><span></span><code>用户输入 /design-doc JIRA-12345
        ↓
Cursor 加载 Commands 定义
        ↓
AI 解析 Workflow 步骤
        ↓
Step 1: 调用 MCP Tool (get_jira_issue)
        ↓
Step 2: 读取文件 (project.md)
        ↓
Step 3: 执行终端命令 (git log)
        ↓
Step 4: 生成内容 + 写入文件
        ↓
完成
</code></pre></div>

<hr>
<h2 id="openspec-workflow">五、深入案例：OpenSpec 的 Workflow 编排</h2>
<p>OpenSpec 是一个"规格驱动开发"工具，它的 <code>AGENTS.md</code> 是 Prompt-as-Code 的经典案例。</p>
<h3 id="51-openspec-workflow">5.1 OpenSpec 的三阶段 Workflow</h3>
<div class="highlight"><pre><span></span><code><span class="gu">## Three-Stage Workflow</span>

<span class="gu">### Stage 1: Creating Changes</span>
<span class="gs">**触发条件**</span>：用户要求添加新功能、做破坏性变更、修改架构

<span class="gs">**Workflow**</span>：
<span class="k">1.</span> 运行 <span class="sb">`openspec list`</span> 和 <span class="sb">`openspec list --specs`</span> 了解当前状态
<span class="k">2.</span> 选择唯一的 <span class="sb">`change-id`</span>（kebab-case，动词开头）
<span class="k">3.</span> 创建目录：`openspec/changes/&lt;id&gt;/`
<span class="k">4.</span> 生成文件：`proposal.md`, <span class="sb">`tasks.md`</span>, <span class="sb">`design.md`</span>（可选）
<span class="k">5.</span> 起草 spec 增量：`## ADDED|MODIFIED|REMOVED Requirements`
<span class="k">6.</span> 运行 <span class="sb">`openspec validate &lt;id&gt; --strict`</span> 验证
<span class="k">7.</span> <span class="gs">**停止**</span>：等待人工批准后再继续

<span class="gu">### Stage 2: Implementing Changes</span>
<span class="gs">**触发条件**</span>：proposal 已被批准

<span class="gs">**Workflow**</span>：
<span class="k">1.</span> 读取 <span class="sb">`proposal.md`</span> 了解要做什么
<span class="k">2.</span> 读取 <span class="sb">`design.md`</span>（如果有）了解技术决策
<span class="k">3.</span> 读取 <span class="sb">`tasks.md`</span> 获取实施清单
<span class="k">4.</span> <span class="gs">**按顺序**</span>实施每个任务
<span class="k">5.</span> 每完成一个任务，更新 <span class="sb">`tasks.md`</span> 状态
<span class="k">6.</span> 全部完成后，标记为 <span class="sb">`- [x]`</span>

<span class="gu">### Stage 3: Archiving Changes</span>
<span class="gs">**触发条件**</span>：实施完成，已部署

<span class="gs">**Workflow**</span>：
<span class="k">1.</span> 运行 <span class="sb">`openspec archive &lt;change-id&gt; --yes`</span>
<span class="k">2.</span> 如果是纯工具变更，加 <span class="sb">`--skip-specs`</span>
<span class="k">3.</span> 运行 <span class="sb">`openspec validate --strict`</span> 确认归档成功
</code></pre></div>

<h3 id="52">5.2 决策树：什么情况下走什么流程</h3>
<p>OpenSpec 的 Prompt 中甚至包含了<strong>决策树</strong>：</p>
<div class="highlight"><pre><span></span><code><span class="gu">### Decision Tree</span>

New request?
├─ Bug fix restoring spec behavior? → Fix directly (不需要 proposal)
├─ Typo/format/comment? → Fix directly
├─ New feature/capability? → Create proposal
├─ Breaking change? → Create proposal
├─ Architecture change? → Create proposal
└─ Unclear? → Create proposal (safer)
</code></pre></div>

<p><strong>这就是在 Prompt 中定义"条件分支"</strong>——AI 会根据用户的请求类型，自动选择正确的流程。</p>
<h3 id="53">5.3 工具调用示例</h3>
<p>OpenSpec 的 Prompt 中明确指定了要调用哪些工具：</p>
<div class="highlight"><pre><span></span><code><span class="gu">### CLI Commands</span>

<span class="gh"># Essential commands</span>
openspec list                  # 列出活跃变更
openspec list --specs          # 列出规格
openspec show [item]           # 查看详情
openspec validate [item]       # 验证格式
openspec archive &lt;change-id&gt;   # 归档变更

<span class="gh"># Debugging</span>
openspec show [change] --json --deltas-only
openspec validate [change] --strict
</code></pre></div>

<p>当 AI 执行 OpenSpec Workflow 时，它会<strong>真的运行这些命令</strong>，而不只是"假装"在运行。</p>
<hr>
<h2 id="workflow-command">六、动手实践：写一个带 Workflow 的 Command</h2>
<h3 id="61">6.1 需求：自动化日报生成器</h3>
<p>我们来写一个 <code>/daily-report</code> Command，它的功能是：</p>
<ol>
<li>从 Jira 获取今天完成的任务</li>
<li>从 Git 获取今天的提交记录</li>
<li>生成日报并保存到文件</li>
<li>可选：发送到 Slack</li>
</ol>
<h3 id="62-command">6.2 完整的 Command 定义</h3>
<p>创建 <code>.cursor/commands/daily-report.md</code>：</p>
<div class="highlight"><pre><span></span><code>---
name: /daily-report
<span class="gu">description: 自动生成工作日报</span>
<span class="gu">---</span>

<span class="gh"># 日报生成器</span>

<span class="gu">## 触发条件</span>
用户输入 <span class="sb">`/daily-report`</span> 或 <span class="sb">`/daily-report --send`</span>

<span class="gu">## Workflow</span>

<span class="gu">### Step 1: 收集 Jira 数据</span>
<span class="k">1.</span> 获取当前用户信息：调用 MCP Tool <span class="sb">`get_current_user`</span>
<span class="k">2.</span> 搜索今天完成的任务：
<span class="w">   </span><span class="k">-</span><span class="w"> </span>调用 MCP Tool <span class="sb">`search_jira_issues`</span>
<span class="w">   </span><span class="k">-</span><span class="w"> </span>JQL: <span class="sb">`assignee = currentUser() AND status changed to &quot;Done&quot; after startOfDay()`</span>
<span class="k">3.</span> 如果没有找到任务 → 输出&quot;今天没有完成的 Jira 任务&quot;，但继续流程

<span class="gu">### Step 2: 收集 Git 数据</span>
<span class="k">1.</span> 运行终端命令：`git log --author=&quot;$(git config user.email)&quot; --since=&quot;00:00&quot; --oneline`
<span class="k">2.</span> 解析输出，提取 commit 列表

<span class="gu">### Step 3: 生成日报</span>
按以下格式生成 Markdown：

```markdown
<span class="gh"># 工作日报 - YYYY-MM-DD</span>

<span class="gu">## 今日完成</span>
<span class="gu">### Jira 任务</span>
<span class="k">-</span><span class="w"> </span>[JIRA-123] 任务标题
<span class="k">-</span><span class="w"> </span>[JIRA-456] 任务标题

<span class="gu">### 代码提交</span>
<span class="k">-</span><span class="w"> </span>abc1234: commit message 1
<span class="k">-</span><span class="w"> </span>def5678: commit message 2

<span class="gu">## 明日计划</span>
（留空，等待用户补充）

<span class="gu">## 遇到的问题</span>
（留空，等待用户补充）
</code></pre></div>

<h3 id="step-4">Step 4: 保存文件</h3>
<ol>
<li>创建目录：<code>docs/daily-reports/</code>（如果不存在）</li>
<li>写入文件：<code>docs/daily-reports/YYYY-MM-DD.md</code></li>
</ol>
<h3 id="step-5">Step 5: 可选发送</h3>
<p>如果用户加了 <code>--send</code> 参数：
1. 读取刚才生成的日报
2. 调用 Slack MCP Tool（如果有）发送到指定频道
3. 如果没有 Slack Tool → 输出"日报已保存，但无法发送（未配置 Slack）"</p>
<h3 id="step-6">Step 6: 完成</h3>
<p>输出："✅ 日报已生成：docs/daily-reports/YYYY-MM-DD.md"</p>
<div class="highlight"><pre><span></span><code>### 6.3 这个 Command 用到了什么？

| 能力 | 具体实现 |
|------|----------|
| **MCP Tool 调用** | `get_current_user`, `search_jira_issues`, Slack |
| **终端命令执行** | `git log --author=...` |
| **文件读写** | 创建目录、写入 Markdown 文件 |
| **条件分支** | `--send` 参数判断、无任务时的处理 |
| **模板生成** | 按固定格式生成日报内容 |

---

## 七、常见误区与最佳实践

### 误区 1：Workflow 步骤太细

❌ 错误：
```markdown
1. 打开终端
2. 输入 git
3. 输入空格
4. 输入 status
5. 按回车
</code></pre></div>

<p>✅ 正确：</p>
<div class="highlight"><pre><span></span><code><span class="k">1.</span> 运行 <span class="sb">`git status`</span> 检查工作区状态
</code></pre></div>

<p><strong>原则</strong>：Workflow 步骤应该是<strong>语义级别</strong>的，不是<strong>操作级别</strong>的。</p>
<h3 id="2">误区 2：没有错误处理</h3>
<p>❌ 错误：</p>
<div class="highlight"><pre><span></span><code><span class="k">1.</span> 运行 <span class="sb">`npm run build`</span>
<span class="k">2.</span> 运行 <span class="sb">`npm run deploy`</span>
</code></pre></div>

<p>✅ 正确：</p>
<div class="highlight"><pre><span></span><code><span class="k">1.</span> 运行 <span class="sb">`npm run build`</span>
<span class="w">   </span><span class="k">-</span><span class="w"> </span>如果失败 → <span class="gs">**停止**</span>，输出错误信息
<span class="k">2.</span> 运行 <span class="sb">`npm run deploy`</span>
<span class="w">   </span><span class="k">-</span><span class="w"> </span>如果失败 → <span class="gs">**回滚**</span>，运行 <span class="sb">`git reset --hard HEAD~1`</span>
</code></pre></div>

<h3 id="3-mcp-tools">误区 3：过度依赖 MCP Tools</h3>
<p>并不是所有操作都需要 MCP Tool。简单的文本处理、格式转换，AI 自己就能做。</p>
<p><strong>MCP Tool 适合</strong>：需要<strong>副作用</strong>的操作（写文件、调 API、执行命令）</p>
<p><strong>AI 自己做</strong>：纯计算、推理、文本生成</p>
<h3 id="_1">最佳实践清单</h3>
<table>
<thead>
<tr>
<th>实践</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>步骤语义化</strong></td>
<td>每一步做一件"有意义的事"，不是一个"动作"</td>
</tr>
<tr>
<td><strong>显式错误处理</strong></td>
<td>每个可能失败的步骤都要说明"失败了怎么办"</td>
</tr>
<tr>
<td><strong>人工确认点</strong></td>
<td>危险操作前加"等待用户确认"</td>
</tr>
<tr>
<td><strong>幂等性</strong></td>
<td>同一个 Workflow 跑两遍，结果应该一样</td>
</tr>
<tr>
<td><strong>可观测性</strong></td>
<td>每一步都输出状态，让用户知道"到哪了"</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="_2">总结</h2>
<table>
<thead>
<tr>
<th>核心概念</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Prompt-as-Code</strong></td>
<td>Prompt = 可管理 + <strong>可执行</strong> 的程序</td>
</tr>
<tr>
<td><strong>Workflow</strong></td>
<td>在 Prompt 中定义多步骤、有条件、可循环的流程</td>
</tr>
<tr>
<td><strong>MCP Tools</strong></td>
<td>让 Prompt 可以调用外部工具（Jira、GitLab、终端、文件系统）</td>
</tr>
<tr>
<td><strong>Rules</strong></td>
<td>始终生效的约束（安全、风格、偏好）</td>
</tr>
<tr>
<td><strong>Commands</strong></td>
<td>可复用的 Workflow 模板</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="checklist-prompt">Checklist：升级你的 Prompt 为"可执行程序"</h2>
<ul>
<li>[ ] 把常用流程写成 Command，定义清晰的 Workflow 步骤</li>
<li>[ ] 在 Workflow 中显式调用 MCP Tools（而不是"假装"在调用）</li>
<li>[ ] 为每个可能失败的步骤添加错误处理</li>
<li>[ ] 在危险操作前加入"等待用户确认"</li>
<li>[ ] 测试 Workflow 的幂等性（跑两遍结果一样）</li>
<li>[ ] 把 Rules、Commands 加入 Git 版本控制</li>
</ul>
<hr>
<h2 id="_3">这一篇你真正要记住的只有一句话</h2>
<blockquote>
<p><strong>Prompt 不只是"和 AI 聊天"，而是用自然语言写的"可执行程序"。</strong></p>
</blockquote>
<p>当你开始在 Prompt 里定义 Workflow、调用 Tools、处理错误，你就已经在<strong>用自然语言编程</strong>了。</p>
<hr>
<h2 id="_4">扩展阅读</h2>
<ul>
<li><a href="https://docs.cursor.com/context/rules-for-ai">Cursor Documentation: Rules</a> — Cursor 官方 Rules 文档</li>
<li><a href="https://modelcontextprotocol.io/">Model Context Protocol (MCP)</a> — Anthropic 的 MCP 协议官方文档</li>
<li><a href="https://github.com/jpoehnelt/openspec">OpenSpec GitHub</a> — 规格驱动开发工具</li>
<li><a href="https://agentskills.io/specification">Agent Skills Specification</a> — AI Agent 技能定义规范</li>
</ul>
<hr>
<div class="highlight"><pre><span></span><code>@startmindmap
* Prompt as Code
** 两层含义
*** 管理 Prompt
*** 执行 Prompt
** Workflow 定义
*** 触发条件
*** 步骤序列
*** 条件分支
*** 工具调用
** MCP 工具
*** Model Context Protocol
*** 外部工具集成
*** 参数传递
** Cursor 架构
*** Rules 规则
*** Commands 命令
*** MCP Tools 工具
@endmindmap
</code></pre></div>

<p><img alt="Prompt as Code 思维导图" src="../images/journal_20260120_prompt_as_code_mindmap.png"></p>
<hr/>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="./tag/ai.html">AI</a>
      <a href="./tag/prompt-engineering.html">Prompt Engineering</a>
      <a href="./tag/cursor.html">Cursor</a>
      <a href="./tag/mcp.html">MCP</a>
      <a href="./tag/openspec.html">OpenSpec</a>
      <a href="./tag/workflow.html">Workflow</a>
    </p>
  </div>


  <div class="neighbors">
    <a class="btn float-left" href="./zhi-chang-gong-ju-xiang-zhi-huang-jin-quan-fa-ze-bu-shi-ni-bu-xing-shi-ni-hui-bao-fang-shi-cuo-liao.html" title="职场工具箱之黄金圈法则: 不是你不行，是你汇报方式错了">
      <i class="fa fa-angle-left"></i> Previous Post
    </a>
    <a class="btn float-right" href="./zhi-chang-gong-ju-xiang-zhi-tnb-biao-da-mo-xing.html" title="职场工具箱之 TNB 表达模型">
      Next Post <i class="fa fa-angle-right"></i>
    </a>
  </div>

  <div class="related-posts">
    <h4>You might enjoy</h4>
    <ul class="related-posts">
      <li><a href="./agent-skillsgei-ai-zhu-shou-zhuang-shang-ji-neng-bao.html">Agent Skills：给 AI 助手装上"技能包"</a></li>
      <li><a href="./vibe-bian-cheng-de-xin-fan-shi-zai-ai-shi-dai-zhong-xin-ding-yi-ruan-jian-kai-fa.html">Vibe 编程的新范式：在 AI 时代重新定义软件开发</a></li>
      <li><a href="./tips-for-vibe-coding-with-cursor-bie-rang-ai-cai-ni-de-xin-si.html">Tips for Vibe Coding with Cursor: 别让 AI 猜你的心思</a></li>
      <li><a href="./cursor-de-san-ban-fu-rules-commands-yu-agent-skills.html">Cursor 的三板斧：Rules, Commands 与 Agent Skills</a></li>
      <li><a href="./ai-fu-zhu-bian-cheng-de-san-da-hu-fa-ke-yan-zheng-xing-ke-guan-ce-xing-ke-li-jie-xing.html">AI 辅助编程的三大护法：可验证性、可观测性、可理解性</a></li>
    </ul>
  </div>



<!-- Disqus -->
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'wfblog';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>
    Please enable JavaScript to view comments.
</noscript>
<!-- End Disqus -->
</article>

<footer>
<p>&copy; 2010 ~ 2030  Walter Fan <a href="https://beian.miit.gov.cn" target="_blank">皖ICP备20001876号-1</a></p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
</p><!-- StatusCake -->

<!-- End StatusCake --></footer>  </main>

<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Walter Fan's Blog ",
  "url" : ".",
  "image": "./images/walterfan.jpg",
  "description": "an old programmer never die, he just branch to a new address."
}
</script>
</body>
</html>