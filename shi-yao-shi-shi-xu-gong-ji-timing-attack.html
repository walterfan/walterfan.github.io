
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="./theme/stylesheet/style.min.css">


    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
          href="./theme/pygments/github.min.css">



  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/solid.css">


  <link rel="shortcut icon" href="./images/favicon.ico" type="image/x-icon">
  <link rel="icon" href="./images/favicon.ico" type="image/x-icon">










 

<meta name="author" content="Walter Fan" />
<meta name="description" content="用 == 或 strings.Compare 比较密钥、密码或 HMAC 时，比较时间会随「猜对多少」变化，攻击者可以按响应时间逐字节猜出秘密；一文说清原理与常数时间比较的用法。" />
<meta name="keywords" content="security, timing-attack, constant-time, authentication, crypto">


  <meta property="og:site_name" content="Walter Fan's Blog"/>
  <meta property="og:title" content="什么是时序攻击（Timing Attack）？"/>
  <meta property="og:description" content="用 == 或 strings.Compare 比较密钥、密码或 HMAC 时，比较时间会随「猜对多少」变化，攻击者可以按响应时间逐字节猜出秘密；一文说清原理与常数时间比较的用法。"/>
  <meta property="og:locale" content="en_US"/>
  <meta property="og:url" content="./shi-yao-shi-shi-xu-gong-ji-timing-attack.html"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="2026-02-12 12:30:00+08:00"/>
  <meta property="article:modified_time" content="2026-02-12 12:30:00+08:00"/>
  <meta property="article:author" content="./author/walter-fan.html">
  <meta property="article:section" content="Journal"/>
  <meta property="article:tag" content="security"/>
  <meta property="article:tag" content="timing-attack"/>
  <meta property="article:tag" content="constant-time"/>
  <meta property="article:tag" content="authentication"/>
  <meta property="article:tag" content="crypto"/>
  <meta property="og:image" content="./images/walterfan.jpg">

  <title>Walter Fan's Blog &ndash; 什么是时序攻击（Timing Attack）？</title>


</head>
<body class="light-theme">

<aside>
  <div>
    <a href="./">
      <img src="./images/walterfan.jpg" alt="Walter Fan" title="Walter Fan">
    </a>

    <h1>
      <a href="./">Walter Fan</a>
    </h1>

    <p>手握灵珠常奋笔, 心开天籁不吹箫</p>


    <nav>
      <ul class="list">



          <li>
            <a target="_blank" href="tao.html" >tao</a>
          </li>
          <li>
            <a target="_blank" href="article.html" >article</a>
          </li>
          <li>
            <a target="_blank" href="manual.html" >manual</a>
          </li>
          <li>
            <a target="_blank" href="interest.html" >interest</a>
          </li>
          <li>
            <a target="_self" href="/wordpress" >notebook</a>
          </li>
          <li>
            <a target="_blank" href="bookmark.html" >bookmark</a>
          </li>
          <li>
            <a target="_self" href="/webrtc/examples/index.html" >webrtc</a>
          </li>
          <li>
            <a target="_blank" href="https://github.com/walterfan" >github</a>
          </li>
      </ul>
    </nav>

    <ul class="social">
      <li>
        <a class="sc-github"
           href="http://github.com/walterfan"
           target="_blank">
          <i class="fa-brands fa-github"></i>
        </a>
      </li>
    </ul>
  </div>

</aside>
  <main>


<article class="single">
  <header>
      
    <h1 id="shi-yao-shi-shi-xu-gong-ji-timing-attack">什么是时序攻击（Timing Attack）？</h1>
    <p>
      Posted on Thu 12 February 2026 in <a href="./category/journal.html">Journal</a>

    </p>
  </header>


  <div>
    <table>
<thead>
<tr>
<th><strong>Abstract</strong></th>
<th>什么是时序攻击（Timing Attack）？</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Authors</strong></td>
<td><a href="https://www.fanyamin.com">Walter Fan</a></td>
</tr>
<tr>
<td><strong>Category</strong></td>
<td>Journal</td>
</tr>
<tr>
<td><strong>Version</strong></td>
<td>v1.0</td>
</tr>
<tr>
<td><strong>Updated</strong></td>
<td>2026-02-12</td>
</tr>
<tr>
<td><strong>License</strong></td>
<td><a href="http://creativecommons.org/licenses/by-nc-nd/4.0">CC-BY-NC-ND 4.0</a></td>
</tr>
</tbody>
</table>
<h2 id="_1">短大纲</h2>
<ul>
<li>用「每次请求多几微秒就被利用」的小场景开场，点出：比较秘密时，<strong>时间会泄密</strong></li>
<li>时序攻击是什么：攻击者通过测量比较耗时，推断秘密内容</li>
<li>为什么简单比较容易泄密：<code>==</code> / <code>strings.Compare</code> 等会「第一个字节不对就返回」，时间差可被统计区分</li>
<li>举例：密码校验、HMAC、API Token 比较</li>
<li>防御：常数时间比较（constant-time comparison），Go/其他语言怎么用</li>
<li>总结 + 思维导图 + 明天就能做 + 适用边界 + 开放式问题</li>
</ul>
<h1 id="2026-02-12">2026-02-12</h1>
<p>有一次安全审计，发现某接口用「用户提交的 token」和「数据库里的 token」直接做 <code>==</code> 比较。功能上没问题，但攻击者不需要拿到内存——<strong>只要反复请求、统计响应时间，就能按「猜对多少」把 token 一个字节一个字节猜出来。</strong> 这类利用「比较耗时」来推断秘密的攻击，就叫 <strong>时序攻击（Timing Attack）</strong>。</p>
<h2 id="_2">时序攻击是什么？</h2>
<p><strong>人话版</strong>：程序在比较两个值（比如密码、HMAC、API Key）时，若「发现第一个不一样就立刻返回」，那么<strong>比较得越久，说明前面猜对的字节越多</strong>。攻击者通过大量请求测响应时间，用统计方法把「哪一字节对了」区分出来，从而逐字节还原秘密。</p>
<p>所以：<strong>比较秘密时，不能「提前返回」——必须把整段比完，且耗时与内容无关，也就是要做「常数时间比较」（constant-time comparison）。</strong></p>
<h2 id="_3">为什么简单比较容易泄密？</h2>
<p>很多语言里的「相等比较」是短路式的：</p>
<ul>
<li><strong>字符串</strong>：<code>==</code>、<code>strings.Compare</code>、<code>strcmp</code> 等，通常是逐字节比，第一个不同就返回。</li>
<li><strong>结果</strong>：猜对前 N 个字节时，比较会多执行 N 次循环，响应时间略长；猜错第一个字节就返回，响应时间更短。</li>
</ul>
<p>攻击者不需要单次精确到纳秒；只要在<strong>同一网络环境下</strong>发大量请求、对每组猜测做<strong>统计</strong>（例如中位数、方差），就能把「这一字节是否猜对」从噪声里区分出来。再对下一个字节重复，就能<strong>逐字节</strong>还原整个秘密。</p>
<h2 id="python">一个小实验：Python 里时间差真的可测</h2>
<p>下面这段代码模拟「校验 token」：<strong>朴素比较</strong>一发现字节不同就返回，<strong>常数时间比较</strong>则始终比完整个长度。用同一批猜测各测很多次，就能看到「猜对第一个字节」时总耗时明显更长——说明单次几微秒的差异，在统计下是可以被利用的。</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">hmac</span>

<span class="n">SECRET</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;admin_token_42&quot;</span>   <span class="c1"># 模拟服务端存的 token</span>

<span class="k">def</span><span class="w"> </span><span class="nf">naive_compare</span><span class="p">(</span><span class="n">guess</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">secret</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;朴素比较：第一个不同就返回，耗时随「猜对多少」变化。&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">guess</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">secret</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">secret</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">guess</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">secret</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">False</span>   <span class="c1"># 提前返回 → 攻击者可通过时间推断这里就错了</span>
    <span class="k">return</span> <span class="kc">True</span>

<span class="k">def</span><span class="w"> </span><span class="nf">constant_time_compare</span><span class="p">(</span><span class="n">guess</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">secret</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;常数时间比较：始终比完，耗时与内容无关。&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">hmac</span><span class="o">.</span><span class="n">compare_digest</span><span class="p">(</span><span class="n">guess</span><span class="p">,</span> <span class="n">secret</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">measure_many</span><span class="p">(</span><span class="n">compare_fn</span><span class="p">,</span> <span class="n">guess</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">rounds</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50000</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;多次比较取总时间（秒），便于放大差异。&quot;&quot;&quot;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rounds</span><span class="p">):</span>
        <span class="n">compare_fn</span><span class="p">(</span><span class="n">guess</span><span class="p">,</span> <span class="n">SECRET</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># 猜错第一个字节：b&quot;x...&quot; vs b&quot;a...&quot;</span>
    <span class="n">wrong_first</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="n">SECRET</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="c1"># 猜对第一个字节：b&quot;a...&quot; vs b&quot;admin...&quot;</span>
    <span class="n">right_first</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;a&quot;</span> <span class="o">+</span> <span class="n">SECRET</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;朴素比较（50000 次）：&quot;</span><span class="p">)</span>
    <span class="n">t_wrong</span> <span class="o">=</span> <span class="n">measure_many</span><span class="p">(</span><span class="n">naive_compare</span><span class="p">,</span> <span class="n">wrong_first</span><span class="p">)</span>
    <span class="n">t_right</span> <span class="o">=</span> <span class="n">measure_many</span><span class="p">(</span><span class="n">naive_compare</span><span class="p">,</span> <span class="n">right_first</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  猜错首字节: </span><span class="si">{</span><span class="n">t_wrong</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  猜对首字节: </span><span class="si">{</span><span class="n">t_right</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">s  ← 明显更慢&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  差异: </span><span class="si">{</span><span class="p">(</span><span class="n">t_right</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t_wrong</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1000</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> ms&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;常数时间比较（50000 次）：&quot;</span><span class="p">)</span>
    <span class="n">t_wrong_safe</span> <span class="o">=</span> <span class="n">measure_many</span><span class="p">(</span><span class="n">constant_time_compare</span><span class="p">,</span> <span class="n">wrong_first</span><span class="p">)</span>
    <span class="n">t_right_safe</span> <span class="o">=</span> <span class="n">measure_many</span><span class="p">(</span><span class="n">constant_time_compare</span><span class="p">,</span> <span class="n">right_first</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  猜错首字节: </span><span class="si">{</span><span class="n">t_wrong_safe</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  猜对首字节: </span><span class="si">{</span><span class="n">t_right_safe</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">s  ← 几乎一样&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  差异: </span><span class="si">{</span><span class="p">(</span><span class="n">t_right_safe</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t_wrong_safe</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1000</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> ms&quot;</span><span class="p">)</span>
</code></pre></div>

<p>本地跑一遍（<code>python timing_demo.py</code>），你会看到：朴素比较下「猜对首字节」比「猜错首字节」多出一截时间（通常几毫秒到几十毫秒，视机器而定），而 <code>hmac.compare_digest</code> 两种猜测的耗时几乎一致。这说明<strong>时间差真实存在，攻击者用大量请求做统计就能逐字节推断</strong>；换成真实 API 和网络延迟，思路相同，只是需要更多请求来压过噪声。</p>
<h2 id="_4">哪些场景要防？</h2>
<p>只要「比较结果」依赖<strong>秘密数据</strong>、且比较方式<strong>依赖内容提前返回</strong>，就存在被时序攻击放大的风险。典型场景：</p>
<ul>
<li><strong>密码 / 口令校验</strong>：用户提交的 hash 与库中存储的 hash 比较。</li>
<li><strong>HMAC / 签名校验</strong>：例如 Webhook 签名、Cookie 签名，用 <code>secret</code> 算出的期望值与请求体比较。</li>
<li><strong>API Token / 会话 ID</strong>：服务端用「请求里的 token」和「库里或缓存里的 token」做字符串相等比较。</li>
</ul>
<p>这些地方一旦用 <code>==</code>、<code>strings.Compare</code>、<code>strcmp</code> 等，就属于「可被时序攻击」的实现。</p>
<h2 id="_5">怎么防：常数时间比较</h2>
<p>思路就一条：<strong>比较耗时与「是否相等」无关，与秘密内容无关</strong>——不提前 return，且每次都对整段做固定次数的操作。</p>
<ul>
<li><strong>Go</strong>：<code>crypto/subtle</code> 里的 <code>subtle.ConstantTimeCompare(a, b []byte) int</code>，只有 0/1 两种结果，且比较过程常数时间。对字符串先转 <code>[]byte</code> 再比，并保证长度一致（长度不一致时也应用常数时间逻辑：例如先比长度，再比内容，或统一先 <code>ConstantTimeCompare</code> 定长部分）。</li>
<li><strong>其他语言</strong>：多数密码学库都提供类似 API（如 Python 的 <code>hmac.compare_digest</code>、OpenSSL 的 <code>CRYPTO_memcmp</code>）。用这些替代手写 <code>==</code> 或 <code>strcmp</code>。</li>
</ul>
<p>注意：<strong>长度本身也不能泄露</strong>。若「正确 token 长度」和「错误 token 长度」返回时间明显不同，攻击者可以先通过时间推断长度，再逐字节猜内容。所以常见做法是：无论对错，都先做一次定长、常数时间的比较（例如和固定长度的占位比，或统一按「较长者」的长度比），再根据结果返回业务上的成功/失败。</p>
<h2 id="_6">一个跨领域的类比</h2>
<p>可以把「朴素比较」想成考试判卷：<strong>看到第一道错题就拍桌子「不及格」</strong>。考生不用看到卷子，只要观察你判卷的时间长短，就能推断「第一道题对没对、第二道题对没对」……直到把答案反推出来。<strong>常数时间比较</strong>相当于：不管对错，都把整张卷子从头到尾看满固定时间，再统一宣布结果——从时间上就推不出具体哪一题对、哪一题错。</p>
<h2 id="_7">总结</h2>
<ul>
<li><strong>时序攻击</strong>：通过测量「比较秘密」的耗时，用统计方法逐字节推断秘密内容。</li>
<li><strong>根因</strong>：用 <code>==</code>、<code>strings.Compare</code> 等会「第一个不同就返回」的比较方式处理密码、HMAC、Token。</li>
<li><strong>防御</strong>：用常数时间比较（如 Go 的 <code>subtle.ConstantTimeCompare</code>），且不泄露长度信息；敏感比较全部走 crypto 库提供的接口。</li>
</ul>
<div class="highlight"><pre><span></span><code>@startmindmap
&lt;style&gt;
mindmapDiagram {
  node { BackgroundColor #F5F5F5; RoundCorner 8; Padding 8; FontSize 14 }
  :depth(0) { BackgroundColor #2C3E50; FontColor white; FontSize 16; FontStyle bold }
  :depth(1) { FontSize 14; FontStyle bold }
  :depth(2) { FontSize 13 }
}
&lt;/style&gt;

* 时序攻击（Timing Attack）
** 是什么
*** 通过测量比较耗时推断秘密
*** 逐字节猜测（统计区分时间差）
** 为何简单比较容易泄密
*** == / strings.Compare 提前返回
*** 猜对越多，比较越久
** 典型场景
*** 密码/Hash 校验
*** HMAC/签名校验
*** API Token 比较
** 防御
*** 常数时间比较（constant-time）
*** Go: crypto/subtle ConstantTimeCompare
*** 不泄露长度
@endmindmap
</code></pre></div>

<p><img alt="时序攻击思维导图" src="../images/journal_20260212_timing-attacks_mindmap.png"></p>
<h2 id="4">明天就能做的 4 件事</h2>
<ol>
<li><strong>搜一遍项目里所有「和密码/HMAC/Token 比较」的代码</strong>（15 分钟）  </li>
<li>
<p>怎么算做得好：列出每一处用的是 <code>==</code>/<code>Compare</code> 还是 <code>ConstantTimeCompare</code>（或等价 API），敏感比较全部走常数时间。</p>
</li>
<li>
<p><strong>把至少一处敏感比较改成常数时间</strong>（10 分钟）  </p>
</li>
<li>
<p>怎么算做得好：Go 用 <code>subtle.ConstantTimeCompare</code>，且长度一致或按「不泄露长度」的方式处理；其他语言用官方推荐的 <code>compare_digest</code>/<code>CRYPTO_memcmp</code> 等。</p>
</li>
<li>
<p><strong>在 code review 清单里加一条</strong>：「涉及密钥/密码/Token 的相等判断是否用了常数时间比较？」  </p>
</li>
<li>
<p>怎么算做得好：新人也能在 MR 里看到这条，且有一两个示例链接。</p>
</li>
<li>
<p><strong>确认「错误时」不因长度不同而明显变快/变慢</strong>（10 分钟）  </p>
</li>
<li>怎么算做得好：对「正确长度错误内容」和「错误长度」的请求，响应时间在统计上无明显差异（或已用定长比较掩盖长度差异）。</li>
</ol>
<h2 id="_8">什么时候必须防、什么时候可以放宽</h2>
<p><strong>必须防的</strong>：对外暴露的登录、API Key 校验、Webhook 签名、会话 Token 校验等，只要比较的是秘密，就应用常数时间比较。<br>
<strong>可以后置的</strong>：纯内网、且已假设攻击者无法大量测时（例如无法发大量请求）的环境，可以列为「后续加固」；但新代码仍建议一开始就用常数时间，成本很低。<br>
<strong>代价与权衡</strong>：常数时间比较会多算几次循环，通常可忽略；换来的是不把「比较时间」变成信息泄露通道。</p>
<p>最后一个问题留给你：你们当前代码库里，还有没有用 <code>==</code> 或 <code>strings.Compare</code> 比较密码、HMAC 或 Token 的地方？如果有，你打算先改哪一处、用哪一门语言的哪种 API？</p>
<h2 id="_9">扩展阅读</h2>
<ul>
<li>Go: <a href="https://pkg.go.dev/crypto/subtle#ConstantTimeCompare">crypto/subtle — ConstantTimeCompare</a></li>
<li><a href="https://cwe.mitre.org/data/definitions/208.html">Timing attacks on key confirmation (CWE-208)</a></li>
<li><a href="https://docs.python.org/3/library/hmac.html#hmac.compare_digest">Python: hmac.compare_digest</a></li>
</ul>
<hr/>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="./tag/security.html">security</a>
      <a href="./tag/timing-attack.html">timing-attack</a>
      <a href="./tag/constant-time.html">constant-time</a>
      <a href="./tag/authentication.html">authentication</a>
      <a href="./tag/crypto.html">crypto</a>
    </p>
  </div>


  <div class="neighbors">
    <a class="btn float-left" href="./wei-fu-wu-de-san-da-an-quan-wei-xie.html" title="微服务的三大安全威胁">
      <i class="fa fa-angle-left"></i> Previous Post
    </a>
    <a class="btn float-right" href="./ai-shi-dai-wo-wei-shi-yao-huan-yao-xie-zuo.html" title="AI 时代，我为什么还要写作">
      Next Post <i class="fa fa-angle-right"></i>
    </a>
  </div>

  <div class="related-posts">
    <h4>You might enjoy</h4>
    <ul class="related-posts">
      <li><a href="./go-cryptotls-configclone-session-resumption-pitfalls-cve-2025-68121.html">Go crypto/tls Config.Clone session resumption pitfalls (CVE-2025-68121)</a></li>
      <li><a href="./wei-fu-wu-de-san-da-an-quan-wei-xie.html">微服务的三大安全威胁</a></li>
      <li><a href="./zai-eks-shang-gei-pod-bang-iam-roleirsaserviceaccount-oidcdao-di-zen-yao-hui-shi.html">在 EKS 上给 Pod 绑 IAM Role：IRSA（ServiceAccount + OIDC）到底怎么回事</a></li>
      <li><a href="./mi-ma-cun-chu-de-yi-zhu.html">密码存储的艺术</a></li>
      <li><a href="./go-wei-fu-wu-fang-wen-kong-zhi-zhi-casbin-shi-jian-zhi-nan.html">Go 微服务访问控制之 Casbin 实践指南</a></li>
    </ul>
  </div>



<!-- Disqus -->
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'wfblog';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>
    Please enable JavaScript to view comments.
</noscript>
<!-- End Disqus -->
</article>

<footer>
<p>&copy; 2010 ~ 2030  Walter Fan <a href="https://beian.miit.gov.cn" target="_blank">皖ICP备20001876号-1</a></p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
</p><!-- StatusCake -->

<!-- End StatusCake --></footer>  </main>

<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Walter Fan's Blog ",
  "url" : ".",
  "image": "./images/walterfan.jpg",
  "description": "an old programmer never die, he just branch to a new address."
}
</script>
</body>
</html>