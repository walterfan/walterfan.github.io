
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="./theme/stylesheet/style.min.css">


    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
          href="./theme/pygments/github.min.css">



  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/solid.css">


  <link rel="shortcut icon" href="./images/favicon.ico" type="image/x-icon">
  <link rel="icon" href="./images/favicon.ico" type="image/x-icon">










 

<meta name="author" content="Walter Fan" />
<meta name="description" content="用第一性原理做架构设计：从“本质需求”推导到“可演进系统”" />
<meta name="keywords" content="journal, blog, architecture, design, first-principles">


  <meta property="og:site_name" content="Walter Fan's Blog"/>
  <meta property="og:title" content="使用第一性原理做架构设计"/>
  <meta property="og:description" content="用第一性原理做架构设计：从“本质需求”推导到“可演进系统”"/>
  <meta property="og:locale" content="en_US"/>
  <meta property="og:url" content="./shi-yong-di-yi-xing-yuan-li-zuo-jia-gou-she-ji.html"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="2026-01-13 20:20:00+08:00"/>
  <meta property="article:modified_time" content="2026-01-13 22:30:00+08:00"/>
  <meta property="article:author" content="./author/walter-fan.html">
  <meta property="article:section" content="Journal"/>
  <meta property="article:tag" content="journal"/>
  <meta property="article:tag" content="blog"/>
  <meta property="article:tag" content="architecture"/>
  <meta property="article:tag" content="design"/>
  <meta property="article:tag" content="first-principles"/>
  <meta property="og:image" content="./images/walterfan.jpg">

  <title>Walter Fan's Blog &ndash; 使用第一性原理做架构设计</title>


</head>
<body class="light-theme">

<aside>
  <div>
    <a href="./">
      <img src="./images/walterfan.jpg" alt="Walter Fan" title="Walter Fan">
    </a>

    <h1>
      <a href="./">Walter Fan</a>
    </h1>

    <p>手握灵珠常奋笔, 心开天籁不吹箫</p>


    <nav>
      <ul class="list">



          <li>
            <a target="_self" href="tao.html" >tao</a>
          </li>
          <li>
            <a target="_self" href="interest.html" >interest</a>
          </li>
          <li>
            <a target="_self" href="/wordpress" >notebook</a>
          </li>
          <li>
            <a target="_self" href="bookmark.html" >bookmark</a>
          </li>
          <li>
            <a target="_self" href="/webrtc/examples/index.html" >webrtc</a>
          </li>
          <li>
            <a target="_self" href="https://github.com/walterfan" >github</a>
          </li>
          <li>
            <a target="_self" href="https://www.jianshu.com/u/e0b365801f48" >技术文章</a>
          </li>
      </ul>
    </nav>

    <ul class="social">
      <li>
        <a class="sc-github"
           href="http://github.com/walterfan"
           target="_blank">
          <i class="fa-brands fa-github"></i>
        </a>
      </li>
    </ul>
  </div>

</aside>
  <main>


<article class="single">
  <header>
      
    <h1 id="shi-yong-di-yi-xing-yuan-li-zuo-jia-gou-she-ji">使用第一性原理做架构设计</h1>
    <p>
      Posted on Tue 13 January 2026 in <a href="./category/journal.html">Journal</a>

    </p>
  </header>


  <div>
    <table>
<thead>
<tr>
<th><strong>Abstract</strong></th>
<th>使用第一性原理做架构设计</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Authors</strong></td>
<td><a href="https://www.fanyamin.com">Walter Fan</a></td>
</tr>
<tr>
<td><strong>Category</strong></td>
<td>learning note</td>
</tr>
<tr>
<td><strong>Status</strong></td>
<td>v1.0</td>
</tr>
<tr>
<td><strong>Updated</strong></td>
<td>2026-01-13</td>
</tr>
<tr>
<td><strong>License</strong></td>
<td><a href="http://creativecommons.org/licenses/by-nc-nd/4.0">CC-BY-NC-ND 4.0</a></td>
</tr>
</tbody>
</table>
<p>你有没有这种“架构既视感”——哦不，应该叫“时空穿越感”：<br>
开会时大家讨论得热火朝天，最后落地成一句话：<strong>“我们先上 Kubernetes + 微服务 + MQ + Redis + ES，后面再优化。”</strong><br>
听起来很像“先把厨房装修成米其林后厨，再学做蛋炒饭”。问题是：蛋炒饭到底要不要这么复杂？</p>
<p>第一性原理（First Principles）不是用来装腔作势的，它的实用价值只有一句：<br>
<strong>把“习惯/经验/潮流”从决策里请出去，让“目标/约束/不变量”坐到主位。</strong></p>
<hr>
<h2 id="tldr">TL;DR（先把结论给你）</h2>
<h3 id="5">第一性原理做架构，其实就 5 步</h3>
<ul>
<li><strong>Step 1：把问题拆到“物理层”</strong>：用户到底要什么？系统必须保证什么？（先别急着选技术栈）</li>
<li><strong>Step 2：写出 3 个“不变量”</strong>：无论怎么演进，都不能破的底线（安全、合规、一致性、可用性……）</li>
<li><strong>Step 3：列清 5 个“硬约束”</strong>：钱、时间、人、合规、上下游（别拿 PPT 对抗现实）</li>
<li><strong>Step 4：从不变量推导结构</strong>：把职责分出来，把边界画出来，把失败路径想清楚</li>
<li><strong>Step 5：做“可解释的取舍”</strong>：你牺牲了什么、换来了什么、未来怎么回滚/怎么演进</li>
</ul>
<h3 id="_1">评审会自查清单（收藏版）</h3>
<ul>
<li><strong>目标是否可量化</strong>：SLO/延迟/成本上限有没有数字？还是“要快、要稳、要省”这种玄学</li>
<li><strong>边界是否清楚</strong>：哪些属于同一事务/同一一致性域？哪些是“最终一致即可”</li>
<li><strong>失败路径是否设计</strong>：超时、重试、降级、限流、熔断、隔离、回滚有没有写</li>
<li><strong>可观测性是否内建</strong>：日志/指标/追踪/成本与配额是不是一等公民</li>
<li><strong>演进路线是否明确</strong>：MVP 怎么活下去？后续如何拆/如何扩/如何迁移</li>
</ul>
<h2 id="0">0. 先把两个词讲清楚：第一性原理是什么？架构设计是什么？</h2>
<p>我见过不少“架构讨论会”，开场 10 分钟就开始互扔名词：微服务、DDD、K8s、Service Mesh、CQRS……<br>
听着像在点奶茶：<strong>“全糖 + 去冰 + 加珍珠 + 加椰果 + 加布丁 + 再来一份集群。”</strong><br>
但架构设计这件事，最怕的不是你不会点单，而是你压根没问：<strong>你到底渴不渴？</strong></p>
<h3 id="01-first-principles">0.1 什么是第一性原理（First Principles）？</h3>
<p>一句话版：<strong>把“别人这么干”暂时放一边，从目标、约束、和不变量出发，自己推导答案。</strong></p>
<p>工程里它更像一种“反射动作”：
- 遇到新需求，先问：<strong>用户真正的痛点是什么？</strong>
- 遇到架构争论，先问：<strong>我们到底在优化哪个指标？</strong>
- 遇到技术选型，先问：<strong>不选它会死吗？选它会不会把未来锁死？</strong></p>
<p>你会发现，很多“架构讨论”其实是“词汇量竞赛”。第一性原理负责把竞赛掐掉，让大家回到同一个起跑线：事实、约束、推导。</p>
<p>它的反面也不是“经验”，而是<strong>未经检验的类比</strong>：<br>
别人这么做、业内这么做、某大厂这么做——于是我们也这么做。</p>
<p>把它落到纸面上，就是三件事：
- <strong>目标（Goal）</strong>：到底要优化什么？延迟、吞吐、可用性、成本、交付速度？
- <strong>约束（Constraints）</strong>：钱、人、时间、合规、上下游（别拿 PPT 对抗现实）
- <strong>不变量（Invariants）</strong>：无论怎么演进都不能破的底线（钱不能错、数据不能丢、权限不能绕过……）</p>
<h3 id="02-architecture-design">0.2 什么是架构设计（Architecture Design）？</h3>
<p>一句话版：<strong>为了达成目标、在约束下守住不变量，你做的一组“关键决策”。</strong></p>
<p>注意这句话里最重要的不是“架构”，而是“关键决策”。架构设计通常包含：
- <strong>系统边界</strong>：哪些必须强一致？哪些可以最终一致？
- <strong>职责拆分</strong>：模块/服务怎么分？接口契约是什么？
- <strong>数据归属</strong>：谁写谁读？如何同步？如何对账？
- <strong>部署与隔离</strong>：爆炸半径怎么控？热点怎么扩？依赖怎么隔离？
- <strong>失败策略</strong>：超时、重试、降级、限流、熔断、幂等、补偿怎么做？
- <strong>可观测性</strong>：日志/指标/追踪/审计/成本是否一等公民？</p>
<p>换句话说：<strong>架构设计不是“选择技术栈”，而是“决定系统如何活下去”。</strong></p>
<hr>
<h2 id="1">1. 架构设计里最常见的“伪问题”</h2>
<h3 id="11">1.1 “我们要不要微服务？”</h3>
<p>这是个典型伪问题。真正的问题是：
- <strong>你要不要独立发布？</strong>（组织结构与交付节奏）
- <strong>你要不要隔离故障？</strong>（爆炸半径）
- <strong>你要不要独立扩缩容？</strong>（成本与热点）</p>
<p>微服务只是其中一种答案，且代价很硬：治理、调用链、灰度、版本兼容、分布式一致性……你要么为它付钱，要么让事故替你付钱。</p>
<h3 id="12-mq">1.2 “我们要不要上 MQ？”</h3>
<p>更本质的问题通常是：
- 你是不是需要<strong>削峰填谷</strong>？
- 你是不是需要<strong>异步化</strong>来换延迟/吞吐？
- 你是不是要<strong>解耦发布</strong>（生产者/消费者独立演进）？</p>
<p>如果你的真实需求只是“把慢操作放后台”，一个任务队列就够了；你上了全家桶，只是把“慢”升级成了“慢且难排查”。</p>
<hr>
<h2 id="2">2. 第一性原理的“架构推导模板”（可直接抄）</h2>
<p>下面这套我很爱用，像写作文提纲一样，能把“散装观点”变成“可评审的结论”。</p>
<h3 id="21-who-whenwhere">2.1 读者画像（Who）+ 场景（When/Where）</h3>
<p>用 2-3 句话说清楚：
- 谁在什么场景下用？频率多高？峰值多高？
- 失败的代价是什么？（钱/声誉/合规/体验）</p>
<h3 id="22-goal">2.2 目标（Goal）——写成可以打分的</h3>
<p>建议至少列：
- <strong>SLO</strong>：可用性、P95/P99 延迟、吞吐
- <strong>成本上限</strong>：月度预算/单请求成本上限
- <strong>交付窗口</strong>：MVP 什么时候必须上线</p>
<p>例如（随便写个“能打分”的版本）：
- 可用性 ( \ge 99.9\% )
- P95 延迟 ( \le 200ms )（核心接口）
- 日活 10 万，峰值 2k QPS
- 3 周内交付 MVP</p>
<h3 id="23-invariants">2.3 不变量（Invariants）——架构的“地心引力”</h3>
<p>我通常会要求团队写出至少 3 条（少了说明没想明白）：
- <strong>合规不变量</strong>：PII/权限/审计不可绕过
- <strong>一致性不变量</strong>：哪些数据必须强一致？一致性的边界在哪？
- <strong>可用性不变量</strong>：哪些能力必须在部分依赖挂掉时仍可用（降级）</p>
<h3 id="24-constraints">2.4 约束（Constraints）——把现实写在纸面上</h3>
<p>典型 5 类：
- <strong>人</strong>：团队规模/技能栈（“我们只有 2 个后端”这句话非常重要）
- <strong>钱</strong>：预算与资源
- <strong>时间</strong>：上线窗口
- <strong>环境</strong>：机房/云、网络边界、依赖系统
- <strong>组织</strong>：跨团队协作成本、审批流程</p>
<h3 id="25-derivation">2.5 推导（Derivation）——从不变量推出结构，而不是从技术推出结构</h3>
<p>这一步是核心：<br>
<strong>边界 = 不变量的边界</strong>。<br>
例如：强一致的部分放在同一事务域；最终一致的部分允许异步化。</p>
<p>你可以用这张“架构推导表”做评审材料：</p>
<div class="highlight"><pre><span></span><code>不变量/约束  -&gt; 设计选择  -&gt; 代价/风险  -&gt; 缓解手段
---------------------------------------------------
隐私合规必须可审计 -&gt; 统一鉴权与审计层 -&gt; 增加链路开销 -&gt; 异步落审计+采样
核心数据强一致 -&gt; 单写主库+事务边界 -&gt; 扩展性受限 -&gt; 读写分离/分库分表路线图
3周交付MVP -&gt; 先单体模块化 -&gt; 未来拆分成本 -&gt; 明确模块边界+接口契约
</code></pre></div>

<hr>
<h2 id="3-saas-sdkclient-version">3. 一个更贴近 SaaS 的案例：SDK/Client Version 治理（别让旧版本把你拖进“维护地狱”）</h2>
<p>如果你做的是 SaaS 服务，而且对外提供各种 SDK/Client（Web、iOS、Android、Desktop、Server SDK……），你大概率见过这种“人间真实”：
- 你发布了新能力，文档写得像诗，但线上报错像雨：<strong>“为啥只有某些客户一直 4xx/5xx？”</strong>
- 你修了一个安全漏洞，公告发了三轮，结果发现：<strong>漏洞还在，因为一堆客户端根本没升级</strong>
- 你想下线一个废弃接口，会议开完一圈，最后结论是：<strong>“先别动，怕炸。”</strong>（翻译：继续背锅）</p>
<p>这就是典型的“版本治理失败”。而版本治理这种问题，特别适合用第一性原理：<br>
因为它不是技术难，而是<strong>系统性约束 + 组织现实</strong>叠加出来的。</p>
<h3 id="31">3.1 先把场景写清楚：你治理的不是版本号，是“真实世界的惯性”</h3>
<ul>
<li>你是 SaaS：多租户、长尾客户、集成方式五花八门</li>
<li>客户端形态多：Browser、Mobile、Desktop、Server-to-Server</li>
<li>升级阻力大：客户的发布节奏、审批流程、灰度策略、甚至“负责人离职了”</li>
</ul>
<p>真正的问题不是“版本太多”，而是：
- <strong>你无法知道谁在用什么版本</strong>
- <strong>你无法控制谁必须升级</strong>
- <strong>你无法在不炸客户的前提下演进协议与能力</strong></p>
<h3 id="32-goalinvariants">3.2 目标（Goal）与不变量（Invariants）</h3>
<p>先把“地心引力”写出来，后面才推得动。</p>
<p><strong>目标（可打分）</strong>（示例）：
- 版本可见：任意一次请求，都能知道 <code>client_type / sdk_version / capability_set / tenant</code>
- 风险可控：支持“按租户/按版本”灰度、降级、封禁、强制升级
- 演进可持续：能在 6-12 个月内完成一次大版本演进，而不是永远兼容到宇宙尽头
- 成本可控：兼容层的复杂度可度量、可逐步削减（而不是越修越像意大利面）</p>
<p><strong>不变量（底线）</strong>（建议至少 3 条）：
- <strong>安全不变量</strong>：高危漏洞版本必须可快速阻断（Kill Switch），不能靠“发公告求升级”
- <strong>合规/审计不变量</strong>：版本治理动作必须可审计（谁对哪个租户做了什么策略）
- <strong>兼容性不变量</strong>：服务端永远要“说人话”——对不支持的能力给出明确错误码与升级指引，而不是让客户猜</p>
<h3 id="33-constraints-90">3.3 约束（Constraints）：这事 90% 不是技术问题，是现实问题</h3>
<ul>
<li>客户升级不可控：你不能指望客户“马上升级”，尤其是企业客户</li>
<li>SDK 发布渠道不同：App Store、企业内部分发、浏览器缓存、包管理器……</li>
<li>多语言/多平台：你做不了“一刀切”，但你可以做“统一策略”</li>
<li>研发资源有限：治理必须先做“最小闭环”，别一上来就搞成平台化大工程</li>
</ul>
<h3 id="34">3.4 从不变量推导边界：协议/能力/版本，谁才是“真相”？</h3>
<p>这里有一个关键认知：<strong>版本号不等于能力</strong>。</p>
<p>同一个 <code>sdk_version=1.2.3</code>，可能因为：
- 产物被二次打包
- Feature Flag 默认值不同
- 部分能力需要额外配置
导致“看起来同版本，实际行为不一样”。</p>
<p>所以治理的“真相”应该是：
- <strong>版本（Version）</strong>：用于粗粒度分组与发布
- <strong>能力集（Capabilities）</strong>：用于精确决策（支持哪些 API/字段/编解码/鉴权方式）
- <strong>策略（Policy）</strong>：用于控制与治理（允许/警告/降级/封禁/强制升级）</p>
<h3 id="35-sdkclient-version">3.5 推导结构：一套可落地的 SDK/Client Version 治理架构</h3>
<p>下面这个结构不花哨，但很能打，核心思想是：<strong>先把“识别 + 决策 + 执行”闭环做起来。</strong></p>
<h4 id="351-versioncapability-discovery">3.5.1 Version/Capability Discovery（识别层：先看得见）</h4>
<p>每个 SDK/Client 请求必须携带“可观测的身份”：
- <code>X-Client-Type</code>：ios/android/web/desktop/server
- <code>X-SDK-Version</code>：语义化版本或 build id
- <code>X-Capabilities</code>：能力列表（或能力 hash）
- <code>X-Tenant-Id</code>：租户（SaaS 的灵魂字段）</p>
<p>服务端要做的事情非常朴素：<strong>把这些字段变成一等公民</strong>（日志、指标、追踪维度）。</p>
<h4 id="352-version-registry">3.5.2 Version Registry（版本目录：把“版本事实”集中管理）</h4>
<p>做一个“版本目录”（可以是服务，也可以是配置中心+管理界面）：
- 版本元数据：发布时间、支持平台、依赖版本、已知问题、安全状态
- 状态机：ACTIVE / DEPRECATED / EOL
- 映射：<code>sdk_version -&gt; capability_set</code>（重要：允许同版本多能力集）</p>
<p>别小看这个目录：它是你后面所有治理动作的“事实来源”。</p>
<h4 id="353-policy-engine">3.5.3 Policy Engine（策略引擎：把治理规则写下来）</h4>
<p>策略引擎的输入通常是：
- tenant + client_type + sdk_version + capabilities + endpoint</p>
<p>输出是一个“决策”：
- allow：正常放行
- warn：放行但返回升级提示（header/response）
- degrade：降级到兼容模式（例如关闭某能力）
- block：直接拒绝（安全漏洞、EOL 强制）
- force_upgrade：返回明确错误码 + upgrade URL（或最小版本要求）</p>
<p>策略的优先级建议这样设计：
1) 安全封禁（最高）<br>
2) 租户特例（VIP/特批）<br>
3) 全局最小版本线（min supported version）<br>
4) 渐进式弃用（deprecation schedule）<br>
5) 默认策略</p>
<h4 id="354-compatibility-layer">3.5.4 Compatibility Layer（兼容层：把“不可控的过去”关进笼子）</h4>
<p>现实是：你一定会遇到旧版本还在用。兼容层要做两件事：
- <strong>协议兼容</strong>：字段缺失、字段语义变化、旧鉴权方式
- <strong>行为兼容</strong>：旧流程依赖的“历史 bug”（是的，有些 bug 也是契约）</p>
<p>但兼容层必须有“寿命”：<br>
每一条兼容逻辑都要在 Version Registry 里绑定一个“到期日/替代方案/影响租户列表”，否则它会变成永久债务。</p>
<h4 id="355-upgrade-experience">3.5.5 Upgrade Experience（升级体验：别让客户升级像渡劫）</h4>
<p>你可以强制升级，但你更应该让升级“可操作”：
- 返回明确错误码（例如 <code>SDK_VERSION_TOO_OLD</code>）
- 提供升级指引链接（文档、SDK 下载、迁移指南）
- 关键变更提供“迁移期”：warn -&gt; degrade -&gt; block 的三段式节奏</p>
<h3 id="36">3.6 失败路径设计：版本治理的“事故现场”都在这里</h3>
<h4 id="361">3.6.1 旧版本触发安全漏洞（必须能一键止血）</h4>
<p>你需要的是 <strong>Kill Switch</strong>，而不是“紧急发邮件”：
- 按 <code>sdk_version</code> 或 <code>build_id</code> 封禁
- 按租户封禁（某客户被攻击时快速隔离）
- 按能力封禁（某 feature 有漏洞，先关再修）</p>
<h4 id="362">3.6.2 版本看起来没问题，但能力不匹配（最难排查的那种）</h4>
<p>把“能力协商”做成协议的一部分：
- 客户端启动时拉一次 <code>capability_profile</code>
- 每次请求带 <code>capability_hash</code>
- 服务端按 hash 决策并落审计</p>
<p>这样你排查问题就不靠玄学了：<br>
“你这台客户端到底支不支持 X？”——日志里一眼就能看到。</p>
<h4 id="363-eol">3.6.3 EOL 版本还在跑，怎么办？</h4>
<p>别一刀切，按节奏：
- 第 1 阶段：warn（提示 + 埋点统计）
- 第 2 阶段：degrade（限制部分高风险能力）
- 第 3 阶段：block（明确错误码 + 升级路径）</p>
<p>同时提供“租户特批”机制：<br>
允许某些大客户延长，但必须可审计、可到期，别变成“永久特权”。</p>
<h3 id="37">3.7 演进路线：从“看得见”到“控得住”，分三步走</h3>
<p>这事最怕“一口吃成平台”，建议按闭环演进：</p>
<p>1) <strong>Phase 0：可观测性先行（1-2 周）</strong><br>
   - 统一上报 <code>client_type/sdk_version/capability</code><br>
   - 仪表盘：Top 版本分布、EOL 使用率、异常率按版本切分</p>
<p>2) <strong>Phase 1：版本目录 + 最小策略（2-4 周）</strong><br>
   - Version Registry 上线（哪怕最初是配置文件）<br>
   - Policy Engine 支持：warn + block（安全封禁优先）</p>
<p>3) <strong>Phase 2：兼容层收口 + 渐进弃用（持续迭代）</strong><br>
   - 兼容逻辑全部挂到“到期日/影响面”<br>
   - 每个季度消灭一批兼容债务（不然它会反过来消灭你）</p>
<p>最后一句话总结：<br>
<strong>SDK/Client Version 治理不是“管理版本号”，而是把“识别-决策-执行-审计”变成系统能力。</strong></p>
<hr>
<h2 id="4">4. 常见坑：你以为你在用第一性原理，其实你在“重命名偏见”</h2>
<h3 id="1_1">坑 1：把“约束”当“借口”</h3>
<p>“我们时间紧，所以先不做监控。”<br>
翻译一下：<strong>我们更愿意把问题留给未来的自己（或者值班同学）。</strong></p>
<p>更靠谱的做法是：<br>
监控不做全量，但做最小闭环：关键接口指标 + 错误日志 + 追踪采样。<br>
别把“没有”当成“以后会有”。</p>
<h3 id="2_1">坑 2：只推导成功路径</h3>
<p>成功路径永远很美，失败路径才是你系统的真实样子。<br>
尤其是分布式系统：<strong>超时比报错更常见</strong>，因为它会让你误以为“也许成功了”。</p>
<p>建议你把“失败矩阵”写进设计文档：
- 下游超时 -&gt; 重试/降级/熔断？
- 重试导致放大流量 -&gt; 限流/隔离？
- 重复请求 -&gt; 幂等键？
- 部分失败 -&gt; 补偿任务/对账？</p>
<hr>
<h2 id="5_1">5. 我常用的“第一性原理架构画布”（模板）</h2>
<p>你可以直接复制到设计文档里：</p>
<div class="highlight"><pre><span></span><code>【场景】谁在什么情况下用？峰值与频率？
【目标】SLO / 延迟 / 吞吐 / 成本 / 交付窗口
【不变量】合规 / 一致性 / 可用性（至少3条）
【约束】人/钱/时间/环境/组织
【推导】不变量/约束 -&gt; 设计选择 -&gt; 代价 -&gt; 缓解
【边界】一致性域划分、数据归属、职责边界
【失败路径】超时/重试/降级/熔断/限流/幂等/补偿
【可观测性】日志/指标/追踪/审计/成本
【演进路线】MVP -&gt; v2 -&gt; v3（拆分/扩容/迁移）
【决策记录】ADR 列表（为什么这样选，未来怎么推翻）
</code></pre></div>

<hr>
<h2 id="_2">总结</h2>
<p>第一性原理不是“把问题想得更复杂”，恰恰相反：它是<strong>把架构从潮流里捞出来，放回需求与约束的地面上</strong>。<br>
当你能清晰写出“不变量”和“约束”，很多争论会自动消失——因为答案已经被推导出来了。</p>
<h2 id="_3">扩展阅读</h2>
<ul>
<li>“Architecture Decision Record (ADR)”：用可追溯的方式记录取舍（搜索关键词：<code>ADR template</code>）</li>
<li>“Release It!”：失败模式、稳定性、隔离与熔断（一本老书，但很能打）</li>
<li>“Designing Data-Intensive Applications”：一致性、复制、分区、流式系统（厚，但值）</li>
<li>“Google SRE Book”：SLO/错误预算/可靠性工程方法论</li>
</ul>
<hr/>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="./tag/journal.html">journal</a>
      <a href="./tag/blog.html">blog</a>
      <a href="./tag/architecture.html">architecture</a>
      <a href="./tag/design.html">design</a>
      <a href="./tag/first-principles.html">first-principles</a>
    </p>
  </div>


  <div class="neighbors">
    <a class="btn float-left" href="./cursor-de-san-ban-fu-rules-commands-yu-agent-skills.html" title="Cursor 的三板斧：Rules, Commands 与 Agent Skills">
      <i class="fa fa-angle-left"></i> Previous Post
    </a>
    <a class="btn float-right" href="./xie-gei-ji-jiang-du-yan-de-ni-yi-ge-lao-cheng-xu-yuan-de-ru-xing-zhi-nan.html" title="写给即将读研的你：一个老程序员的入行指南">
      Next Post <i class="fa fa-angle-right"></i>
    </a>
  </div>

  <div class="related-posts">
    <h4>You might enjoy</h4>
    <ul class="related-posts">
      <li><a href="./operator-terraform-dui-chuan-tong-yun-wei-de-gai-bian.html">Operator + Terraform 对传统运维的改变</a></li>
      <li><a href="./zhi-chang-zhong-na-xie-huo-de-zui-jiu-de-fang-fa-lun-suo-xie.html">职场中那些“活得最久”的方法论缩写</a></li>
      <li><a href="./zui-tong-yong-de-6-da-yan-jiang-kuang-jia.html">最通用的 6 大演讲框架</a></li>
      <li><a href="./bie-liao-2025.html">别了, 2025</a></li>
      <li><a href="./ai-agent-she-ji-yu-luo-di.html">AI Agent 设计与落地</a></li>
    </ul>
  </div>



<!-- Disqus -->
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'wfblog';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>
    Please enable JavaScript to view comments.
</noscript>
<!-- End Disqus -->
</article>

<footer>
<p>&copy; 2010 ~ 2030  Walter Fan <a href="https://beian.miit.gov.cn" target="_blank">皖ICP备20001876号-1</a></p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
</p><!-- StatusCake -->

<!-- End StatusCake --></footer>  </main>

<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Walter Fan's Blog ",
  "url" : ".",
  "image": "./images/walterfan.jpg",
  "description": "an old programmer never die, he just branch to a new address."
}
</script>
</body>
</html>