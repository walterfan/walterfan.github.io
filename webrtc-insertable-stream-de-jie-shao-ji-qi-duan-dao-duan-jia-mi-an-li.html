
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="./theme/stylesheet/style.min.css">


    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
          href="./theme/pygments/github.min.css">



  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/solid.css">


  <link rel="shortcut icon" href="./images/favicon.ico" type="image/x-icon">
  <link rel="icon" href="./images/favicon.ico" type="image/x-icon">










 

<meta name="author" content="Walter Fan" />
<meta name="description" content="Daily minute" />
<meta name="keywords" content="journal, blog">


  <meta property="og:site_name" content="Walter Fan's Blog"/>
  <meta property="og:title" content="WebRTC Insertable Stream 的介绍及其端到端加密案例"/>
  <meta property="og:description" content="Daily minute"/>
  <meta property="og:locale" content="en_US"/>
  <meta property="og:url" content="./webrtc-insertable-stream-de-jie-shao-ji-qi-duan-dao-duan-jia-mi-an-li.html"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="2021-10-06 10:20:00+08:00"/>
  <meta property="article:modified_time" content="2021-10-06 19:30:00+08:00"/>
  <meta property="article:author" content="./author/walter-fan.html">
  <meta property="article:section" content="Journal"/>
  <meta property="article:tag" content="journal"/>
  <meta property="article:tag" content="blog"/>
  <meta property="og:image" content="./images/walterfan.jpg">

  <title>Walter Fan's Blog &ndash; WebRTC Insertable Stream 的介绍及其端到端加密案例</title>


</head>
<body class="light-theme">

<aside>
  <div>
    <a href="./">
      <img src="./images/walterfan.jpg" alt="Walter Fan" title="Walter Fan">
    </a>

    <h1>
      <a href="./">Walter Fan</a>
    </h1>

    <p>手握灵珠常奋笔, 心开天籁不吹箫</p>


    <nav>
      <ul class="list">



          <li>
            <a target="_self" href="/tao" >tao</a>
          </li>
          <li>
            <a target="_self" href="interest.html" >interest</a>
          </li>
          <li>
            <a target="_self" href="/wordpress" >notebook</a>
          </li>
          <li>
            <a target="_self" href="bookmark.html" >bookmark</a>
          </li>
          <li>
            <a target="_self" href="/webrtc/examples/index.html" >webrtc</a>
          </li>
          <li>
            <a target="_self" href="https://github.com/walterfan" >github</a>
          </li>
          <li>
            <a target="_self" href="https://www.jianshu.com/u/e0b365801f48" >技术文章</a>
          </li>
          <li>
            <a target="_self" href="/tao/tech" >技术笔记</a>
          </li>
          <li>
            <a target="_self" href="/tao/tool" >我的工具</a>
          </li>
          <li>
            <a target="_self" href="/tao" >给我留言</a>
          </li>
      </ul>
    </nav>

    <ul class="social">
      <li>
        <a class="sc-github"
           href="http://github.com/walterfan"
           target="_blank">
          <i class="fa-brands fa-github"></i>
        </a>
      </li>
      <li>
        <a class="sc-weibo"
           href="http://weibo.com/walterfan"
           target="_blank">
          <i class="fa-brands fa-weibo"></i>
        </a>
      </li>
    </ul>
  </div>

</aside>
  <main>


<article class="single">
  <header>
      
    <h1 id="webrtc-insertable-stream-de-jie-shao-ji-qi-duan-dao-duan-jia-mi-an-li">WebRTC Insertable Stream 的介绍及其端到端加密案例</h1>
    <p>
      Posted on Wed 06 October 2021 in <a href="./category/journal.html">Journal</a>

    </p>
  </header>


  <div>
    <table>
<thead>
<tr>
<th><strong>Abstract:</strong></th>
<th>WebRTC Insertable Stream 的介绍及其端到端加密案例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Authors:</strong></td>
<td>Walter Fan</td>
</tr>
<tr>
<td><strong>Status:</strong></td>
<td>WIP</td>
</tr>
<tr>
<td><strong>Class:</strong></td>
<td>Learning Minutes</td>
</tr>
<tr>
<td><strong>Updated:</strong></td>
<td>2021-10-16</td>
</tr>
<tr>
<td><strong>Link:</strong></td>
<td>https://www.jianshu.com/u/e0b365801f48</td>
</tr>
</tbody>
</table>
<h2 id="_1">目录</h2>
<ul>
<li>Insertable Stream 概述</li>
<li>Stream API</li>
<li>用例</li>
<li>接口与模型</li>
<li>可读流 ReadableStream</li>
<li>可写流 WritableStream</li>
<li>管道链 Pipe chains</li>
<li>可插入流 Insertable Streams API</li>
<li>SFrameTransform</li>
<li>RTCRtpScriptTransform</li>
<li>案例 - 端到端加密</li>
<li>通过 WebRTC Insertable Streams 实现的真正的端到端加密</li>
<li>参考资料</li>
</ul>
<h2 id="_2">概述</h2>
<p>Insertable Stream 可插入的流是新的 WebRTC API, 可用来操作通过 RTCPeerConnection 传送的 MediaStreamTracks 中的每一个字节。它让上层应用能对 WebRTC 底层媒体进行访问，让以往 WebRTC 应用中许多不可能做的情况都成为可能了， 比如替换视频聊天时的背景，实时进行音视频处理（降噪，美颜，打水印，加特效等）</p>
<h3 id="_3">所解决的问题</h3>
<p>我们需要 WebRTC 提供 API</p>
<ul>
<li>允许用户指定的处理，而不仅仅只能通过浏览器</li>
<li>允许浏览器处理由用户处理过的数据，就好像它是通过正常的处理管道一样</li>
<li>允许使用 WASM 等技术实现更有效的媒体处理</li>
<li>允许使用像 Workers 这样的技术来避免主线程阻塞</li>
<li>不会对当前通信的安全或隐私产生负面影响</li>
</ul>
<h2 id="stream-api">Stream API</h2>
<p>Streams 标准提供了一组通用的 API，用于创建此类流数据并与之交互，这些数据体现在可读流、可写流和转换流中。</p>
<ul>
<li>readable streams</li>
<li>writable streams</li>
<li>transform streams</li>
</ul>
<p>这些 API 旨在更有效地映射到低级的 I/O 原始操作，包括在适当的情况下对字节流进行专门的处理。</p>
<p>它们允许将多个流轻松组合到管道链中，或者可以通过读取器和写入器直接使用。最后，它们被设计为自动提供背压和排队。</p>
<ul>
<li>阅读 <a href="" title="Streams API Concepts">Streams API Concepts</a> 来了解背后的基本概念</li>
</ul>
<h3 id="_4">用例</h3>
<ul>
<li>视频特效: 传入一个视频流 ，通过 transform stream 来实时地应用特效</li>
<li>解压： 传入一个文件流，通过 transform stream 有选择地从压缩包中解压文件，当用户滚动浏览图库时将它们转换为 img  元素。</li>
<li>图像解码：传入一个 HTTP 响应流，通过 transform stream 将字节流解码为 bitmap，再接一个 transform stream 将 bitmap 转换为 png</li>
<li>加解密：传入一个音视频流，通过 transform stream 来实时地对发送的音视频帧进行加密，或者 对接收到的音视频帧进行解密</li>
</ul>
<p>下面我们会提到的一个端到端加密的例子</p>
<h2 id="_5">接口与模型</h2>
<p>一个数据块，称之为 chunk，它是从一个流中读入或写出的一个数据片段，它可以是任意类型，一个流甚至可以包含不同类型的 chunk。</p>
<p>对于给定的流，chunk 通常不是最原子的数据单元； 例如，字节流可能包含由 Uint8Array 组成的块，而不是单个字节。</p>
<h3 id="readablestream">可读流 ReadableStream</h3>
<p>readable stream 是在 JavaScript 中由来自底层的 ReadableStream 对象表示的数据源------这是网络上或者本地某个地方的资源，可以从中获取数据。</p>
<p><img alt="readable stream" src="https://upload-images.jianshu.io/upload_images/1598924-5ae0f3290bce4297.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>有两种类型的底层数据源：</p>
<p>1)  推送源 Push sources，它在您访问它时不断向您推送数据，可以开始、暂停或取消对流的访问，例如视频流和 TCP/Web 套接字中的数据流。
2)  拉取源 Pull sources： 它要求您在连接后明确向它们请求数据，例如通过 Fetch 或 XHR 调用进行的文件访问操作.</p>
<p>ReadableStream 代码示例：</p>
<div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">ReadableStream</span><span class="p">({</span>
<span class="w">        </span><span class="nx">start</span><span class="p">(</span><span class="nx">controller</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="nx">pull</span><span class="p">(</span><span class="nx">controller</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="nx">cancel</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="nx">type</span><span class="p">,</span>
<span class="w">        </span><span class="nx">autoAllocateChunkSize</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="nx">highWaterMark</span><span class="p">,</span>
<span class="w">        </span><span class="nx">size</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">);</span>
</pre></div>


<h3 id="writablestream">可写流 WritableStream</h3>
<p>可写流是您可以写入数据的目的地，在 JavaScript 中由 WritableStream 对象表示。 它用作对于底层接收器之上的抽象，一个可写入原始数据的底层的 I/O sink。</p>
<p><img alt="WritableStream" src="https://upload-images.jianshu.io/upload_images/1598924-2f236d235bc7ec0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>WritableStream 代码示例：</p>
<div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">WritableStream</span><span class="p">({</span>
<span class="w">        </span><span class="nx">start</span><span class="p">(</span><span class="nx">controller</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="nx">write</span><span class="p">(</span><span class="nx">chunk</span><span class="p">,</span><span class="nx">controller</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="nx">close</span><span class="p">(</span><span class="nx">controller</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="nx">abort</span><span class="p">(</span><span class="nx">reason</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="nx">highWaterMark</span><span class="p">,</span>
<span class="w">        </span><span class="nx">size</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">);</span>
</pre></div>


<h3 id="pipe-chains">管道链 Pipe chains</h3>
<p>Stream API 可以用一个称为 pipe chain 的结构将这些流一个一个串起来，具体方法有 pipeThrough 和 pipeTo</p>
<p><img alt="Stream API" src="https://upload-images.jianshu.io/upload_images/1598924-d9048d1bfc3b69d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="insertable-streams-api">可插入流 Insertable Streams API</h2>
<p>可插入流其实指的是一种转换流，它意为可以在媒体流的处理过程中插入一些处理逻辑。它可使用 RTCRtpSender 和 RTCRtpReceiver 上附加的 API 来将处理代码插入媒体流的处理管道。</p>
<div class="highlight"><pre><span></span><span class="c1">// New dictionary</span>
<span class="nx">dictionary</span><span class="w"> </span><span class="nx">RTCInsertableStreams</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">ReadableStream</span><span class="w"> </span><span class="nx">readable</span><span class="p">;</span>
<span class="w">    </span><span class="nx">WritableStream</span><span class="w"> </span><span class="nx">writable</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">typedef</span><span class="w"> </span><span class="p">(</span><span class="nx">SFrameTransform</span><span class="w"> </span><span class="nx">or</span><span class="w"> </span><span class="nx">RTCRtpScriptTransform</span><span class="p">)</span><span class="w"> </span><span class="nx">RTCRtpTransform</span><span class="p">;</span>

<span class="c1">// New methods for RTCRtpSender and RTCRtpReceiver</span>
<span class="nx">partial</span><span class="w"> </span><span class="kr">interface</span><span class="w"> </span><span class="nx">RTCRtpSender</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">attribute</span><span class="w"> </span><span class="nx">RTCRtpTransform</span><span class="o">?</span><span class="w"> </span><span class="nx">transform</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">partial</span><span class="w"> </span><span class="kr">interface</span><span class="w"> </span><span class="nx">RTCRtpReceiver</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">attribute</span><span class="w"> </span><span class="nx">RTCRtpTransform</span><span class="o">?</span><span class="w"> </span><span class="nx">transform</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>由上面的定义可知，可插入流通过转换器 RTCRtpTransform 来实现，有两种转换器</p>
<p>1)  SFrameTransform: 主要用来加解密， S 是 Secure 的首字母
2)  RTCRtpScriptTransform：指对一般的 audio/video 帧的转换</p>
<h3 id="sframetransform">SFrameTransform</h3>
<p>接口定义如下</p>
<div class="highlight"><pre><span></span><span class="kr">enum</span><span class="w"> </span><span class="nx">SFrameTransformRole</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="s2">&quot;encrypt&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="s2">&quot;decrypt&quot;</span>
<span class="p">};</span>

<span class="nx">dictionary</span><span class="w"> </span><span class="nx">SFrameTransformOptions</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">SFrameTransformRole</span><span class="w"> </span><span class="nx">role</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;encrypt&quot;</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">typedef</span><span class="w"> </span><span class="p">[</span><span class="nx">EnforceRange</span><span class="p">]</span><span class="w"> </span><span class="nx">unsigned</span><span class="w"> </span><span class="kr">long</span><span class="w"> </span><span class="kr">long</span><span class="w"> </span><span class="nx">SmallCryptoKeyID</span><span class="p">;</span>
<span class="nx">typedef</span><span class="w"> </span><span class="p">(</span><span class="nx">SmallCryptoKeyID</span><span class="w"> </span><span class="nx">or</span><span class="w"> </span><span class="nx">bigint</span><span class="p">)</span><span class="w"> </span><span class="nx">CryptoKeyID</span><span class="p">;</span>

<span class="p">[</span><span class="nx">Exposed</span><span class="o">=</span><span class="p">(</span><span class="nx">Window</span><span class="p">,</span><span class="nx">DedicatedWorker</span><span class="p">)]</span>
<span class="kr">interface</span><span class="w"> </span><span class="nx">SFrameTransform</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">constructor</span><span class="p">(</span><span class="nx">optional</span><span class="w"> </span><span class="nx">SFrameTransformOptions</span><span class="w"> </span><span class="nx">options</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{});</span>
<span class="w">    </span><span class="nb">Promise</span><span class="o">&lt;</span><span class="kc">undefined</span><span class="o">&gt;</span><span class="w"> </span><span class="nx">setEncryptionKey</span><span class="p">(</span><span class="nx">CryptoKey</span><span class="w"> </span><span class="nx">key</span><span class="p">,</span><span class="w"> </span><span class="nx">optional</span><span class="w"> </span><span class="nx">CryptoKeyID</span><span class="w"> </span><span class="nx">keyID</span><span class="p">);</span>
<span class="w">    </span><span class="nx">attribute</span><span class="w"> </span><span class="nx">EventHandler</span><span class="w"> </span><span class="nx">onerror</span><span class="p">;</span>
<span class="p">};</span>
<span class="nx">SFrameTransform</span><span class="w"> </span><span class="nx">includes</span><span class="w"> </span><span class="nx">GenericTransformStream</span><span class="p">;</span>

<span class="kr">enum</span><span class="w"> </span><span class="nx">SFrameTransformErrorEventType</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="s2">&quot;authentication&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="s2">&quot;keyID&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="s2">&quot;syntax&quot;</span>
<span class="p">};</span>

<span class="p">[</span><span class="nx">Exposed</span><span class="o">=</span><span class="p">(</span><span class="nx">Window</span><span class="p">,</span><span class="nx">DedicatedWorker</span><span class="p">)]</span>
<span class="kr">interface</span><span class="w"> </span><span class="nx">SFrameTransformErrorEvent</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">Event</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">constructor</span><span class="p">(</span><span class="nx">DOMString</span><span class="w"> </span><span class="nx">type</span><span class="p">,</span><span class="w"> </span><span class="nx">SFrameTransformErrorEventInit</span><span class="w"> </span><span class="nx">eventInitDict</span><span class="p">);</span>

<span class="w">    </span><span class="nx">readonly</span><span class="w"> </span><span class="nx">attribute</span><span class="w"> </span><span class="nx">SFrameTransformErrorEventType</span><span class="w"> </span><span class="nx">errorType</span><span class="p">;</span>
<span class="w">    </span><span class="nx">readonly</span><span class="w"> </span><span class="nx">attribute</span><span class="w"> </span><span class="nx">CryptoKeyID</span><span class="o">?</span><span class="w"> </span><span class="nx">keyID</span><span class="p">;</span>
<span class="w">    </span><span class="nx">readonly</span><span class="w"> </span><span class="nx">attribute</span><span class="w"> </span><span class="nx">any</span><span class="w"> </span><span class="nx">frame</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">dictionary</span><span class="w"> </span><span class="nx">SFrameTransformErrorEventInit</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">EventInit</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">required</span><span class="w"> </span><span class="nx">SFrameTransformErrorEventType</span><span class="w"> </span><span class="nx">errorType</span><span class="p">;</span>
<span class="w">    </span><span class="nx">required</span><span class="w"> </span><span class="nx">any</span><span class="w"> </span><span class="nx">frame</span><span class="p">;</span>
<span class="w">    </span><span class="nx">CryptoKeyID</span><span class="o">?</span><span class="w"> </span><span class="nx">keyID</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<h3 id="rtcrtpscripttransform">RTCRtpScriptTransform</h3>
<p>接口定义如下</p>
<div class="highlight"><pre><span></span><span class="c1">// 定义视频帧的类型，最终会由 WebCodecs 标准来定义</span>
<span class="kr">enum</span><span class="w"> </span><span class="nx">RTCEncodedVideoFrameType</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="s2">&quot;empty&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="s2">&quot;key&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="s2">&quot;delta&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="nx">dictionary</span><span class="w"> </span><span class="nx">RTCEncodedVideoFrameMetadata</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">long</span><span class="w"> </span><span class="kr">long</span><span class="w"> </span><span class="nx">frameId</span><span class="p">;</span>
<span class="w">    </span><span class="nx">sequence</span><span class="o">&lt;</span><span class="kr">long</span><span class="w"> </span><span class="kr">long</span><span class="o">&gt;</span><span class="w"> </span><span class="nx">dependencies</span><span class="p">;</span>
<span class="w">    </span><span class="nx">unsigned</span><span class="w"> </span><span class="kr">short</span><span class="w"> </span><span class="nx">width</span><span class="p">;</span>
<span class="w">    </span><span class="nx">unsigned</span><span class="w"> </span><span class="kr">short</span><span class="w"> </span><span class="nx">height</span><span class="p">;</span>
<span class="w">    </span><span class="kr">long</span><span class="w"> </span><span class="nx">spatialIndex</span><span class="p">;</span>
<span class="w">    </span><span class="kr">long</span><span class="w"> </span><span class="nx">temporalIndex</span><span class="p">;</span>
<span class="w">    </span><span class="kr">long</span><span class="w"> </span><span class="nx">synchronizationSource</span><span class="p">;</span>
<span class="w">    </span><span class="nx">sequence</span><span class="o">&lt;</span><span class="kr">long</span><span class="o">&gt;</span><span class="w"> </span><span class="nx">contributingSources</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//定义编码过的 video 和 audio 帧. 最终会由 WebCodecs 标准来定义.</span>
<span class="p">[</span><span class="nx">Exposed</span><span class="o">=</span><span class="p">(</span><span class="nx">Window</span><span class="p">,</span><span class="nx">DedicatedWorker</span><span class="p">)]</span>
<span class="kr">interface</span><span class="w"> </span><span class="nx">RTCEncodedVideoFrame</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">readonly</span><span class="w"> </span><span class="nx">attribute</span><span class="w"> </span><span class="nx">RTCEncodedVideoFrameType</span><span class="w"> </span><span class="nx">type</span><span class="p">;</span>
<span class="w">    </span><span class="nx">readonly</span><span class="w"> </span><span class="nx">attribute</span><span class="w"> </span><span class="nx">unsigned</span><span class="w"> </span><span class="kr">long</span><span class="w"> </span><span class="kr">long</span><span class="w"> </span><span class="nx">timestamp</span><span class="p">;</span>
<span class="w">    </span><span class="nx">attribute</span><span class="w"> </span><span class="nb">ArrayBuffer</span><span class="w"> </span><span class="nx">data</span><span class="p">;</span>
<span class="w">    </span><span class="nx">RTCEncodedVideoFrameMetadata</span><span class="w"> </span><span class="nx">getMetadata</span><span class="p">();</span>
<span class="p">};</span>

<span class="c1">//音频帧的元数据，包含RTP中定义的 SSRC, CSRC</span>
<span class="nx">dictionary</span><span class="w"> </span><span class="nx">RTCEncodedAudioFrameMetadata</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">long</span><span class="w"> </span><span class="nx">synchronizationSource</span><span class="p">;</span>
<span class="w">    </span><span class="nx">sequence</span><span class="o">&lt;</span><span class="kr">long</span><span class="o">&gt;</span><span class="w"> </span><span class="nx">contributingSources</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">[</span><span class="nx">Exposed</span><span class="o">=</span><span class="p">(</span><span class="nx">Window</span><span class="p">,</span><span class="nx">DedicatedWorker</span><span class="p">)]</span>
<span class="kr">interface</span><span class="w"> </span><span class="nx">RTCEncodedAudioFrame</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">readonly</span><span class="w"> </span><span class="nx">attribute</span><span class="w"> </span><span class="nx">unsigned</span><span class="w"> </span><span class="kr">long</span><span class="w"> </span><span class="kr">long</span><span class="w"> </span><span class="nx">timestamp</span><span class="p">;</span>
<span class="w">    </span><span class="nx">attribute</span><span class="w"> </span><span class="nb">ArrayBuffer</span><span class="w"> </span><span class="nx">data</span><span class="p">;</span>
<span class="w">    </span><span class="nx">RTCEncodedAudioFrameMetadata</span><span class="w"> </span><span class="nx">getMetadata</span><span class="p">();</span>
<span class="p">};</span>


<span class="c1">// 定义 JavaScript-based transforms.</span>

<span class="p">[</span><span class="nx">Exposed</span><span class="o">=</span><span class="nx">DedicatedWorker</span><span class="p">]</span>
<span class="kr">interface</span><span class="w"> </span><span class="nx">RTCTransformEvent</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">Event</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">readonly</span><span class="w"> </span><span class="nx">attribute</span><span class="w"> </span><span class="nx">RTCRtpScriptTransformer</span><span class="w"> </span><span class="nx">transformer</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">partial</span><span class="w"> </span><span class="kr">interface</span><span class="w"> </span><span class="nx">DedicatedWorkerGlobalScope</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">attribute</span><span class="w"> </span><span class="nx">EventHandler</span><span class="w"> </span><span class="nx">onrtctransform</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">[</span><span class="nx">Exposed</span><span class="o">=</span><span class="nx">DedicatedWorker</span><span class="p">]</span>
<span class="kr">interface</span><span class="w"> </span><span class="nx">RTCRtpScriptTransformer</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">readonly</span><span class="w"> </span><span class="nx">attribute</span><span class="w"> </span><span class="nx">ReadableStream</span><span class="w"> </span><span class="nx">readable</span><span class="p">;</span>
<span class="w">    </span><span class="nx">readonly</span><span class="w"> </span><span class="nx">attribute</span><span class="w"> </span><span class="nx">WritableStream</span><span class="w"> </span><span class="nx">writable</span><span class="p">;</span>
<span class="w">    </span><span class="nx">readonly</span><span class="w"> </span><span class="nx">attribute</span><span class="w"> </span><span class="nx">any</span><span class="w"> </span><span class="nx">options</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">[</span><span class="nx">Exposed</span><span class="o">=</span><span class="nx">Window</span><span class="p">]</span>
<span class="kr">interface</span><span class="w"> </span><span class="nx">RTCRtpScriptTransform</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">constructor</span><span class="p">(</span><span class="nx">Worker</span><span class="w"> </span><span class="nx">worker</span><span class="p">,</span><span class="w"> </span><span class="nx">optional</span><span class="w"> </span><span class="nx">any</span><span class="w"> </span><span class="nx">options</span><span class="p">,</span><span class="w"> </span><span class="nx">optional</span><span class="w"> </span><span class="nx">sequence</span><span class="o">&lt;</span><span class="nx">object</span><span class="o">&gt;</span><span class="w"> </span><span class="nx">transfer</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>


<h2 id="-">案例 - 端到端加密</h2>
<p>一般在视频会议中，各个终端会与服务器建立 SRTP 连接， 服务器会做 SRTP 的解密。</p>
<p><img alt="srtp" src="https://upload-images.jianshu.io/upload_images/1598924-bb66aa680702bf58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这样的方式对于一些需要高度机密的客户是不可接受的，这时候就需要端到端的加密，即只能在客户端才能加解密，如图所示</p>
<p><img alt="e2e" src="https://upload-images.jianshu.io/upload_images/1598924-24a83d006e0da9d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这在以入的 WebRTC 方案中是搞不定的，因为浏览器把所有的媒体流处理都封装了，上层应用没办法来直接处理媒体流的字节码，现在有了 Insertable Stream, 上图中的绿色方块中的功能就有可能了。</p>
<h3 id="webrtc-insertable-streams">通过 WebRTC Insertable Streams 实现的真正的端到端加密</h3>
<p>搭建一个本地的 peer connection, video1 元素放置本地获取的 stream, video2 元素放置从远程获取的 stream</p>
<p>这里也放置了一个 videoMonitor 元素来模拟为中间人 middlebox, 它从 peer connection 中拿到媒体流，不经 decode 而直接播放。</p>
<p>大致流程为:</p>
<div class="highlight"><pre><span></span>localStream(video1) --&gt; 加密 --&gt; peerConnection --&gt; 解密 --&gt; video2(remoteStream)
                                    |
                                    v
                                videoMonitor(未解密的)   
</pre></div>


<p>从 RTCPeerConnection 中获取 RTCRtpSender 和 RTCRtpReceiver</p>
<ul>
<li>详细解释参见:
    <a href="https://webrtchacks.com/true-end-to-end-encryption-with-webrtc-insertable-streams/" referrerpolicy="no-referrer" rel="noopener noreferrer" target="_blank" title="https://webrtchacks.com/true-end-to-end-encryption-with-webrtc-insertable-streams/">https://webrtchacks.com/true-end-to-end-encryption-with-webrtc-insertable-streams/</a></li>
<li>详细代码参见:
    <a href="https://github.com/webrtc/samples/tree/gh-pages/src/content/insertable-streams/endtoend-encryption" referrerpolicy="no-referrer" rel="noopener noreferrer" target="_blank" title="https://github.com/webrtc/samples/tree/gh-pages/src/content/insertable-streams/endtoend-encryption">https://github.com/webrtc/samples/tree/gh-pages/src/content/insertable-streams/endtoend-encryption</a></li>
</ul>
<p>效果如下：</p>
<p><img alt="snapshot" src="https://upload-images.jianshu.io/upload_images/1598924-567fb352a72b5eda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>下面的代码演示如何在原本发送到远端的视频流，RTCRtpSender 中的数据流是</p>
<div class="highlight"><pre><span></span>    readableStream --&gt; writableStream
</pre></div>


<p>现在在中间插入一个转换流</p>
<div class="highlight"><pre><span></span>    readableStream --&gt; senderTransformStream -&gt; writableStream
</pre></div>


<p>代码示例：</p>
<div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">sender</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">pc1</span><span class="p">.</span><span class="nx">addTrack</span><span class="p">(</span><span class="nx">stream</span><span class="p">.</span><span class="nx">getVideoTracks</span><span class="p">()[</span><span class="mf">0</span><span class="p">],</span><span class="w"> </span><span class="nx">stream</span><span class="p">);</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">senderStreams</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">sender</span><span class="p">.</span><span class="nx">createEncodedVideoStreams</span><span class="p">()</span><span class="w"> </span><span class="o">:</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">senderTransformStream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">TransformStream</span><span class="p">({</span>
<span class="w">    </span><span class="nx">transform</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="nx">chunk</span><span class="p">,</span><span class="w"> </span><span class="nx">controller</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//这里可以做加密</span>
<span class="w">        </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">chunk</span><span class="p">,</span><span class="w"> </span><span class="nx">chunk</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">byteLength</span><span class="p">);</span>
<span class="w">        </span><span class="nx">controller</span><span class="p">.</span><span class="nx">enqueue</span><span class="p">(</span><span class="nx">chunk</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">});</span>

<span class="nx">senderStreams</span><span class="p">.</span><span class="nx">readableStream</span>
<span class="w">    </span><span class="p">.</span><span class="nx">pipeThrough</span><span class="p">(</span><span class="nx">senderTransformStream</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="nx">pipeTo</span><span class="p">(</span><span class="nx">senderStreams</span><span class="p">.</span><span class="nx">writableStream</span><span class="p">);</span>
</pre></div>


<ul>
<li>完整代码参见 WebRTC example:
    <a href="https://webrtc.github.io/samples/src/content/insertable-streams/endtoend-encryption/" referrerpolicy="no-referrer" rel="noopener noreferrer" target="_blank" title="https://webrtc.github.io/samples/src/content/insertable-streams/endtoend-encryption/">https://webrtc.github.io/samples/src/content/insertable-streams/endtoend-encryption/</a></li>
</ul>
<p>转换流的实现是在一个 web worker 中实现的，主线程与 worker 线程通过消息来通信</p>
<div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">worker</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">Worker</span><span class="p">(</span><span class="s1">&#39;./js/worker.js&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;E2EE worker&#39;</span><span class="p">});</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">setupSenderTransform</span><span class="p">(</span><span class="nx">sender</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">senderStreams</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">sender</span><span class="p">.</span><span class="nx">createEncodedStreams</span><span class="p">();</span>

<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="nx">readable</span><span class="p">,</span><span class="w"> </span><span class="nx">writable</span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">senderStreams</span><span class="p">;</span>
<span class="w">    </span><span class="nx">worker</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">({</span>
<span class="w">            </span><span class="nx">operation</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;encode&#39;</span><span class="p">,</span>
<span class="w">            </span><span class="nx">readable</span><span class="p">,</span>
<span class="w">            </span><span class="nx">writable</span><span class="p">,</span>
<span class="w">        </span><span class="p">},</span><span class="w"> </span><span class="p">[</span><span class="nx">readable</span><span class="p">,</span><span class="w"> </span><span class="nx">writable</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">function</span><span class="w"> </span><span class="nx">setupReceiverTransform</span><span class="p">(</span><span class="nx">receiver</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">const</span><span class="w"> </span><span class="nx">receiverStreams</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">receiver</span><span class="p">.</span><span class="nx">createEncodedStreams</span><span class="p">();</span>
<span class="w">        </span><span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="nx">readable</span><span class="p">,</span><span class="w"> </span><span class="nx">writable</span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">receiverStreams</span><span class="p">;</span>
<span class="w">        </span><span class="nx">worker</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">({</span>
<span class="w">            </span><span class="nx">operation</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;decode&#39;</span><span class="p">,</span>
<span class="w">            </span><span class="nx">readable</span><span class="p">,</span>
<span class="w">            </span><span class="nx">writable</span><span class="p">,</span>
<span class="w">        </span><span class="p">},</span><span class="w"> </span><span class="p">[</span><span class="nx">readable</span><span class="p">,</span><span class="w"> </span><span class="nx">writable</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>详细代码参见
<a href="https://github.com/webrtc/samples/blob/gh-pages/src/content/insertable-streams/endtoend-encryption/js/worker.js" referrerpolicy="no-referrer" rel="noopener noreferrer" target="_blank" title="https://github.com/webrtc/samples/blob/gh-pages/src/content/insertable-streams/endtoend-encryption/js/worker.js">https://github.com/webrtc/samples/blob/gh-pages/src/content/insertable-streams/endtoend-encryption/js/worker.js</a></p>
<p>在 worker 中</p>
<ul>
<li>对于 encode 消息的处理就是插入一个用来加密的
    transformStream（处理函数为 encodeFunction）</li>
<li>对于 decode 消息的处理就是插入一个用来解密的
    transformStream（处理函数为 decodeFunction）</li>
</ul>
<div class="highlight"><pre><span></span>onmessage = async (event) =&gt; {
const {operation} = event.data;
if (operation === &#39;encode&#39;) {
    const {readable, writable} = event.data;
    const transformStream = new TransformStream({
        transform: encodeFunction,
    });
    //处理管道经由 transformStream 的 encodeFunction 做 encode
    readable
        .pipeThrough(transformStream)
        .pipeTo(writable);
} else if (operation === &#39;decode&#39;) {
    const {readable, writable} = event.data;
    const transformStream = new TransformStream({
        transform: decodeFunction,
    });
    //处理管道经由 transformStream 的 decodeFunction 做 decode
    readable
        .pipeThrough(transformStream)
        .pipeTo(writable);

} else if (operation === &#39;setCryptoKey&#39;) {
    if (event.data.currentCryptoKey !== currentCryptoKey) {
    currentKeyIdentifier++;
    }
    currentCryptoKey = event.data.currentCryptoKey;
    useCryptoOffset = event.data.useCryptoOffset;
}
};
</pre></div>


<ul>
<li>encodeFunction 的实现如下，主要是把视频帧中的数据取出，将视频数据与加密 key 进行异或, 做一个简单的加密，然后再加入 key 的标识和校验和  (checksum), 再把处理过的数据写回 encodedFrame.data。最后，将 encodedFrame 追加到 controller 的队列末尾。</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">function</span><span class="w"> </span><span class="nx">encodeFunction</span><span class="p">(</span><span class="nx">encodedFrame</span><span class="p">,</span><span class="w"> </span><span class="nx">controller</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">scount</span><span class="o">++</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">30</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// dump the first 30 packets.</span>
<span class="w">        </span><span class="nx">dump</span><span class="p">(</span><span class="nx">encodedFrame</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;send&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">currentCryptoKey</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">const</span><span class="w"> </span><span class="nx">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">DataView</span><span class="p">(</span><span class="nx">encodedFrame</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// Any length that is needed can be used for the new buffer.</span>
<span class="w">        </span><span class="kd">const</span><span class="w"> </span><span class="nx">newData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">ArrayBuffer</span><span class="p">(</span><span class="nx">encodedFrame</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">byteLength</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">5</span><span class="p">);</span>
<span class="w">        </span><span class="kd">const</span><span class="w"> </span><span class="nx">newView</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">DataView</span><span class="p">(</span><span class="nx">newData</span><span class="p">);</span>

<span class="w">        </span><span class="kd">const</span><span class="w"> </span><span class="nx">cryptoOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useCryptoOffset</span><span class="o">?</span><span class="w"> </span><span class="nx">frameTypeToCryptoOffset</span><span class="p">[</span><span class="nx">encodedFrame</span><span class="p">.</span><span class="nx">type</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">cryptoOffset</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">encodedFrame</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">byteLength</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="nx">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">newView</span><span class="p">.</span><span class="nx">setInt8</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">view</span><span class="p">.</span><span class="nx">getInt8</span><span class="p">(</span><span class="nx">i</span><span class="p">));</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// This is a bitwise xor of the key with the payload. This is not strong encryption, just a demo.</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">cryptoOffset</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">encodedFrame</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">byteLength</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="nx">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kd">const</span><span class="w"> </span><span class="nx">keyByte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">currentCryptoKey</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="nx">currentCryptoKey</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
<span class="w">            </span><span class="nx">newView</span><span class="p">.</span><span class="nx">setInt8</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">view</span><span class="p">.</span><span class="nx">getInt8</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="nx">keyByte</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// Append keyIdentifier.</span>
<span class="w">        </span><span class="nx">newView</span><span class="p">.</span><span class="nx">setUint8</span><span class="p">(</span><span class="nx">encodedFrame</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">byteLength</span><span class="p">,</span><span class="w"> </span><span class="nx">currentKeyIdentifier</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mh">0xff</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// Append checksum</span>
<span class="w">        </span><span class="nx">newView</span><span class="p">.</span><span class="nx">setUint32</span><span class="p">(</span><span class="nx">encodedFrame</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">byteLength</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mh">0xDEADBEEF</span><span class="p">);</span>

<span class="w">        </span><span class="nx">encodedFrame</span><span class="p">.</span><span class="nx">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">newData</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nx">controller</span><span class="p">.</span><span class="nx">enqueue</span><span class="p">(</span><span class="nx">encodedFrame</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<ul>
<li>decodeFunction</li>
</ul>
<p>decodeFunction 的实现如下，主要是把视频帧中的数据取出，先检查校验和(checksum), 再检查加密 key 的标识，如果都没问题就用加密 key 与视频数据进行再次异或来实现简单的解密，最后，将 decodedFrame 追加到 controller 的队列末尾。</p>
<div class="highlight"><pre><span></span>function decodeFunction(encodedFrame, controller) {
    if (rcount++ &lt; 30) { // dump the first 30 packets
        dump(encodedFrame, &#39;recv&#39;);
    }
    const view = new DataView(encodedFrame.data);
    const checksum = encodedFrame.data.byteLength &gt; 4 ? view.getUint32(encodedFrame.data.byteLength - 4) : false;
    if (currentCryptoKey) {
        if (checksum !== 0xDEADBEEF) {
            console.log(&#39;Corrupted frame received, checksum &#39; + checksum.toString(16));
            return; // 这可能是加密 key 设定了，但是收到了未加密的视频帧
        }
        const keyIdentifier = view.getUint8(encodedFrame.data.byteLength - 5);
        if (keyIdentifier !== currentKeyIdentifier) {
            // 这是加密 key 和解密的 key 不一致
            console.log(`Key identifier mismatch, got ${keyIdentifier} expected ${currentKeyIdentifier}.`);
            return;
        }

        const newData = new ArrayBuffer(encodedFrame.data.byteLength - 5);
        const newView = new DataView(newData);
        const cryptoOffset = useCryptoOffset? frameTypeToCryptoOffset[encodedFrame.type] : 0;

        for (let i = 0; i &lt; cryptoOffset; ++i) {
            newView.setInt8(i, view.getInt8(i));
        }
        for (let i = cryptoOffset; i &lt; encodedFrame.data.byteLength - 5; ++i) {
            const keyByte = currentCryptoKey.charCodeAt(i % currentCryptoKey.length);
            newView.setInt8(i, view.getInt8(i) ^ keyByte);
        }
        encodedFrame.data = newData;
    } else if (checksum === 0xDEADBEEF) {
        return; // encrypted in-flight frame but we already forgot about the key.
    }
    controller.enqueue(encodedFrame);
}
</pre></div>


<p>至此，无论是采用 P2P 还是 SFU, 都不怕再有"中间人攻击"，只有通信的双方共享一个加密 key ,他们之间才能看到彼此正常的视频。在实际应用了，加密 key的管理会更复杂，还需要加盐，加密算法多半会用 AES。</p>
<h2 id="_6">参考资料</h2>
<ul>
<li><a href="https://github.com/w3c/webrtc-encoded-transform/blob/main/explainer.md" referrerpolicy="no-referrer" rel="noopener noreferrer" target="_blank" title="Insertable Stream 的说明">Insertable Stream 的说明</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Concepts" referrerpolicy="no-referrer" rel="noopener noreferrer" target="_blank" title="Streams API 概念">Streams API 概念</a></li>
<li><a href="https://streams.spec.whatwg.org/" referrerpolicy="no-referrer" rel="noopener noreferrer" target="_blank" title="Streams API 规范">Streams API 规范</a></li>
<li><a href="https://w3c.github.io/webrtc-encoded-transform" referrerpolicy="no-referrer" rel="noopener noreferrer" target="_blank" title="Insertable Streams 标准">Insertable Streams 标准</a></li>
<li><a href="https://webrtc.github.io/samples/src/content/insertable-streams/endtoend-encryption/" referrerpolicy="no-referrer" rel="noopener noreferrer" target="_blank" title="WebRTC 端到端加密示例">WebRTC 端到端加密示例</a></li>
</ul>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="./tag/journal.html">journal</a>
      <a href="./tag/blog.html">blog</a>
    </p>
  </div>


  <div class="neighbors">
    <a class="btn float-left" href="./yong-audioworklet-lai-zuo-bai-zao-sheng.html" title="用 AudioWorklet 来做白噪声">
      <i class="fa fa-angle-left"></i> Previous Post
    </a>
    <a class="btn float-right" href="./ci-xin-an-chu-shi-wu-xiang.html" title="此心安处是吾乡">
      Next Post <i class="fa fa-angle-right"></i>
    </a>
  </div>

  <div class="related-posts">
    <h4>You might enjoy</h4>
    <ul class="related-posts">
      <li><a href="./cong-rbac-dao-abac-quan-xian-guan-li-de-yi-zhu.html">从 RBAC 到 ABAC, 权限管理的艺术</a></li>
      <li><a href="./ru-he-zheng-ming-ni-shi-ni-spifee.html">如何证明你是你 - SPIFEE</a></li>
      <li><a href="./ai-ba-zi-mu-zu-de-huo-du-gan-liao.html">AI 把字幕组的活都干了</a></li>
      <li><a href="./jmpp-rang-xmpp-xie-yi-lao-shu-kai-xin-hua.html">JMPP 让 XMPP 协议老树开新花</a></li>
      <li><a href="./bie-liao-2024ni-hao-2025.html">别了2024，你好2025</a></li>
    </ul>
  </div>



<!-- Disqus -->
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'wfblog';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>
    Please enable JavaScript to view comments.
</noscript>
<!-- End Disqus -->
</article>

<footer>
<p>&copy; 2010 ~ 2030  Walter Fan <a href="https://beian.miit.gov.cn" target="_blank">皖ICP备20001876号-1</a></p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
</p><!-- StatusCake -->

<!-- End StatusCake --></footer>  </main>

<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Walter Fan's Blog ",
  "url" : ".",
  "image": "./images/walterfan.jpg",
  "description": "an old programmer never die, he just branch to a new address."
}
</script>
</body>
</html>