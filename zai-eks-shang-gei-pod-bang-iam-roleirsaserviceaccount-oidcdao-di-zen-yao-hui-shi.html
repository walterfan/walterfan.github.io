
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="./theme/stylesheet/style.min.css">


    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
          href="./theme/pygments/github.min.css">



  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/solid.css">


  <link rel="shortcut icon" href="./images/favicon.ico" type="image/x-icon">
  <link rel="icon" href="./images/favicon.ico" type="image/x-icon">










 

<meta name="author" content="Walter Fan" />
<meta name="description" content="Node Role 像一把“万能钥匙”。IRSA 让你把权限精确绑定到 Pod：用 Kubernetes 的 ServiceAccount token 走 OIDC 联邦，去 STS 换临时凭证。" />
<meta name="keywords" content="Kubernetes, EKS, AWS, IAM, IRSA, OIDC, Security, STS">


  <meta property="og:site_name" content="Walter Fan's Blog"/>
  <meta property="og:title" content="在 EKS 上给 Pod 绑 IAM Role：IRSA（ServiceAccount + OIDC）到底怎么回事"/>
  <meta property="og:description" content="Node Role 像一把“万能钥匙”。IRSA 让你把权限精确绑定到 Pod：用 Kubernetes 的 ServiceAccount token 走 OIDC 联邦，去 STS 换临时凭证。"/>
  <meta property="og:locale" content="en_US"/>
  <meta property="og:url" content="./zai-eks-shang-gei-pod-bang-iam-roleirsaserviceaccount-oidcdao-di-zen-yao-hui-shi.html"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="2026-01-25 18:00:00+08:00"/>
  <meta property="article:modified_time" content="2026-01-25 18:00:00+08:00"/>
  <meta property="article:author" content="./author/walter-fan.html">
  <meta property="article:section" content="Kubernetes"/>
  <meta property="article:tag" content="Kubernetes"/>
  <meta property="article:tag" content="EKS"/>
  <meta property="article:tag" content="AWS"/>
  <meta property="article:tag" content="IAM"/>
  <meta property="article:tag" content="IRSA"/>
  <meta property="article:tag" content="OIDC"/>
  <meta property="article:tag" content="Security"/>
  <meta property="article:tag" content="STS"/>
  <meta property="og:image" content="./images/walterfan.jpg">

  <title>Walter Fan's Blog &ndash; 在 EKS 上给 Pod 绑 IAM Role：IRSA（ServiceAccount + OIDC）到底怎么回事</title>


</head>
<body class="light-theme">

<aside>
  <div>
    <a href="./">
      <img src="./images/walterfan.jpg" alt="Walter Fan" title="Walter Fan">
    </a>

    <h1>
      <a href="./">Walter Fan</a>
    </h1>

    <p>手握灵珠常奋笔, 心开天籁不吹箫</p>


    <nav>
      <ul class="list">



          <li>
            <a target="_self" href="tao.html" >tao</a>
          </li>
          <li>
            <a target="_self" href="interest.html" >interest</a>
          </li>
          <li>
            <a target="_self" href="/wordpress" >notebook</a>
          </li>
          <li>
            <a target="_self" href="bookmark.html" >bookmark</a>
          </li>
          <li>
            <a target="_self" href="/webrtc/examples/index.html" >webrtc</a>
          </li>
          <li>
            <a target="_self" href="https://github.com/walterfan" >github</a>
          </li>
          <li>
            <a target="_self" href="https://www.jianshu.com/u/e0b365801f48" >技术文章</a>
          </li>
      </ul>
    </nav>

    <ul class="social">
      <li>
        <a class="sc-github"
           href="http://github.com/walterfan"
           target="_blank">
          <i class="fa-brands fa-github"></i>
        </a>
      </li>
    </ul>
  </div>

</aside>
  <main>


<article class="single">
  <header>
      
    <h1 id="zai-eks-shang-gei-pod-bang-iam-roleirsaserviceaccount-oidcdao-di-zen-yao-hui-shi">在 EKS 上给 Pod 绑 IAM Role：IRSA（ServiceAccount + OIDC）到底怎么回事</h1>
    <p>
      Posted on Sun 25 January 2026 in <a href="./category/kubernetes.html">Kubernetes</a>

    </p>
  </header>


  <div>
    <table>
<thead>
<tr>
<th><strong>Abstract</strong></th>
<th>在 EKS 上实现 Pod 级 IAM Role 绑定（IRSA）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Authors</strong></td>
<td><a href="https://www.fanyamin.com">Walter Fan</a></td>
</tr>
<tr>
<td><strong>Category</strong></td>
<td>云原生安全实践</td>
</tr>
<tr>
<td><strong>Status</strong></td>
<td>v1.0</td>
</tr>
<tr>
<td><strong>Updated</strong></td>
<td>2026-01-25</td>
</tr>
<tr>
<td><strong>License</strong></td>
<td><a href="http://creativecommons.org/licenses/by-nc-nd/4.0">CC-BY-NC-ND 4.0</a></td>
</tr>
</tbody>
</table>
<h2 id="pod">开篇：你给了 Pod “公司大门钥匙”，然后怪它手痒？</h2>
<p>很多团队的第一版 EKS 权限管理是这样的：</p>
<ul>
<li>给节点（EC2）绑一个 IAM Role（instance profile）</li>
<li>业务 Pod 跑上去之后，AWS SDK 自动就能调 S3、DynamoDB、Secrets Manager</li>
</ul>
<p>这看起来很省事，像“公司统一发门禁卡”。但它有个尴尬的现实：<strong>同一台节点上的所有 Pod，理论上都能继承同一把钥匙</strong>。你本来只是想让 A 服务读一个 S3 前缀，结果 B 服务（甚至某个被攻破的 sidecar）也拿到了“顺手开门”的能力。</p>
<p><strong>反直觉点在于：问题不在 IAM 写得不够细，而在“身份粒度”不对。</strong><br>
你把权限发给了“机器（Node）”，而不是“工作负载（Pod）”。机器是共享的，工作负载才是你真正想管的边界。</p>
<p>这篇文章我想帮你把 IRSA 讲透：它不是一个“更复杂的 IAM”，而是把凭证发放从“机器”换成“工作负载身份”。读完你会拿到三件东西：</p>
<ul>
<li><strong>能讲给同事听</strong>：ServiceAccount token、OIDC、Identity Provider、STS 这些词到底各干什么</li>
<li><strong>能抄作业跑通</strong>：用 <code>eksctl + YAML</code> 把一个 Pod 绑到一个 IAM Role，并验证 <code>sts get-caller-identity</code></li>
<li><strong>能快速定位问题</strong>：遇到 403/AccessDenied，知道从 SA、token、信任策略、注入变量、CloudTrail 哪儿下手</li>
</ul>
<hr>
<h2 id="irsa-pod">一句话版：IRSA 是怎么让 Pod “合法拿到钥匙”的？</h2>
<p>一句话总结就是：</p>
<blockquote>
<p><strong>Pod 拿着 Kubernetes 发的短期 ServiceAccountToken（JWT），去 AWS STS 走 <code>AssumeRoleWithWebIdentity</code> 换一张更短期的 AWS 临时凭证；AWS 用 OIDC 的规则去验证这个 JWT 是不是你这个集群、这个 ServiceAccount 发的。</strong></p>
</blockquote>
<h3 id="irsaiam-roles-for-service-accounts">这就叫 IRSA：IAM Roles for Service Accounts</h3>
<p>IRSA 全称 <strong>IAM Roles for Service Accounts</strong>。你可以把它理解成一句很朴素的话：</p>
<blockquote>
<p><strong>把 AWS 的 IAM Role 绑定到 Kubernetes 的 ServiceAccount 上</strong>，让“用这个 SA 的 Pod”拿到属于自己的 AWS 临时凭证。</p>
</blockquote>
<p>它跟“给节点绑 Node Role”最大的区别是：<strong>权限不再按机器发，而是按工作负载发</strong>。</p>
<h3 id="irsa-node-role">为什么要 IRSA：因为 Node Role 太像“宿舍万能钥匙”</h3>
<p>不做 IRSA 时，很多集群的默认姿势是：给节点（EC2）绑一个 IAM Role。它当然省事，但也很像你给整层楼发了一把万能钥匙，然后要求大家“自觉别乱开门”。</p>
<p>IRSA 至少解决了三件现实问题：</p>
<ul>
<li><strong>最小权限更可行</strong>：你可以把权限精确到某个 ServiceAccount（进而是某类 Pod），而不是一整台节点</li>
<li><strong>凭证更安全</strong>：Pod 拿到的是 STS 的临时凭证，短期、自动轮换，避免把 AK/SK 硬编码进镜像/配置</li>
<li><strong>审计更清晰</strong>：谁在用哪个角色访问 AWS 资源，更容易在 CloudTrail/日志里对号入座</li>
</ul>
<p>接下来我们把这些关键词拆开讲清楚，再上实操。</p>
<hr>
<h2 id="podserviceaccounttokenoidcidpsts">二、先把几个词讲清楚：Pod、ServiceAccount、Token、OIDC、IdP、STS</h2>
<p>我见过不少 IRSA 失败案例，本质不是“命令敲错了”，而是几个词混在一起，像把“身份证、工牌、门禁卡、临时访客证”全叫成“卡”，然后大家一起迷路。</p>
<h3 id="0-kubernetes">0) Kubernetes 基础速通：控制面、数据面、以及“谁在什么时候插一脚”</h3>
<p>如果你对 K8s 已经很熟，这一小节可以直接跳过；但我建议你至少扫一眼，因为 IRSA 的很多“玄学问题”其实都发生在这几个人之间。</p>
<ul>
<li><strong>控制面（Control Plane）</strong>：可以理解成“公司人事 + 门禁系统 + 排班系统”的总和</li>
<li><strong>kube-apiserver</strong>：所有请求的大门口（kubectl、controller、kubelet 都要来这里办事）</li>
<li><strong>etcd</strong>：集群的“户口本”，对象最终都落在这里</li>
<li><strong>scheduler</strong>：负责“这个 Pod 去哪台节点上班”</li>
<li>
<p><strong>controller-manager</strong>：各种控制器，负责把“期望状态”往“现实状态”上推</p>
</li>
<li>
<p><strong>数据面（Data Plane）</strong>：就是“真正干活的一线员工”</p>
</li>
<li><strong>kubelet</strong>：节点上的班长，负责拉镜像、起容器、挂载卷、申请/轮换 token</li>
<li><strong>CNI/网络插件</strong>：负责让 Pod 能互相说话、能出公网</li>
<li>
<p><strong>容器运行时</strong>：containerd / CRI-O 之类，负责把容器跑起来</p>
</li>
<li>
<p><strong>Namespace</strong>：你可以当成“部门”。同名的 ServiceAccount 在不同 namespace 是两个人。</p>
</li>
<li>
<p><strong>ServiceAccount（SA）</strong>：你可以当成“工牌号”。它本身不等于权限，但它能和权限绑定。</p>
</li>
<li>
<p><strong>RBAC（Role/RoleBinding）</strong>：这是 K8s 内部权限体系：决定“这个工牌能不能在集群里办某件事”。<br>
  注意：<strong>RBAC 不会直接影响你能不能调 AWS API</strong>，那是另一套故事（IRSA）。</p>
</li>
<li>
<p><strong>Admission Webhook</strong>：可以理解成“入职体检”。Pod 真正被写入 etcd 之前，会有一轮“检查/变更”。<br>
<code>amazon-eks-pod-identity-webhook</code> 就是这种角色：它会在 PodSpec 上<strong>偷偷塞几样东西</strong>（比如环境变量、volume），让 AWS SDK 后面能自动工作。</p>
</li>
</ul>
<p>把这些角色放在心里，你后面看时序图会顺很多：<strong>apiserver 负责“准入”，kubelet 负责“落地执行”，webhook 负责“加工 PodSpec”。</strong></p>
<h3 id="1-pod-aws-api">1) Pod：真正去调 AWS API 的“那个人”</h3>
<p>Pod 是 Kubernetes 的调度单位，但你要记住一件事：</p>
<ul>
<li><strong>AWS 不认识 Pod</strong></li>
<li>AWS 只认识“某个请求携带的凭证”</li>
</ul>
<p>所以 IRSA 的本质不是“给 Pod 发权限”，而是：<strong>让 Pod 里的进程（AWS SDK / aws cli）能拿到一份只属于它的临时凭证</strong>。</p>
<h3 id="2-serviceaccountsapod-k8s">2) ServiceAccount（SA）：Pod 的“身份名片”（K8s 世界里用）</h3>
<p>ServiceAccount 是 Kubernetes 里的身份对象，主要用来做两件事：</p>
<ul>
<li><strong>集群内权限</strong>：配合 RBAC，决定这个 Pod 能不能 <code>get/list/watch</code> 某些 K8s 资源</li>
<li><strong>集群外联邦</strong>：当你把 SA token 拿去和外部系统（比如 AWS）做身份联邦时，它就成了“身份声明的载体”</li>
</ul>
<p>IRSA 里最关键的一点是：<strong>AWS 最终是按 SA 来区分“谁能换到哪一个 IAM Role”</strong>。</p>
<h3 id="3-serviceaccounttoken-jwt">3) ServiceAccountToken：不是“永不过期的钥匙”，而是“会轮换的短期 JWT”</h3>
<p>你在很多老文章里会看到“ServiceAccount token 存在一个 Secret 里”。那是旧模式，隐患也很直观：长期有效、容易被拷走、撤销成本高。</p>
<p>IRSA 依赖的是更现代的做法：<strong>Projected ServiceAccountToken</strong>（短期、可设置 audience、会轮换）。你可以把它理解成：</p>
<ul>
<li><strong>JWT（JSON Web Token）</strong>：一段带签名的字符串，里面写着“我是谁、从哪来、给谁用、什么时候过期”</li>
<li><strong>短期</strong>：过期了就得换新的（由 kubelet / apiserver 发放与轮换）</li>
</ul>
<p>这个 token 里有几个字段，你后面排错会经常用到：</p>
<ul>
<li><strong><code>iss</code></strong>（issuer）：谁签发的（对应你的集群 OIDC issuer URL）</li>
<li><strong><code>sub</code></strong>（subject）：我是谁（通常形如 <code>system:serviceaccount:&lt;namespace&gt;:&lt;serviceaccount&gt;</code>）</li>
<li><strong><code>aud</code></strong>（audience）：给谁用（IRSA 场景里常见是 <code>sts.amazonaws.com</code>）</li>
</ul>
<blockquote>
<p>你可以把它当成“访客证”：上面写了公司（iss）、姓名/部门（sub）、要去的会议室（aud）、有效期（exp）。</p>
</blockquote>
<h3 id="4-oidc-jwt">4) OIDC：一套“外部怎么验证这个 JWT 是真的”的标准流程</h3>
<p>OIDC（OpenID Connect）在这里你不用背规范，把它当成三件事就够了：</p>
<ul>
<li><strong>Issuer</strong>：一个 URL，告诉大家“token 的发行方是谁”</li>
<li><strong>Discovery</strong>：在 <code>/.well-known/openid-configuration</code> 这个路径上，别人能发现 issuer 的各种信息（尤其是 <code>jwks_uri</code>）</li>
<li><strong>JWKS（公钥集合）</strong>：在 <code>jwks_uri</code> 上，别人能拿到用于验签的公钥（通常带 <code>kid</code>）</li>
</ul>
<p>也就是说：<strong>AWS 不需要“相信你的人品”，它只需要能按 OIDC 的规则验证 token 的签名与声明</strong>。</p>
<h3 id="5-identity-provideridp-irsa-idp">5) Identity Provider（IdP）：在 IRSA 里，“IdP 指的是你的集群”</h3>
<p>这句话很多人会绕：不是 AWS 是 IdP，也不是你的应用是 IdP。</p>
<p>在 IRSA 语境下：</p>
<ul>
<li><strong>Kubernetes/EKS 暴露 OIDC issuer + JWKS</strong>（它能签 token，也能让外部验证）</li>
<li><strong>AWS IAM 里创建一个 OIDC Provider</strong>，指向这个 issuer（相当于告诉 AWS：“以后看到这个 issuer 的 token，就按这个规则验”）</li>
</ul>
<p>所以“Identity Provider”指的是<strong>Kubernetes 集群这个身份发行方</strong>；AWS 是“依赖方/验证方”（relying party/verifier）。</p>
<h3 id="6-sts-aws">6) STS：把“身份声明”换成“可用的 AWS 临时凭证”</h3>
<p>应用最终需要的不是 JWT，而是 AWS API 能用的临时凭证（AccessKeyId/SecretAccessKey/SessionToken）。</p>
<p>所以 IRSA 最关键的 API 是：</p>
<ul>
<li><code>AssumeRoleWithWebIdentity</code>：你拿着 web identity token（SA token）来，STS 验证 OK 后，给你一份短期 AWS 凭证</li>
</ul>
<p>到这一步，AWS SDK 的默认凭证链就能工作了：它会从环境变量/文件里拿到 token 与 role arn，自动去 STS 换凭证并缓存刷新。</p>
<hr>
<h2 id="irsa">三、IRSA 的工作原理</h2>
<ul>
<li>kube-apiserver 不会“上传公钥给 AWS”，它是<strong>暴露 OIDC discovery/JWKS 端点</strong>，AWS 需要时去拉</li>
<li>token 的轮换不是“写死一个 secret”，而是基于 <strong>TokenRequest + projected token</strong> 的短期发放与轮换</li>
</ul>
<p>简化的时序图如下：
<img alt="IRSA Workflow" src="./images/IRSA.png"></p>
<div class="highlight"><pre><span></span><code>sequenceDiagram
    participant KubeAPIServer as KubeAPIServer
    participant OIDCDiscovery as OIDCDiscoveryEndpoint
    participant PodIdentityWebhook as PodIdentityWebhook
    participant Kubelet as Kubelet
    participant Pod as Pod
    participant AWSSTS as AWS_STS

    KubeAPIServer-&gt;&gt;KubeAPIServer: 配置SA token issuer与签名(集群侧)
    KubeAPIServer-&gt;&gt;OIDCDiscovery: 暴露/.well-known与JWKS(公钥)
    OIDCDiscovery--&gt;&gt;KubeAPIServer: 可被外部发现与拉取

    KubeAPIServer-&gt;&gt;KubeAPIServer: 创建Pod(引用某个ServiceAccount)
    KubeAPIServer-&gt;&gt;PodIdentityWebhook: AdmissionWebhook变更PodSpec(注入role与token文件)
    PodIdentityWebhook--&gt;&gt;KubeAPIServer: 返回已注入的PodSpec

    Kubelet-&gt;&gt;Pod: 启动容器并挂载projected SA token
    Kubelet-&gt;&gt;KubeAPIServer: 通过TokenRequest申请/轮换短期token
    KubeAPIServer--&gt;&gt;Kubelet: 返回签名后的JWT(SA token)
    Kubelet--&gt;&gt;Pod: 把token写入挂载文件

    Pod-&gt;&gt;AWSSTS: AssumeRoleWithWebIdentity(带SA token + role_arn)
    AWSSTS-&gt;&gt;OIDCDiscovery: 拉取OIDC配置与JWKS(需要时)
    OIDCDiscovery--&gt;&gt;AWSSTS: 返回issuer/jwks(公钥)
    AWSSTS--&gt;&gt;Pod: 返回AWS临时凭证
    Pod-&gt;&gt;AWSSTS: 使用临时凭证访问AWS资源
</code></pre></div>

<p>把这个图翻译成人话，就是四句话：</p>
<ul>
<li><strong>K8s 集群会签发短期的 SA token（JWT）</strong>，并提供“别人如何验它”的公钥与 discovery 信息</li>
<li><strong>PodIdentityWebhook 负责“把需要的材料塞进 Pod”</strong>（常见是 <code>AWS_ROLE_ARN</code> 和 <code>AWS_WEB_IDENTITY_TOKEN_FILE</code>，以及投影 token 的 volume）</li>
<li><strong>Pod 里 AWS SDK 看到这些材料，就会去 STS 换临时凭证</strong></li>
<li><strong>STS 通过 OIDC discovery/JWKS 去验签</strong>，验过了才发临时凭证</li>
</ul>
<hr>
<h2 id="eksctl-yaml">四、实操：eksctl + YAML 一次跑通（含验证）</h2>
<p>下面这套步骤我尽量写得“能复制就跑”，并且每一步都告诉你：<strong>跑完你应该看到什么</strong>。</p>
<h3 id="step-0">Step 0：前置检查（别在第一步就掉坑里）</h3>
<ul>
<li>你有一个 EKS 集群（<code>kubectl</code> 能连上）</li>
<li>你的工作机上有：<code>aws</code> CLI、<code>eksctl</code>、<code>kubectl</code></li>
<li>你的 Pod 里使用的 AWS SDK / <code>aws</code> CLI 走默认凭证链（不要在镜像里硬编码 AK/SK）</li>
</ul>
<h3 id="step-1-oidc-provider">Step 1：关联集群的 OIDC Provider（一次性）</h3>
<div class="highlight"><pre><span></span><code>eksctl<span class="w"> </span>utils<span class="w"> </span>associate-iam-oidc-provider<span class="w"> </span>--cluster<span class="w"> </span>&lt;clusterName&gt;<span class="w"> </span>--approve
</code></pre></div>

<p>你可以把这一步理解成：<strong>在 AWS IAM 里登记“这个集群是一个 OIDC 身份发行方”</strong>。</p>
<h3 id="step-2-iam-policy-s3">Step 2：准备一个最小权限的 IAM Policy（例：只读某个 S3 前缀）</h3>
<p>示例（请把 <code>&lt;bucket&gt;</code> 和 <code>&lt;prefix&gt;</code> 替换成你自己的）：</p>
<div class="highlight"><pre><span></span><code><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;Version&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;2012-10-17&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;Statement&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;Sid&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;ListBucketPrefix&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;Effect&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Allow&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;Action&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;s3:ListBucket&quot;</span><span class="p">],</span>
<span class="w">      </span><span class="nt">&quot;Resource&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;arn:aws:s3:::&lt;bucket&gt;&quot;</span><span class="p">],</span>
<span class="w">      </span><span class="nt">&quot;Condition&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;StringLike&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="nt">&quot;s3:prefix&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;&lt;prefix&gt;/*&quot;</span><span class="p">]</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;Sid&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;GetObjects&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;Effect&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Allow&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;Action&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;s3:GetObject&quot;</span><span class="p">],</span>
<span class="w">      </span><span class="nt">&quot;Resource&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;arn:aws:s3:::&lt;bucket&gt;/&lt;prefix&gt;/*&quot;</span><span class="p">]</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div>

<p>然后用 AWS CLI 创建（你也可以用现有的 policy arn，下面只是给一个“闭环演示”）：</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 先把上面的 JSON 保存为 policy.json</span>
aws<span class="w"> </span>iam<span class="w"> </span>create-policy<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--policy-name<span class="w"> </span>demo-irsa-s3-read<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--policy-document<span class="w"> </span>file://policy.json
</code></pre></div>

<h3 id="step-3-eksctl-iam-role-serviceaccount">Step 3：用 eksctl 创建“带 IAM Role 的 ServiceAccount”</h3>
<p>这一步最省心：它会帮你把 IAM Role、信任策略、以及 K8s ServiceAccount 注解一起搞定。</p>
<div class="highlight"><pre><span></span><code>eksctl<span class="w"> </span>create<span class="w"> </span>iamserviceaccount<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--cluster<span class="w"> </span>&lt;clusterName&gt;<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--namespace<span class="w"> </span>demo<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--name<span class="w"> </span>s3-reader<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--attach-policy-arn<span class="w"> </span>arn:aws:iam::&lt;accountId&gt;:policy/demo-irsa-s3-read<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--approve
</code></pre></div>

<p>如果你想真正搞懂 IRSA（以及后面排错不抓瞎），建议你至少看一眼“信任策略（trust policy）”长什么样。核心就两点：</p>
<ul>
<li><strong>Principal 是 OIDC provider</strong>（对应这个 EKS 集群的 issuer）</li>
<li><strong>Condition 把范围锁死到某个 SA（sub）+ 某个 audience（aud）</strong></li>
</ul>
<p>一个典型的 trust policy（示例，字段以你实际 region/oidc id 为准）大概是这样：</p>
<div class="highlight"><pre><span></span><code><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;Version&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;2012-10-17&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;Statement&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;Effect&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Allow&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;Principal&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;Federated&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;arn:aws:iam::&lt;accountId&gt;:oidc-provider/oidc.eks.&lt;region&gt;.amazonaws.com/id/&lt;oidcId&gt;&quot;</span>
<span class="w">      </span><span class="p">},</span>
<span class="w">      </span><span class="nt">&quot;Action&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;sts:AssumeRoleWithWebIdentity&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;Condition&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;StringEquals&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="nt">&quot;oidc.eks.&lt;region&gt;.amazonaws.com/id/&lt;oidcId&gt;:sub&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;system:serviceaccount:demo:s3-reader&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;oidc.eks.&lt;region&gt;.amazonaws.com/id/&lt;oidcId&gt;:aud&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;sts.amazonaws.com&quot;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div>

<p>你可以用下面这个命令拿到集群的 issuer（也就是上面 <code>oidc.eks.../id/&lt;oidcId&gt;</code> 那段的来源）：</p>
<div class="highlight"><pre><span></span><code>aws<span class="w"> </span>eks<span class="w"> </span>describe-cluster<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--name<span class="w"> </span>&lt;clusterName&gt;<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--query<span class="w"> </span><span class="s2">&quot;cluster.identity.oidc.issuer&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">  </span>--output<span class="w"> </span>text
</code></pre></div>

<p>跑完你应该能看到：</p>
<ul>
<li><code>demo</code> namespace 里有一个 <code>s3-reader</code> 的 ServiceAccount</li>
<li>这个 SA 上有类似下面的注解（Role ARN 以你实际为准）：</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="nt">metadata</span><span class="p">:</span>
<span class="w">  </span><span class="nt">annotations</span><span class="p">:</span>
<span class="w">    </span><span class="nt">eks.amazonaws.com/role-arn</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">arn:aws:iam::&lt;accountId&gt;:role/&lt;roleName&gt;</span>
</code></pre></div>

<h3 id="step-4deployment-serviceaccountnameyaml">Step 4：Deployment 指定 serviceAccountName（YAML）</h3>
<p>下面用 <code>amazon/aws-cli</code> 做演示，进 Pod 后直接跑 <code>aws sts get-caller-identity</code>。</p>
<div class="highlight"><pre><span></span><code><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">apps/v1</span>
<span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Deployment</span>
<span class="nt">metadata</span><span class="p">:</span>
<span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">irsa-demo</span>
<span class="w">  </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">demo</span>
<span class="nt">spec</span><span class="p">:</span>
<span class="w">  </span><span class="nt">replicas</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">1</span>
<span class="w">  </span><span class="nt">selector</span><span class="p">:</span>
<span class="w">    </span><span class="nt">matchLabels</span><span class="p">:</span>
<span class="w">      </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">irsa-demo</span>
<span class="w">  </span><span class="nt">template</span><span class="p">:</span>
<span class="w">    </span><span class="nt">metadata</span><span class="p">:</span>
<span class="w">      </span><span class="nt">labels</span><span class="p">:</span>
<span class="w">        </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">irsa-demo</span>
<span class="w">    </span><span class="nt">spec</span><span class="p">:</span>
<span class="w">      </span><span class="nt">serviceAccountName</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">s3-reader</span>
<span class="w">      </span><span class="nt">containers</span><span class="p">:</span>
<span class="w">        </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">awscli</span>
<span class="w">          </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">public.ecr.aws/aws-cli/aws-cli:2</span>
<span class="w">          </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="s">&quot;sh&quot;</span><span class="p p-Indicator">,</span><span class="w"> </span><span class="s">&quot;-c&quot;</span><span class="p p-Indicator">]</span>
<span class="w">          </span><span class="nt">args</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="s">&quot;sleep</span><span class="nv"> </span><span class="s">36000&quot;</span><span class="p p-Indicator">]</span>
</code></pre></div>

<p>应用：</p>
<div class="highlight"><pre><span></span><code>kubectl<span class="w"> </span>create<span class="w"> </span>namespace<span class="w"> </span>demo
kubectl<span class="w"> </span>apply<span class="w"> </span>-f<span class="w"> </span>irsa-demo.yaml
</code></pre></div>

<blockquote>
<p>说明：<code>kubectl create namespace demo</code> 如果已经存在会报错，忽略即可。</p>
</blockquote>
<h3 id="step-5">Step 5：确认注入是否生效（关键观测点）</h3>
<p>如果集群里安装了 IRSA 所需的 webhook（常见就是 <code>amazon-eks-pod-identity-webhook</code>，也可能以 EKS add-on 形式存在），你的 Pod 里一般会看到：</p>
<ul>
<li><code>AWS_ROLE_ARN</code></li>
<li><code>AWS_WEB_IDENTITY_TOKEN_FILE</code>（通常指向一个挂载文件，例如 <code>/var/run/secrets/eks.amazonaws.com/serviceaccount/token</code>）</li>
</ul>
<p>你可以这样看：</p>
<div class="highlight"><pre><span></span><code>kubectl<span class="w"> </span>-n<span class="w"> </span>demo<span class="w"> </span><span class="nb">exec</span><span class="w"> </span>deploy/irsa-demo<span class="w"> </span>--<span class="w"> </span>env<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>AWS_
kubectl<span class="w"> </span>-n<span class="w"> </span>demo<span class="w"> </span><span class="nb">exec</span><span class="w"> </span>deploy/irsa-demo<span class="w"> </span>--<span class="w"> </span>ls<span class="w"> </span>-l<span class="w"> </span>/var/run/secrets/eks.amazonaws.com/serviceaccount<span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nb">true</span>
</code></pre></div>

<p>如果你没看到这些变量/文件，先别急着怪 IAM，多半是“注入链路”没通，后面排错清单会讲怎么定位。</p>
<h3 id="step-6">Step 6：验证：看调用者到底是谁</h3>
<div class="highlight"><pre><span></span><code>kubectl<span class="w"> </span>-n<span class="w"> </span>demo<span class="w"> </span><span class="nb">exec</span><span class="w"> </span>deploy/irsa-demo<span class="w"> </span>--<span class="w"> </span>aws<span class="w"> </span>sts<span class="w"> </span>get-caller-identity
</code></pre></div>

<p>你期望看到的结果是：<code>Arn</code> 指向你给这个 SA 绑定的那个 role（而不是节点 role）。</p>
<hr>
<h2 id="irsa-403accessdenied">五、常见坑与排错清单：IRSA 403/AccessDenied 的“高频原因”</h2>
<p>我把排错按“从近到远”排了一下：先看 Pod 里有没有材料，再看 IAM 是否愿意信你。</p>
<h3 id="1-pod-serviceaccount">1) Pod 没用到你想要的 ServiceAccount</h3>
<ul>
<li>现象：你明明建了 <code>s3-reader</code>，但 Pod 还是拿到节点 role 或者直接没权限</li>
<li>排查：</li>
</ul>
<div class="highlight"><pre><span></span><code>kubectl<span class="w"> </span>-n<span class="w"> </span>demo<span class="w"> </span>get<span class="w"> </span>pod<span class="w"> </span>-l<span class="w"> </span><span class="nv">app</span><span class="o">=</span>irsa-demo<span class="w"> </span>-o<span class="w"> </span><span class="nv">jsonpath</span><span class="o">=</span><span class="s1">&#39;{.items[0].spec.serviceAccountName}{&quot;\n&quot;}&#39;</span>
kubectl<span class="w"> </span>-n<span class="w"> </span>demo<span class="w"> </span>get<span class="w"> </span>sa<span class="w"> </span>s3-reader<span class="w"> </span>-o<span class="w"> </span>yaml
</code></pre></div>

<h3 id="2-aws_role_arn-aws_web_identity_token_file">2) 没有注入 <code>AWS_ROLE_ARN</code> / <code>AWS_WEB_IDENTITY_TOKEN_FILE</code></h3>
<ul>
<li>现象：Pod 里看不到环境变量；AWS SDK 走不到 web identity 这条链</li>
<li>排查：先确认你集群里是否安装了 <code>amazon-eks-pod-identity-webhook</code>（或对应 add-on），以及它是否对该 namespace 生效</li>
</ul>
<div class="highlight"><pre><span></span><code>kubectl<span class="w"> </span>-n<span class="w"> </span>demo<span class="w"> </span><span class="nb">exec</span><span class="w"> </span>deploy/irsa-demo<span class="w"> </span>--<span class="w"> </span>env<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>AWS_
</code></pre></div>

<blockquote>
<p>备注：即便没有 webhook，你也可以手动在 Pod spec 里挂 projected token 并设置 env，但那就从“抄作业”变成“手搓器械体操”了。多数团队的最佳实践还是让 webhook 来做注入。</p>
</blockquote>
<h3 id="3-iam-role-trust-policy">3) IAM Role 的 trust policy 条件写错（最常见）</h3>
<p>IRSA 的信任策略里通常会写两类关键条件（概念上）：</p>
<ul>
<li><strong><code>sub</code> 匹配</strong>：绑定到 <code>system:serviceaccount:&lt;ns&gt;:&lt;sa&gt;</code> 这个身份</li>
<li><strong><code>aud</code> 匹配</strong>：要求 audience 是 <code>sts.amazonaws.com</code></li>
</ul>
<p>只要你 namespace 或 serviceaccount 名字对不上，STS 就会拒绝。</p>
<h3 id="4-oidc-provider">4) OIDC provider 没建好 / 建到别的集群</h3>
<ul>
<li>现象：STS 报 token issuer 不可信，或者无法找到对应 OIDC provider</li>
<li>排查：回到 Step 1，确认集群确实关联过 OIDC provider（很多人“以为做过”，其实在另一个 AWS profile 上做过）</li>
</ul>
<h3 id="5-policy">5) 你其实拿到了临时凭证，但 policy 不允许</h3>
<ul>
<li>现象：<code>sts get-caller-identity</code> 成功，但访问 S3/Secrets Manager 仍然 <code>AccessDenied</code></li>
<li>排查：</li>
<li>先看 <strong>CallerIdentity 的 Arn</strong> 是不是你期望的 role</li>
<li>再看 IAM policy 是否真的覆盖到目标资源 ARN（S3 的 bucket/object ARN 很容易写漏）</li>
</ul>
<h3 id="6-cloudtrail">6) CloudTrail：当你在黑屋里摸墙时，它就是手电筒</h3>
<p>当你看到 STS 或目标服务拒绝请求时，CloudTrail 里通常能看到更明确的失败原因（尤其是 <code>AssumeRoleWithWebIdentity</code> 相关事件）。排错时别只在 K8s 里打转。</p>
<hr>
<h2 id="2026-irsa-vs-eks-pod-identity">六、2026 该怎么选：IRSA vs EKS Pod Identity（点到为止）</h2>
<p>你这篇主线是 IRSA，我也建议绝大多数团队先把 IRSA 跑顺：资料多、生态成熟、思路清晰。</p>
<p>但你应该知道还有一个选择：<strong>EKS Pod Identity</strong>。</p>
<p>我用一句话概括差别（不展开）：</p>
<ul>
<li><strong>IRSA</strong>：靠 OIDC + IAM trust policy 把角色绑定到“某个集群的某个 SA”（信任关系更“写死”在 IAM 里）</li>
<li><strong>EKS Pod Identity</strong>：更偏“由 EKS 提供的机制/agent 来做绑定与发放”，减少你手写 OIDC/trust 的心智负担</li>
</ul>
<p>如果你要多集群复用同一套角色、或者希望降低 OIDC 相关配置的复杂度，可以把 Pod Identity 当作下一步选项（AWS 官方文档里有更完整对比与迁移思路）。</p>
<hr>
<h2 id="tldr">TL;DR（给只想抄结论的人）</h2>
<ul>
<li><strong>别把权限绑在 Node Role 上当万能钥匙</strong>：那是“方便”，不是“安全”</li>
<li><strong>IRSA 的核心</strong>：Pod 用 <strong>短期 SA token（JWT）</strong> 走 <strong>OIDC</strong> 联邦去 <strong>STS</strong> 换临时凭证</li>
<li><strong>你排错的抓手</strong>：Pod 里有没有 <code>AWS_ROLE_ARN</code> / <code>AWS_WEB_IDENTITY_TOKEN_FILE</code>，CallerIdentity 是谁，trust policy 的 <code>sub/aud</code> 是否匹配</li>
</ul>
<hr>
<h2 id="checklist">可执行清单（Checklist）</h2>
<ul>
<li>[ ] 集群已关联 OIDC provider：<code>eksctl utils associate-iam-oidc-provider ... --approve</code></li>
<li>[ ] 用 <code>eksctl create iamserviceaccount</code> 创建 SA+Role 并挂上最小权限 policy</li>
<li>[ ] Deployment 指定 <code>serviceAccountName</code></li>
<li>[ ] Pod 内验证 <code>aws sts get-caller-identity</code>，确认 Arn 是目标 role</li>
<li>[ ] 访问目标 AWS 资源做一次“最小权限验证”（读 S3 前缀/读某个 secret）</li>
<li>[ ] 出问题按顺序排查：SA -&gt; env/token -&gt; trust policy -&gt; OIDC provider -&gt; policy 资源 ARN</li>
</ul>
<hr>
<h2 id="_1">你可能会想问</h2>
<p>你现在的集群里，最想先“拆掉 Node 万能钥匙”的是哪一类权限？S3/Secrets Manager/DynamoDB 还是别的？我可以按你实际资源（比如某个 secret 的 ARN、某个 bucket 前缀）把最小权限 policy 模板再收敛一版。</p>
<hr>
<h2 id="reference">Reference</h2>
<ul>
<li>AWS Blog: <a href="https://aws.amazon.com/blogs/opensource/introducing-fine-grained-iam-roles-service-accounts/">Introducing fine-grained IAM roles for service accounts</a></li>
<li>Kubernetes 文档: <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/">Configure service accounts for pods</a></li>
<li>GitHub: <a href="https://github.com/aws/amazon-eks-pod-identity-webhook">amazon-eks-pod-identity-webhook</a></li>
<li>AWS EKS 文档: <a href="https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html">IAM roles for service accounts</a></li>
<li>AWS EKS 文档: <a href="https://docs.aws.amazon.com/eks/latest/userguide/pod-identities.html">Learn how EKS Pod Identity grants pods access to AWS services</a></li>
</ul>
<hr/>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可。</p>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="./tag/kubernetes.html">Kubernetes</a>
      <a href="./tag/eks.html">EKS</a>
      <a href="./tag/aws.html">AWS</a>
      <a href="./tag/iam.html">IAM</a>
      <a href="./tag/irsa.html">IRSA</a>
      <a href="./tag/oidc.html">OIDC</a>
      <a href="./tag/security.html">Security</a>
      <a href="./tag/sts.html">STS</a>
    </p>
  </div>


  <div class="neighbors">
    <a class="btn float-left" href="./tong-shi-bu-pei-he-zhen-de-shi-ta-men-de-wen-ti-ma.html" title="同事不配合，真的是他们的问题吗？">
      <i class="fa fa-angle-left"></i> Previous Post
    </a>
    <a class="btn float-right" href="./cong-guo-cheng-shi-ming-ling-shi-dao-sheng-ming-shi-bian-cheng-yu-yun-wei-de-yi-ci-quan-li-zhuan-yi.html" title="从过程式、命令式到声明式：编程与运维的一次“权力转移”">
      Next Post <i class="fa fa-angle-right"></i>
    </a>
  </div>

  <div class="related-posts">
    <h4>You might enjoy</h4>
    <ul class="related-posts">
      <li><a href="./cong-guo-cheng-shi-ming-ling-shi-dao-sheng-ming-shi-bian-cheng-yu-yun-wei-de-yi-ci-quan-li-zhuan-yi.html">从过程式、命令式到声明式：编程与运维的一次“权力转移”</a></li>
      <li><a href="./zai-shu-mei-pai-shang-wan-k3scong-an-zhuang-dao-shi-zhan-da-zao-ni-de-si-ren-kubernetes-ji-qun.html">在树莓派上玩 K3s：从安装到实战，打造你的私人 Kubernetes 集群</a></li>
      <li><a href="./mi-ma-cun-chu-de-yi-zhu.html">密码存储的艺术</a></li>
    </ul>
  </div>



<!-- Disqus -->
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'wfblog';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>
    Please enable JavaScript to view comments.
</noscript>
<!-- End Disqus -->
</article>

<footer>
<p>&copy; 2010 ~ 2030  Walter Fan <a href="https://beian.miit.gov.cn" target="_blank">皖ICP备20001876号-1</a></p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
</p><!-- StatusCake -->

<!-- End StatusCake --></footer>  </main>

<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Walter Fan's Blog ",
  "url" : ".",
  "image": "./images/walterfan.jpg",
  "description": "an old programmer never die, he just branch to a new address."
}
</script>
</body>
</html>